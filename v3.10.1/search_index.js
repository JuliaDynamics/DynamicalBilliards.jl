var documenterSearchIndex = {"docs":
[{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"This section has some examples of usage of DynamicalBilliards, with some brief comments.","category":"page"},{"location":"tutorials/examples/#Julia-logo-Billiard-1","page":"Examples","title":"Julia-logo Billiard","text":"","category":"section"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"The \"Julia-logo-billiard\" animation that is the logo of our package was made with the following code. The function billiard_logo also exports the same result.","category":"page"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"using DynamicalBilliards, PyPlot\n\n# %%\nh = 1.0; α = 0.8; r = 0.18; off = 0.25\n\ncos6 = cos(π/6)\nβ = (h - cos6*α)/cos6\nt = α + 2β\ncenter_of_mass = [0.0, √3*t/6]\nstartloc = [-α/2, 0.0]\n\n# create directions of the hexagonal 6:\nhexvert = [(cos(2π*i/6), sin(2π*i/6)) for i in 1:6]\ndirs = [SVector{2}(hexvert[i] .- hexvert[mod1(i+1, 6)]) for i in 1:6]\n\nframe = Obstacle{Float64}[]\nsp = startloc\nep = startloc + α*dirs[1]\nnormal = (w = ep .- sp; [-w[2], w[1]])\npush!(frame, InfiniteWall(sp, ep, normal, \"frame 1\"))\n\nfor i in 2:6\n    s = iseven(i) ? β : α\n    T = InfiniteWall #iseven(i) ? RandomWall : InfiniteWall\n    sp = frame[i-1].ep\n    ep = sp + s*dirs[i]\n    normal = (w = ep .- sp; [-w[2], w[1]])\n    push!(frame, T(sp, ep, normal, \"frame $(i)\"))\nend\n\n# Radii of circles that compose the Julia logo\noffset = [0.0, off]\nR = [cos(2π/3) -sin(2π/3);\n     sin(2π/3)  cos(2π/3)]\n\ngreen = Disk(center_of_mass .+ offset, r, \"green\")\nred = Antidot(center_of_mass .+ R*offset, r, \"red\")\npurple = RandomDisk(center_of_mass .+ R*R*offset, r, \"purple\")\n\nbd = Billiard(green, red, purple, frame...)\n\n# Raysplitting functions for the red circle:\nrefraction = (φ, pflag, ω) -> pflag ? 0.5φ : 2.0φ\ntransmission_p = (p) -> (φ, pflag, ω) -> begin\n    if pflag\n        p*exp(-(φ)^2/2(π/8)^2)\n    else\n        abs(φ) < π/4 ? (1-p)*exp(-(φ)^2/2(π/4)^2) : 0.0\n    end\nend\nnewoantidot = ((x, bool) -> bool ? -2.0x : -0.5x)\nraya = RaySplitter([2], transmission_p(0.5), refraction, newoantidot)\n\n# Create and animate particles\nN = 5\nparticles = [MagneticParticle(-0.3, 0.7 + 0.0005*i, 0.0, -2.0) for i in 1:N]\ncs = [(0, 0, i/N, 0.75) for i in 1:N]\n\nanimate_evolution(particles, bd, 10.0, (raya,);\ncolors = cs, disable_axis = true)","category":"page"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"<video width=\"100%\" height=\"auto\" controls>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/DynamicalBilliards_v3.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"tutorials/examples/#Mean-Free-Path-of-the-Lorentz-Gas-1","page":"Examples","title":"Mean Free Path of the Lorentz Gas","text":"","category":"section"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"using DynamicalBilliards\nbd = billiard_lorentz(0.2) #alias for billiard_sinai(setting = \"periodic\")\nmfp = meancollisiontime(randominside(bd), bd, 1000000.0)","category":"page"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"The result is very close to the analytic result:","category":"page"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"textmfp =  frac1-pi r^2 2r stackrelr=02= 218584","category":"page"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"which you can find for example here.","category":"page"},{"location":"tutorials/examples/#Semi-Periodic-Billiard-1","page":"Examples","title":"Semi-Periodic Billiard","text":"","category":"section"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"DynamicalBilliards allows for your system to be periodic in only some specific directions. For example, the following code produces a billiard that is periodic in only the x-direction:","category":"page"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"using DynamicalBilliards, PyPlot\no = 0.0; x = 2.0; y=1.0\n\nsp = [o,o]; ep = [o, y]; n = [x,o]\nleftw = PeriodicWall(sp, ep, n, \"Left periodic boundary\")\nsp = [x,o]; ep = [x, y]; n = [-x,o]\nrightw = PeriodicWall(sp, ep, n, \"Right periodic boundary\")\n\nsp = [o,y]; ep = [x, y]; n = [o,-y]\ntopw2 = InfiniteWall(sp, ep, n, \"Top wall\")\nsp = [o,o]; ep = [x, o]; n = [o,y]\nbotw2 = InfiniteWall(sp, ep, n, \"Bottom wall\")\n\nr = 0.25\nd = Disk([0.5, 0.5], r)\nd2 = Disk([1.5, 0.5], r/2)\n\nbd = Billiard(leftw, rightw, topw2, botw2, d, d2)\n\np = randominside(bd)\np.pos = [0.311901, 0.740439]\np.vel = [0.548772, 0.835972]\nxt, yt, t = timeseries(p, bd, 25)\nplot(bd, xt, yt)\nscatter(xt[end], yt[end], color = \"black\")\nylim(0,y)\nxlim(floor(minimum(xt)), ceil(maximum(xt)))\nsavefig(\"xperiodic.svg\"); nothing # hide","category":"page"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"tutorials/examples/#Star-billiard-1","page":"Examples","title":"Star billiard","text":"","category":"section"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"using DynamicalBilliards, PyPlot\nv = DynamicalBilliards.polygon_vertices(0.5, 5, [0,0], 0)\nv2 = DynamicalBilliards.polygon_vertices(0.25, 5, [0,0], π/5)\nvstar = []\nfor i in 1:5\n    push!(vstar, v[i], v2[i])\nend\nbd = billiard_vertices(vstar)\n\nplot(bd)\nxt, yt = timeseries(randominside(bd), bd, 10)\nplot(xt, yt)\naxis(\"off\") # hide\nsavefig(\"star.svg\"); nothing # hide","category":"page"},{"location":"tutorials/examples/#","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"mushroomtools/#","page":"MushroomTools","title":"MushroomTools","text":"MushroomTools","category":"page"},{"location":"mushroomtools/#DynamicalBilliards.MushroomTools","page":"MushroomTools","title":"DynamicalBilliards.MushroomTools","text":"MushroomTools\n\nModule containing many functions helpful in simulating (perfect) mushroom billiards, see billiard_mushroom. Contains stuff like initializing efficiently regular or chaotic particles and functions that return the corresponding chaotic or regular phase-space volumes or portions. The functions V_3D_tot and V_3D_reg use equations derived in ref. [1].\n\nMade by Lukas Hupe.\n\nReferences\n\n[1] A. Barnett & T. Betcke, Chaos 17, 043125 (2007).\n\n\n\n\n\n","category":"module"},{"location":"mushroomtools/#","page":"MushroomTools","title":"MushroomTools","text":"Notice that the name MushroomTools is exported by DynamicalBilliards. The functions within it are not though, so you have to access them like e.g. MushroomTools.randomchaotic.","category":"page"},{"location":"mushroomtools/#","page":"MushroomTools","title":"MushroomTools","text":"Modules = [MushroomTools]\nOrder   = [:function]","category":"page"},{"location":"mushroomtools/#DynamicalBilliards.MushroomTools.V_2D_tot-Tuple{Any,Any,Any}","page":"MushroomTools","title":"DynamicalBilliards.MushroomTools.V_2D_tot","text":"V_2D_tot(l,w,r)\n\nReturn the total boundary map volume (2D) of a billiard_mushroom parameterized by (l,w,r).\n\n\n\n\n\n","category":"method"},{"location":"mushroomtools/#DynamicalBilliards.MushroomTools.V_3D_tot-Tuple{Any,Any,Any}","page":"MushroomTools","title":"DynamicalBilliards.MushroomTools.V_3D_tot","text":"V_3D_tot(l,w,r)\n\nReturn the total phasespace volume (3D) of a billiard_mushroom parameterized by (l,w,r).\n\n\n\n\n\n","category":"method"},{"location":"mushroomtools/#DynamicalBilliards.MushroomTools.g_c_2D-Tuple{Any,Any,Any}","page":"MushroomTools","title":"DynamicalBilliards.MushroomTools.g_c_2D","text":"g_c_2D(l, w, r)\n\nReturn the chaotic phasespace portion of the boundary map (2D) of a billiard_mushroom with stem length l, stem width w and cap radious r. This result is known analytically, see MushroomTools for references.\n\n\n\n\n\n","category":"method"},{"location":"mushroomtools/#DynamicalBilliards.MushroomTools.g_c_3D-Tuple{Any,Any,Any}","page":"MushroomTools","title":"DynamicalBilliards.MushroomTools.g_c_3D","text":"g_c_3D(l, w, r)\n\nReturn the chaotic phasespace portion of the full (3D) phase-space of a billiard_mushroom with stem length l, stem width w and cap radious r. This result is known analytically, see MushroomTools for references.\n\n\n\n\n\n","category":"method"},{"location":"mushroomtools/#DynamicalBilliards.MushroomTools.g_r_2D-Tuple{Any,Any,Any}","page":"MushroomTools","title":"DynamicalBilliards.MushroomTools.g_r_2D","text":"g_r_2D(l, w, r)\n\nReturn the regular phasespace portion of the boundary map (2D) of a billiard_mushroom with stem length l, stem width w and cap radious r. This result is known analytically, see MushroomTools for references.\n\n\n\n\n\n","category":"method"},{"location":"mushroomtools/#DynamicalBilliards.MushroomTools.g_r_3D-Tuple{Any,Any,Any}","page":"MushroomTools","title":"DynamicalBilliards.MushroomTools.g_r_3D","text":"g_r_3D(l, w, r)\n\nReturn the regular phasespace portion of the full (3D) phase-space of a billiard_mushroom with stem length l, stem width w and cap radious r. This result is known analytically, see MushroomTools for references.\n\n\n\n\n\n","category":"method"},{"location":"mushroomtools/#DynamicalBilliards.MushroomTools.randin_mushroom-Union{Tuple{}, Tuple{T}, Tuple{T}, Tuple{T,T}, Tuple{T,T,T}} where T<:AbstractFloat","page":"MushroomTools","title":"DynamicalBilliards.MushroomTools.randin_mushroom","text":"randin_mushroom(l, w, r [, ω])\n\nGenerate a random particle within the billiard_mushroom parameterised by l, w and r. If ω is given the particle is magnetic instead.\n\nThis function is much more efficient than randominside.\n\n\n\n\n\n","category":"method"},{"location":"mushroomtools/#DynamicalBilliards.MushroomTools.randomchaotic-Tuple{Any,Any,Any}","page":"MushroomTools","title":"DynamicalBilliards.MushroomTools.randomchaotic","text":"randomchaotic(l, w, r)\n\nGenerate a chaotic particle, i.e. not trapped in the cap.\n\n\n\n\n\n","category":"method"},{"location":"mushroomtools/#DynamicalBilliards.MushroomTools.randomregular-Tuple{Any,Any,Any}","page":"MushroomTools","title":"DynamicalBilliards.MushroomTools.randomregular","text":"randomregular(l, w, r)\n\nGenerate a regular particle (i.e. trapped in the cap).\n\n\n\n\n\n","category":"method"},{"location":"visualizing/#Visualizing-and-Animating-1","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"","category":"section"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"All plotting functionality of DynamicalBilliards lies within a few well-defined functions that use the PyPlot package to plot aspects of the system.","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"All plotting functions are brought into scope when using PyPlot. The functions are:","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"DynamicalBilliards.plot(::Obstacle)\nDynamicalBilliards.plot(::Billiard)\nDynamicalBilliards.plot(::AbstractParticle, ::Bool)\nanimate_evolution","category":"page"},{"location":"visualizing/#PyPlot.plot-Tuple{Obstacle}","page":"Visualizing & Animating","title":"PyPlot.plot","text":"plot(obst::Obstacle; kwargs...)\n\nPlot given obstacle on the current PyPlot axes.\n\nThe default arguments for each type of obstacle have been chosen for maximum clarity and consistency.\n\nThe kwargs... given by the user are keywords passed directly into PyPlot's constructors. For Wall obstacles, kwargs are passed into PyPlot.plot(). For Circular obstacles, kwargs are passed into matplotlib.patches.Circle or Arc.\n\n\n\n\n\n","category":"method"},{"location":"visualizing/#PyPlot.plot-Tuple{Billiard}","page":"Visualizing & Animating","title":"PyPlot.plot","text":"plot(bd::Billiard; ax = (figure(); gca()))\n\nPlot all obstacles in bd using the default arguments, set xlim and ylim to be 20% larger than cellsize and set the axis aspect ratio to equal.\n\nplot(bd::Billiard, xmin, ymin, xmax, ymax;\n     hexagonal = false, ax = (figure(); gca()))\n\nPlot the given periodic billiard bd, repeatedly plotting from (xmin, ymin) to (xmax, ymax). Works for either rectangular periodic billiards, or hexagonal ones. Use keyword hexagonal to denote which one you want.\n\nplot(bd::Billiard, xt::Vector, yt::Vector; hexagonal = false,\n     ax = (figure(); gca()), plot_orbit = true, orbit_color = \"C0\")\n\nPlot the given billiard bd and an acompanying orbit resulting from timeseries! using the limits defined by xt and yt. Works for both periodic and normal billiards.\n\n\n\n\n\n","category":"method"},{"location":"visualizing/#PyPlot.plot-Tuple{AbstractParticle,Bool}","page":"Visualizing & Animating","title":"PyPlot.plot","text":"plot(p::AbstractParticle [, cyclotron=false]; use_cell=true, ax=gca(), kwargs...)\n\nPlot given particle on ax. Optionally use p.current_cell for the particle's position. Given kwargs... are passed onto PyPlot.scatter.\n\nThe particle is represented as a small ball (PyPlot.scatter) and a small arrow (PyPlot.quiver). All kwargs... are given to scatter but if a keyword argument color is given, it is also passed to quiver.\n\nOptionally you can plot the cyclotron traced by a MagneticParticle by giving true as second argument.\n\n\n\n\n\n","category":"method"},{"location":"visualizing/#DynamicalBilliards.animate_evolution","page":"Visualizing & Animating","title":"DynamicalBilliards.animate_evolution","text":"animate_evolution(ps, bd, colnumber [, raysplitters]; kwargs...)\n\nAnimate the evolution of a vector of particles ps in billiard bd for a total time t (always considered float). Optionally enable ray-splitting.\n\nEvolution kwargs\n\ndt = 0.01 : Time resolution used for production of time series (see timeseries!. It is not recommended to significantly increase this value, to preserve the smoothness of the orbits.\nframeskip = 5 : The amount of dt-steps performed each frame. Increasing either frameskip and dt makes the animation progress faster.\ntailtime = 1.0 : The length of the \"tail\" trailing the particle in time units.\nresetting = reset_billiard! : function called after evolving each individual particle in the billiard (so that ray-splitting doesn't break).\n\nColors & plotting kwargs\n\ncolors : An array of valid Matplotlib colors for the \"tails\". If colors is shorter than ps, colors are reused. Defaults to the standard Matplotlib color sequence.\nparticle_kwargs::NamedTuple : Additional keyword arguments passed to the plot function for particles.\ntail_kwargs::NamedTuple: Additional keyword arguments passed to the plot function for \"tails\" (line plot).\n\nExporting and axis kwargs\n\nfigsize = (7.2, 7.2)) : Size for new figure (if one is created). Must be divisible by 2 if you want to save the animation.\ndpi = 100 : DPI for saving the figures (and thus for also the resulting video).\nax = (figure(figsize = figsize); plot(bd); gca()) : axis to plot on.\nsavename = nothing : If given the animation is exported to an savetype file (requires ffmpeg). The name can include path.\nsavetype = \"mp4\" or \"gif\".\ndisable_axis = false : Remove the axis splines.\ndeletefigs = true : To create the animation a lot of figures are saved in the save directory and are deleted after the animation is done. You can choose to keep them.\nframerate = 20 : Animation framerate.\n\n\n\n\n\n","category":"function"},{"location":"visualizing/#Examples-1","page":"Visualizing & Animating","title":"Examples","text":"","category":"section"},{"location":"visualizing/#Plotting-Obstacles-with-keywords-1","page":"Visualizing & Animating","title":"Plotting Obstacles with keywords","text":"","category":"section"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"using DynamicalBilliards, PyPlot\n\nbd = billiard_sinai()\n\nfigure()\nplot(bd[2]);\nplot(bd[4], color = \"blue\", linestyle = \"dotted\", lw = 5.0);\nplot(bd[1], facecolor = \"yellow\", edgecolor = \"black\");\nsavefig(\"rand_obstacles.svg\"); nothing # hide","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"(Image: )","category":"page"},{"location":"visualizing/#Plotting-a-Billiard-1","page":"Visualizing & Animating","title":"Plotting a Billiard","text":"","category":"section"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"using DynamicalBilliards\nb = billiard_polygon(6, 1)\na = Antidot([0.0,0.0], 0.5)\nbd = Billiard(b.obstacles..., a)","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"If you want to quickly plot the entire billiard with default parameters, simply use the function plot(bd):","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"using PyPlot\nplot(bd)\nsavefig(\"billiard_example.svg\"); nothing # hide","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"(Image: )","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"plot() also sets up the axis to have equal aspect ratio and sets up the axis limits to be just large enough to contain the entire billiard.","category":"page"},{"location":"visualizing/#Plotting-particles-1","page":"Visualizing & Animating","title":"Plotting particles","text":"","category":"section"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"Following the above example, we create and plot a particle using the function plot:","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"p = randominside(bd)\nplot(p)\n# Plot one more particle with purple color,\n# pentagon shape and bigger size (default is s=30):\np2 = randominside(bd)\nplot(p2; color=(0.5, 0, 0.8), marker=\"p\", s=60.0)\np3 = randominside(bd, 2.0)\nplot(p3, true; color=(0, 0, 0.8), marker=\"o\", s=60.0)\nsavefig(\"particles_example.svg\"); nothing # hide","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"(Image: )","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"(notice that the particle position and direction are random)","category":"page"},{"location":"visualizing/#Color-conventions-1","page":"Visualizing & Animating","title":"Color conventions","text":"","category":"section"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"The default plotting settings have been chosen for maximum clarity and consistency. The color conventions followed are:","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"Particles are black.\nParticle orbits use matplotlib's color cycle (first one is blue).\nReflecting obstacles (e.g. Disk, FiniteWall etc.) are green.\nRandomly reflecting obstacles (e.g. RandomDisk or RandomWall) are purple.\nRay-splitting obstacles are red with dashed linestyle.\nPeriodicity enforcing obstacles are yellow with dotted linestyle (if and when plotted).\nDoors (FiniteWall with isdoor=true) are plotted with alternating black and cyan dashed lines.","category":"page"},{"location":"visualizing/#Animating-the-motion-of-a-particle-1","page":"Visualizing & Animating","title":"Animating the motion of a particle","text":"","category":"section"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"The function animate_evolution is provided to animate the evolution of a particle from collision to collision. Let's animate a particle inside a simple pentagon with magnetic field:","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"bd = billiard_polygon(5, 1)\na = Disk([0.0,0.0], 0.4)\nbd = Billiard(bd.obstacles..., a)\np = MagneticParticle(0, -0.5, 0, 1.0)\n\nanimate_evolution(p, bd, 10.0; savename = \"penta\")","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"<video width=\"100%\" height=\"auto\" controls> <source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/penta.mp4?raw=true\" type=\"video/mp4\"> </video>","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"The cool thing about animate_evolution is that it can animate multiple particles simultaneously! For example, here is a beautiful demonstration of chaos in non-dispersive billiards:","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"bd = billiard_stadium()\nN = 20\ncs = [(i/N, 0, 1 - i/N, 0.5) for i in 1:N]\nps = [Particle(1, 0.6 + 0.0005*i, 0) for i in 1:N]\n\nanimate_evolution(ps, bd, 10.0; colors = cs, tailtime = 1.5, savename = \"disperse\")","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"<video width=\"100%\" height=\"auto\" controls> <source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/disperse.mp4?raw=true\" type=\"video/mp4\"> </video>","category":"page"},{"location":"visualizing/#Periodic-Billiards-1","page":"Visualizing & Animating","title":"Periodic Billiards","text":"","category":"section"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"In order to plot periodic billiards, you have need to call a different method of plot, since now you also have to specify the limits of plotting. The methods provided are:","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"plot(bd, xmin, ymin, xmax, ymax)\nplot(bd, xt::Vector{T}, yt::Vector{T})","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"The last one conveniently plots the combo of particle-trajectory and periodic-billiard taking care of all the details internally. Give the keyword plot_orbit = false if you do not want to plot the orbit defined by (xt, yt).","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"For example, the following code","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"using DynamicalBilliards, PyPlot\nr = 0.25\nbd = billiard_rectangle(2, 1; setting = \"periodic\")\nd = Disk([0.5, 0.5], r)\nd2 = Ellipse([1.5, 0.5], r, 2r/3)\nbd = Billiard(bd.obstacles..., d, d2)\np = Particle(1.0, 0.5, 0.2)\nxt, yt, vxt, vyt, t = timeseries!(p, bd, 10)\nplot(bd, xt, yt)\nplot(p)\nsavefig(\"rectperiodic.svg\"); nothing # hide","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"(Image: )","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"And, you can also periodically plot billiards with hexagonal periodicity. Only give the keyword argument hexagonal = true to plot. As an example:","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"bd = billiard_hexagonal_sinai(0.3, 1.50; setting = \"periodic\")\nd = Disk([0.7, 0], 0.2)\nd2 = Antidot([0.7/2, 0.65], 0.35)\nbd = Billiard(bd..., d, d2)\n\np = MagneticParticle(-0.5, 0.5, π/5, 1.0)\n\nxt, yt = timeseries(p, bd, 10)\n\nplot(bd, xt, yt; hexagonal = true)\nsavefig(\"hexperiodic.svg\"); nothing # hide","category":"page"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"(Image: )","category":"page"},{"location":"visualizing/#Boundary-Map-plots-1","page":"Visualizing & Animating","title":"Boundary Map plots","text":"","category":"section"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"plot_boundarymap","category":"page"},{"location":"visualizing/#DynamicalBilliards.plot_boundarymap","page":"Visualizing & Animating","title":"DynamicalBilliards.plot_boundarymap","text":"plot_boundarymap(bmap, intervals; kwargs...)\n\nPlots the boundary map. The input arguments are the return values of boundarymap (also applies for the parallelized version, where bmap is a vector of vectors of 2-vectors).\n\nKeyword Arguments\n\nax = (figure(); gca()) : The axis to plot on.\ncolor = \"C0\" : The color to use for the plotted points. Can be either a color for PyPlot.plot or a vector of colors of length length(bmap), in order to give each initial condition a different color (for parallelized version).\nms = 1.0 : Marker size of the points.\nbordercolor = \"C3\" : The color of the vertical lines that denote the obstacle borders.\nobstacleindices = true: show obstacle indices above plot\nAny other keyword argument is passed to PyPlot.plot which plots the points of the section.\n\n\n\n\n\n","category":"function"},{"location":"visualizing/#","page":"Visualizing & Animating","title":"Visualizing & Animating","text":"Examples are shown in the phase spaces section.","category":"page"},{"location":"tutorials/billiard_table/#Creating-your-own-Billiard-1","page":"Defining a Billiard","title":"Creating your own Billiard","text":"","category":"section"},{"location":"tutorials/billiard_table/#The-Billiard-type-1","page":"Defining a Billiard","title":"The Billiard type","text":"","category":"section"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"Billiard","category":"page"},{"location":"tutorials/billiard_table/#DynamicalBilliards.Billiard","page":"Defining a Billiard","title":"DynamicalBilliards.Billiard","text":"Billiard(obstacles...)\n\nConstruct a Billiard from given obstacles (tuple, vector, varargs).\n\nFor functions like boundarymap, it is expected (if possible) that the obstacles of the billiard are sorted, such that the arc-coordinate ξ around the billiard is increasing counter-clockwise.\n\nξ is measured as:\n\nthe distance from start point to end point in Walls\nthe arc length measured counterclockwise from the open face in Semicircles\nthe arc length measured counterclockwise from the rightmost point in Circulars\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"A Billiard is a wrapper of a Tuple of Obstacles. The abstract Type Obstacle{T} is the supertype of all objects that a particle may collide with, with global billiard precision of type T.","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"There are many premade functions that construct well-known billiards, like the periodic Sinai billiard. You can find all of them at the Standard Billiards Library.","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"To create a custom billiard from scratch, it is often convenient to start with an empty Vector{Obstacle{T}}:","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"using DynamicalBilliards\nbd = Obstacle{Float64}[]  # T<: AbstractFloat","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"and then you create your obstacles one by one and add them to it. All obstacles that are already defined in the package can be found at the Obstacle Library below.","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"For the example of this page, we will create a hexagonal billiard with a disk in the middle step-by-step (the function billiard_polygon creates a polygonal billiard table already).","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"The first step is to define the six walls of the billiard table. An InfiniteWall object needs to be supplemented with a start point, an end point, a normal vector and, optionally, a name.","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"The vertex points of a regular hexagon of radius r are given by the formula:","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"(xy) = left( rcosleft(frac2pi i6right) rcosleft(frac2pi i6right) right) quad textfor i in 16","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"To create each wall object, we will implement the following loop:","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"hexagon_vertex = (r) -> [ [r*cos(2π*i/6), r*sin(2π*i/6)] for i in 1:6]\nhexver = hexagon_vertex(2.0)\n\nfor i in eachindex(hexver)\n  starting = hexver[i]\n  ending = hexver[mod1(i+1, length(hexver))]\n  w = ending - starting\n  normal = [-w[2], w[1]]\n  wall = InfiniteWall(starting, ending, normal, \"wall $i\")\n  push!(bd, wall)\nend\n\nsummary(bd)","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"note: Keep the size around 1.\nBecause the precision in DynamicalBilliards is measured using eps(T) with T the number type, it is advised to keep the size of the billiard in the order of magnitude of 1. Having overly large billiards with sizes of 100 or more can lead to accuracy loss!","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"The normal vector of a Wall obstacle is necessary to be supplemented by the user because it must point towards where the particle is expected to come from. If w is the vector (wall) pointing from start- to end-point then the vector [-w[2], w[1]] is pointing to the left of w and the vector [w[2], -[w1]] is pointing to the right. Both are normal to w, but you have to know which one to pick. In this case this is very easy, since the normal has to simply point towards the origin.","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"note: There is no glue.\nIn DynamicalBilliards there is no \"glue\" that combines obstacles or \"sticks\" them together, ensuring that the billiard is closed. You only have to take care that their ends meet geometrically. Even obstacle overlapping is allowed, if you want to be on the safe side!","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"We add a disk by specifying a center and radius (and optionally a name):","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"d = Disk([0,0], 0.8)\npush!(bd, d)\n# Make the structure required:\nbilliard = Billiard(bd)","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"To make sure the billiard looks as you would expect, use the function plot(bd). Create a particle inside that billiard and evolve it:","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"using PyPlot\nplot(billiard)\nω = 0.5\np = randominside(billiard, ω)\nxt, yt, vxt, vyt, t = timeseries!(p, billiard, 100)\nplot(xt, yt)\nplot(p)\nsavefig(\"tut1.svg\"); nothing # hide","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"(Image: )","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"The billiard table now works for straight or magnetic propagation. To expand this to ray-splitting you have to use ray-splitting Obstacles (see the tutorial on Ray-Splitting). Additional information on how to define your own Obstacle sub-type is given in the tutorial on Defining your own Obstacles.","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"If you make any billiard system that you think is cool and missing from this package, you are more than welcome to submit a PR extending the Standard Billiards Library with your contribution!","category":"page"},{"location":"tutorials/billiard_table/#Obstacle-order-1","page":"Defining a Billiard","title":"Obstacle order","text":"","category":"section"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"info: Obstacle order.\nThe order that the obstacles are given to the constructor is important for the function boundarymap. For any other functionality it is irrelevant.","category":"page"},{"location":"tutorials/billiard_table/#Convex-Billiards-1","page":"Defining a Billiard","title":"Convex Billiards","text":"","category":"section"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"These 2 types of walls used by DynamicalBilliards that behave differently during evolution:","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"InfiniteWall : This wall is not actually infinite. It has a starting and ending position. However, when the collision time is calculated, this wall is assumed to be a line (i.e. infinite). This is absolutely fine, as long as the billiards used are convex polygons. SplitterWall, PeriodicWall and RandomWall behave like InfiniteWall during evolution.\nFiniteWall : This wall is indeed finite in every sense of the word. This means that during collision time estimation, if the collision point that was calculated lies outside of the boundaries of the FiniteWall, then the returned collision time is Inf (no collision). FiniteWall is slower than InfiniteWall for that reason.","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"If you wish to create a billiard table that you know will be convex, you should then use InfiniteWalls for faster evolution. Notice that using escapetime requires at least one FiniteWall with field isdoor=true.","category":"page"},{"location":"tutorials/billiard_table/#Obstacle-Library-1","page":"Defining a Billiard","title":"Obstacle Library","text":"","category":"section"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"This is the list of Obstacles you can use when creating your own billiard.","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"Obstacle","category":"page"},{"location":"tutorials/billiard_table/#DynamicalBilliards.Obstacle","page":"Defining a Billiard","title":"DynamicalBilliards.Obstacle","text":"Obstacle{<:AbstractFloat}\n\nObstacle supertype.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#Curved-1","page":"Defining a Billiard","title":"Curved","text":"","category":"section"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"Disk\nRandomDisk\nAntidot\nSemicircle\nEllipse","category":"page"},{"location":"tutorials/billiard_table/#DynamicalBilliards.Disk","page":"Defining a Billiard","title":"DynamicalBilliards.Disk","text":"Disk{T<:AbstractFloat}  <: Circular{T}\n\nDisk-like obstacle with propagation allowed outside of the circle (immutable type).\n\nFields:\n\nc::SVector{2,T} : Center.\nr::T : Radius.\nname::String : Some name given for user convenience. Defaults to \"Disk\".\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#DynamicalBilliards.RandomDisk","page":"Defining a Billiard","title":"DynamicalBilliards.RandomDisk","text":"RandomDisk{T<:AbstractFloat} <: Circular{T}\n\nDisk-like obstacle that randomly (and uniformly) reflects colliding particles. The propagation is allowed outside of the circle.\n\nFields:\n\nc::SVector{2,T} : Center.\nr::T : Radius.\nname::String : Some name given for user convenience. Defaults to \"Random disk\".\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#DynamicalBilliards.Antidot","page":"Defining a Billiard","title":"DynamicalBilliards.Antidot","text":"Antidot{T<:AbstractFloat} <: Circular{T}\n\nDisk-like obstacle that allows propagation both inside and outside of the disk (mutable type). Used in ray-splitting billiards.\n\nFields:\n\nc::SVector{2,T} : Center.\nr::T : Radius.\npflag::Bool : Flag that keeps track of where the particle is currently propagating (pflag = propagation-flag). true stands for outside the disk, false for inside the disk. Defaults to true.\nname::String : Name of the obstacle given for user convenience. Defaults to \"Antidot\".\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#DynamicalBilliards.Semicircle","page":"Defining a Billiard","title":"DynamicalBilliards.Semicircle","text":"Semicircle{T<:AbstractFloat} <: Circular{T}\n\nObstacle that represents half a circle. Propagation is allowed only inside the semicircle.\n\nFields:\n\nc::SVector{2,T} : Center.\nr::T : Radius.\nfacedir::SVector{2,T} : Direction where the open face of the Semicircle is facing.\nname::String : Name of the obstacle given for user convenience. Defaults to \"Semicircle\".\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#DynamicalBilliards.Ellipse","page":"Defining a Billiard","title":"DynamicalBilliards.Ellipse","text":"Ellipse{T<:AbstractFloat}  <: Obstacle{T}\n\nEllipse obstacle that also allows ray-splitting. The ellipse is always oriented on the x and y axis (although you can make whichever you want the major one).\n\nFields:\n\nc::SVector{2,T} : Center.\na::T : x semi-axis.\nb::T : y semi-axis.\npflag::Bool : Flag that keeps track of where the particle is currently propagating. true (default) is associated with being outside the ellipse.\nname::String : Some name given for user convenience. Defaults to \"Ellipse\".\n\nThe ellipse equation is given by\n\nleft(fracx - c1a right)^2+ left(fracy - c2bright)^2 = 1\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#Lines-1","page":"Defining a Billiard","title":"Lines","text":"","category":"section"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"Wall\nInfiniteWall\nRandomWall\nPeriodicWall\nSplitterWall\nFiniteWall","category":"page"},{"location":"tutorials/billiard_table/#DynamicalBilliards.Wall","page":"Defining a Billiard","title":"DynamicalBilliards.Wall","text":"Wall{T<:AbstractFloat} <: Obstacle{T}\n\nWall obstacle supertype.\n\nAll Wall subtypes (except PeriodicWall) can be called as Wall(sp, ep), in which case the normal vector is computed automatically to point to the left of v = ep - sp.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#DynamicalBilliards.InfiniteWall","page":"Defining a Billiard","title":"DynamicalBilliards.InfiniteWall","text":"InfiniteWall{T<:AbstractFloat} <: Wall{T}\n\nWall obstacle imposing specular reflection during collision (immutable type). Faster than FiniteWall, meant to be used for convex billiards.\n\nFields:\n\nsp::SVector{2,T} : Starting point of the Wall.\nep::SVector{2,T} : Ending point of the Wall.\nnormal::SVector{2,T} : Normal vector to the wall, pointing to where the particle will come from before a collision (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.\nname::String : Name of the obstacle, given for user convenience. Defaults to \"Wall\".\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#DynamicalBilliards.RandomWall","page":"Defining a Billiard","title":"DynamicalBilliards.RandomWall","text":"RandomWall{T<:AbstractFloat} <: Wall{T}\n\nWall obstacle imposing (uniformly) random reflection during collision (immutable type).\n\nFields:\n\nsp::SVector{2,T} : Starting point of the Wall.\nep::SVector{2,T} : Ending point of the Wall.\nnormal::SVector{2,T} : Normal vector to the wall, pointing to where the particle is expected to come from (pointing towards the inside of the billiard).\nname::String : Name of the obstacle, given for user convenience. Defaults to \"Random wall\".\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#DynamicalBilliards.PeriodicWall","page":"Defining a Billiard","title":"DynamicalBilliards.PeriodicWall","text":"PeriodicWall{T<:AbstractFloat} <: Wall{T}\n\nWall obstacle that imposes periodic boundary conditions upon collision (immutable type).\n\nFields:\n\nsp::SVector{2,T} : Starting point of the Wall.\nep::SVector{2,T} : Ending point of the Wall.\nnormal::SVector{2,T} : Normal vector to the wall, pointing to where the particle will come from (to the inside the billiard). The size of the vector is important! This vector is added to a particle's pos during collision. Therefore the size of the normal vector must be correctly associated with the size of the periodic cell.\nname::String : Name of the obstacle, given for user convenience. Defaults to \"Periodic wall\".\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#DynamicalBilliards.SplitterWall","page":"Defining a Billiard","title":"DynamicalBilliards.SplitterWall","text":"SplitterWall{T<:AbstractFloat} <: Wall{T}\n\nWall obstacle imposing allowing for ray-splitting (mutable type).\n\nFields:\n\nsp::SVector{2,T} : Starting point of the Wall.\nep::SVector{2,T} : Ending point of the Wall.\nnormal::SVector{2,T} : Normal vector to the wall, pointing to where the particle will come from before a collision. The size of the vector is irrelevant.\npflag::Bool : Flag that keeps track of where the particle is currently propagating (pflag = propagation flag). true is associated with the normal vector the wall is instantiated with. Defaults to true.\nname::String : Name of the obstacle, given for user convenience. Defaults to \"Splitter wall\".\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#DynamicalBilliards.FiniteWall","page":"Defining a Billiard","title":"DynamicalBilliards.FiniteWall","text":"FiniteWall{T<:AbstractFloat} <: Wall{T}\n\nWall obstacle imposing specular reflection during collision (immutable type). Slower than InfiniteWall, meant to be used for non-convex billiards.\n\nGiving a true value to the field isdoor designates this obstacle to be a Door. This is used in escapetime function. A Door is a obstacle of the billiard that the particle can escape from, thus enabling calculations of escape times.\n\nFields:\n\nsp::SVector{2,T} : Starting point of the Wall.\nep::SVector{2,T} : Ending point of the Wall.\nnormal::SVector{2,T} : Normal vector to the wall, pointing to where the particle will come from before a collision (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.\nisdoor::Bool : Flag of whether this FiniteWall instance is a \"Door\". Defaults to false.\nname::String : Name of the obstacle, given for user convenience. Defaults to \"Finite Wall\".\n\n\n\n\n\n","category":"type"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"In addition, translate is a helpful function:","category":"page"},{"location":"tutorials/billiard_table/#","page":"Defining a Billiard","title":"Defining a Billiard","text":"translate","category":"page"},{"location":"tutorials/billiard_table/#DynamicalBilliards.translate","page":"Defining a Billiard","title":"DynamicalBilliards.translate","text":"translate(obst::Obstacle, vector)\n\nCreate a copy of the given obstacle with its position translated by vector.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#High-Level-API-1","page":"High Level API","title":"High Level API","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"DynamicalBilliards was created with ease-of-use as its main cornerstone. With 3 simple steps, the user can get the output of the propagation of a particle in a billiard.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"In general, the workflow of DynamicalBilliards follows these simple steps:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Create a billiard.\nCreate particles inside that billiard.\nGet the output you want by using one of the high level functions.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Adding more complexity in your billiard does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a RaySplitter and pass it to the high level functions.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"After reading through this page, you will be able to use almost all aspects of DynamicalBilliards with minimal effort.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"tip: Visualizations\nVisualizing the billiards, particles, and their motion is one of the most important parts of the DynamicalBilliards. It is not discussed in this page however, but rather in the Visualizing & Animating page.","category":"page"},{"location":"basic/high_level/#Billiard-1","page":"High Level API","title":"Billiard","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"A Billiard is simply a collection of Obstacle subtypes. Particles are propagating inside a Billiard, bouncing from obstacle to obstacle while having constant velocity in-between.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"There is a tutorial on how to create your own billiard. In addition, there are many pre-defined billiards that can be found in the Standard Billiards Library section. That is why knowing how to construct a Billiard is not important at this point.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"In this page we will be using the Bunimovich billiard as an example:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"using DynamicalBilliards\nbd = billiard_bunimovich()","category":"page"},{"location":"basic/high_level/#Particles-1","page":"High Level API","title":"Particles","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"A \"particle\" is that thingy that moves around in the billiard. It always moves with velocity of measure 1, by convention.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Currently there are two types of particles:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Particle, which propagates as a straight line.\nMagneticParticle, which propagates as a circle instead of a line (similar to electrons in a perpendicular magnetic field).","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"There are two ways to create a particle. The first one is to provide the constructor with some initial conditions:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"x0 = rand(); y0 = rand();\nφ0 = 2π*rand()\np = Particle(x0, y0, φ0)","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"To create a MagneticParticle simply provide the constructor with one more number, the angular velocity:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"ω = 0.5\nmp = MagneticParticle(x0, y0, φ0, ω)","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"When creating a billiard or a particle, the object is printed with {Float64} at the end. This shows what type of numbers are used for all numerical operations. If you are curious you can learn more about it in the Numerical Precision.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"danger: Particles must be inside the Billiard!\nKeep in mind that the particle must be initialized inside a billiard for any functionality to work properly and make sense. If you are not sure what we mean by that, then you should check out the Internals page.","category":"page"},{"location":"basic/high_level/#Random-initial-conditions-1","page":"High Level API","title":"Random initial conditions","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"If you have a Billiard which is not a rectangle, creating many random initial conditions inside it can be a pain. Fortunately, the second way to create a particle is to use the following function:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"randominside","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.randominside","page":"High Level API","title":"DynamicalBilliards.randominside","text":"randominside(bd::Billiard [, ω])\n\nReturn a particle with random allowed initial conditions inside the given billiard. If supplied with a second argument the type of the returned particle is MagneticParticle, with angular velocity ω.\n\nWARNING : randominside works for any convex billiard but it does not work for non-convex billiards. (this is because it uses distance)\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"For example:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"p = randominside(bd)","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"and","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"mp = randominside(bd, ω)","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"randominside always creates particles with same number type as the billiard.","category":"page"},{"location":"basic/high_level/#evolve-and-timeseries-1","page":"High Level API","title":"evolve & timeseries","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Now that we have created a billiard and a particle inside, we want to evolve it! There is a simple function for that, called evolve! (or evolve if you don't want to mutate the particle), which returns the time, position and velocities at the collision points:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"evolve!","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.evolve!","page":"High Level API","title":"DynamicalBilliards.evolve!","text":"evolve!([p::AbstractParticle,] bd::Billiard, t)\n\nEvolve the given particle p inside the billiard bd. If t is of type AbstractFloat, evolve for as much time as t. If however t is of type Int, evolve for as many collisions as t. Return the states of the particle between collisions.\n\nThis function mutates the particle, use evolve otherwise. If a particle is not given, a random one is picked through randominside.\n\nReturn\n\nct::Vector{T} : Collision times.\nposs::Vector{SVector{2,T}} : Positions at the collisions.\nvels::Vector{SVector{2,T}}) : Velocities exactly after the collisions.\nω, either T or Vector{T} : Angular velocity/ies (returned only for magnetic particles).\n\nThe time ct[i+1] is the time necessary to reach state poss[i+1], vels[i+1] starting from the state poss[i], vels[i]. That is why ct[1] is always 0 since poss[1], vels[1] are the initial conditions. The angular velocity ω[i] is the one the particle has while propagating from state poss[i], vels[i] to i+1.\n\nNotice that at any point, the velocity vector vels[i] is the one obdained after the specular reflection of the i-1th collision.\n\nRay-splitting billiards\n\nevolve!(p, bd, t, raysplitters)\n\nTo implement ray-splitting, the evolve! function is supplemented with a fourth argument, raysplitters which is a tuple of RaySplitter instances. Notice that evolve always mutates the billiard if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Forget the ray-splitting part for now (see Ray-Splitting).","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Let's see an example:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"ct, poss, vels = evolve(p, bd, 100)\nfor i in 1:5\n  println(round(ct[i], digits=3), \"  \", poss[i], \"  \", vels[i])\nend","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Similarly, for magnetic propagation","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"ct, poss, vels, ω = evolve(mp, bd, 100)\nfor i in 1:10\n  println(round(ct[i], digits=3), \"  \", poss[i], \"  \", vels[i])\nend","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"The above return types are helpful in some applications. In other applications however one prefers to have the time series of the individual variables. For this, the timeseries function is used:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"timeseries!","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.timeseries!","page":"High Level API","title":"DynamicalBilliards.timeseries!","text":"timeseries!([p::AbstractParticle,] bd::Billiard, t; dt, warning)\n\nEvolve the given particle p inside the billiard bd for the condition t and return the x, y, vx, vy timeseries and the time vector. If t is of type AbstractFloat, then evolve for as much time as t. If however t is of type Int, evolve for as many collisions as t. Otherwise, t can be any function, that takes as an input t(n, τ, i, p) and returns true when the evolution should terminate. Here n is the amount of obstacles collided with so far, τ the amount time evolved so far, i the obstacle just collided with and p the particle (so you can access e.g. p.pos).\n\nThis function mutates the particle, use timeseries otherwise. If a particle is not given, a random one is picked through randominside.\n\nThe keyword argument dt is the time step used for interpolating the time series in between collisions. dt is capped by the collision time, as the interpolation always stops at collisions. For straight propagation dt = Inf, while for magnetic dt = 0.01.\n\nFor pinned magnetic particles, timeseries! issues a warning and returns the trajectory of the particle. If t is integer, the trajectory is evolved for one full circle only.\n\nInternally uses DynamicalBilliards.extrapolate.\n\nRay-splitting billiards\n\ntimeseries!(p, bd, t, raysplitters; ...)\n\nTo implement ray-splitting, the timeseries! function is supplemented with a fourth argument, raysplitters which is a tuple of RaySplitter instances. Notice that timeseries always mutates the billiard if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"For example:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"xt, yt, vxt, vyt, t = timeseries(p, bd, 100)\n\n# print as a matrix:\nhcat(xt, yt, vxt, vyt, t)[1:5, :]","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Same story for magnetic particles:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"# evolve the magnetic particle instead:\nxt, yt, vxt, vyt, t = timeseries(mp, bd, 100)\n\n# print as a matrix:\nhcat(xt, yt, vxt, vyt, t)[1:5, :]","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Sometimes we may need information about which obstacles a particle visited, in which sequence, and when. For this we have the following function:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"visited_obstacles!","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.visited_obstacles!","page":"High Level API","title":"DynamicalBilliards.visited_obstacles!","text":"visited_obstacles!([p::AbstractParticle,] bd::Billiard, t)\n\nEvolve the given particle p inside the billiard bd exactly like evolve!. However return only:\n\nts::Vector{T} : Vector of time points of when each collision occured.\nobst::Vector{Int} : Vector of obstacle indices in bd that the particle collided with at the time points in ts.\n\nThe first entries are 0.0 and 0. Similarly with evolve! the function does not record collisions with periodic walls.\n\nCurrently does not support raysplitting. Returns empty arrays for pinned particles.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"note: Type of `t`\nRemember that the behavior of time evolution depends on the type of the t argument, which represents \"total amount\". If it is AbstractFloat, it represents total amount of time, but if it is Int it represents total number of collisions.","category":"page"},{"location":"basic/high_level/#Poincaré-Sections-1","page":"High Level API","title":"Poincaré Sections","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"psos","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.psos","page":"High Level API","title":"DynamicalBilliards.psos","text":"psos(bd::Billiard, plane::InfiniteWall, t, particles)\n\nCompute the Poincaré section of the particles with the given plane, by evolving each one for time t (either integer or float) inside bd.\n\nThe plane can be an InfiniteWall of any orientation, however only crossings of the plane such that dot(velocity, normal) < 0 are allowed, with normal the normal unit vector of the plane.\n\nparticles can be:\n\nA single particle.\nA Vector of particles.\nAn integer n optionally followed by an angular velocity ω.\n\nReturn the positions poss and velocities vels at the instances of crossing the plane. If given more than one particle, the result is a vector of vectors of vectors.\n\nNotice - This function can handle pinned particles. If a pinned particle can intersect with the plane, then an intersection is returned. If however it can't then empty vectors are returned.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"For example, the surface of section in the periodic Sinai billiard with magnetic field reveals the mixed nature of the phase-space:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"using DynamicalBilliards, PyPlot\nt = 100; r = 0.15\nbd = billiard_sinai(r, setting = \"periodic\")\n\n# the direction of the normal vector is IMPORTANT!!!\n# (always keep in mind that ω > 0  means counter-clockwise rotation!)\nplane = InfiniteWall([0.5, 0.0], [0.5, 1.0], [-1.0, 0.0])\n\nposvector, velvector = psos(bd, plane, t, 1000, 2.0)\nc(a) = length(a) == 1 ? \"C1\" : \"C0\"\n\nfigure()\nfor i in 1:length(posvector)\n    poss = posvector[i] # vector of positions\n    vels = velvector[i] # vector of velocities at the section\n    L = length(poss)\n    if L > 0\n        #plot y vs vy\n        y = [a[2] for a in poss]\n        vy = [a[2] for a in vels]\n\n        plot(y, vy, ls = \"None\", color = c(y), ms = 2.0, alpha = 0.75, marker = \"o\")\n    end\nend\nxlabel(\"\\$y\\$\"); ylabel(\"\\$v_y\\$\")\nsavefig(\"psos.png\"); nothing # hide","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"(Image: )","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"note: `psos` operates on the unit cell\nThe psos function always calculates the crossings within the unit cell of a periodic billiard. This means that no information about the \"actual\" position of the particle is stored, everything is modulo the unit cell.This can be seen very well in the above example, where there aren't any entries in the region 0.5 - r ≤ y ≤ 0.5 + r.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Of course it is very easy to \"re-normalize\" the result such that it is coherent. The only change we have to do is simply replace the line y = [a[2] for a in poss] with","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"y = [a[2] < 0.5 ? a[2] + 1 : a[2]  for a in poss]","category":"page"},{"location":"basic/high_level/#Escape-Times-1","page":"High Level API","title":"Escape Times","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"It is very easy to create your own function that calculates an \"escape time\": the time until the particle leaves the billiard by meeting a specified condition. There is also a high-level function for this though:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"escapetime","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.escapetime","page":"High Level API","title":"DynamicalBilliards.escapetime","text":"escapetime([p,] bd, t; warning = false)\n\nCalculate the escape time of a particle p in the billiard bd, which is the time until colliding with any \"door\" in bd. As a \"door\" is considered any FiniteWall with field isdoor = true.\n\nIf the particle evolves for more than t (integer or float) without colliding with the Door (i.e. escaping) the returned result is Inf.\n\nA warning can be thrown if the result is Inf. Enable this using the keyword warning = true.\n\nIf a particle is not given, a random one is picked through randominside. See parallelize for a parallelized version.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"To create a \"door\" simply use FiniteWall.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"For example, the default implementation of the mushroom billiard has a \"door\" at the bottom of the stem. Thus,","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"using Statistics\nbd = billiard_mushroom()\net = zeros(100)\nfor i ∈ 1:100\n    particle = randominside(bd)\n    et[i] = escapetime(particle, bd, 10000)\nend\nprintln(\"Out of 100 particles, $(count(x-> x != Inf, et)) escaped\")\nprintln(\"Mean escape time was $(mean(et[et .!= Inf]))\")","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Of course, escapetime works with MagneticParticle as well","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"escapetime(randominside(bd, 1.0), bd, 10000)","category":"page"},{"location":"basic/high_level/#Mean-Collision-Times-1","page":"High Level API","title":"Mean Collision Times","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Because the computation of a mean collision time (average time between collisions in a billiard) is often a useful quantity, the following function computes it","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"meancollisiontime","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.meancollisiontime","page":"High Level API","title":"DynamicalBilliards.meancollisiontime","text":"meancollisiontime([p,] bd, t) → κ\n\nCompute the mean collision time κ of the particle p in the billiard bd by evolving for total amount t (either float for time or integer for collision number).\n\nCollision times are counted only between obstacles that are not PeriodicWall.\n\nIf a particle is not given, a random one is picked through randominside. See parallelize for a parallelized version.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"For example,","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"bd = billiard_sinai()\nmeancollisiontime(randominside(bd), bd, 10000.0)","category":"page"},{"location":"basic/high_level/#Parallelization-1","page":"High Level API","title":"Parallelization","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"parallelize","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.parallelize","page":"High Level API","title":"DynamicalBilliards.parallelize","text":"parallelize(f, bd::Billiard, t, particles; partype = :threads)\n\nParallelize function f across the available particles. The parallelization type can be :threads or :pmap, which use threads or a worker pool initialized with addprocs before using DynamicalBilliards.\n\nparticles can be:\n\nA Vector of particles.\nAn integer n optionally followed by an angular velocity ω. This uses randominside.\n\nThe functions usable here are:\n\nmeancollisiontime\nescapetime\nlyapunovspectrum (returns only the maximal exponents)\nboundarymap (returns vector of vectors of 2-vectors and arcintervals)\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Here are some examples","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"bd = billiard_stadium()\nparticles = [randominside(bd) for i in 1:1000]\nparallelize(meancollisiontime, bd, 1000, particles)","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"parallelize(lyapunovspectrum, bd, 1000, particles)","category":"page"},{"location":"basic/high_level/#It's-all-about-bounce!-1","page":"High Level API","title":"It's all about bounce!","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"The main propagation algorithm used by DynamicalBilliards is bundled in the following well-behaving function:","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"bounce!","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.bounce!","page":"High Level API","title":"DynamicalBilliards.bounce!","text":"bounce!(p::AbstractParticle, bd::Billiard) → i, t, pos, vel\n\n\"Bounce\" the particle (advance for one collision) in the billiard. Takes care of finite-precision issues.\n\nReturn:\n\nindex of the obstacle that the particle just collided with\nthe time from the previous collision until the current collision t\nposition and velocity of the particle at the current collision (after the collision has been resolved!). The position is given in the unit cell of periodic billiards. Do pos += p.current_cell for the position in real space.\n\nbounce!(p, bd, raysplit) → i, t, pos, vel\n\nRay-splitting version of bounce!.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"bounce! is the function used internally by all high-level functions, like evolve!, boundarymap, escapetime, etc.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"This is the function a user should use if they want to calculate other things besides what is already available in the high level API.","category":"page"},{"location":"basic/high_level/#Standard-Billiards-Library-1","page":"High Level API","title":"Standard Billiards Library","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"tip: You can also use keywords!\nAll standard billiards have a function version that accepts keyword arguments instead of positional arguments, for ease of use.","category":"page"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"billiard_rectangle\nbilliard_sinai\nbilliard_bunimovich\nbilliard_mushroom\nbilliard_polygon\nbilliard_vertices\nbilliard_iris\nbilliard_hexagonal_sinai\nbilliard_raysplitting_showcase\nbilliard_logo","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.billiard_rectangle","page":"High Level API","title":"DynamicalBilliards.billiard_rectangle","text":"billiard_rectangle(x=1.0, y=1.0; setting = \"standard\")\n\nReturn a vector of obstacles that defines a rectangle billiard of size (x, y).\n\nSettings\n\n\"standard\" : Specular reflection occurs during collision.\n\"periodic\" : The walls are PeriodicWall type, enforcing periodicity at the boundaries\n\"random\" : The velocity is randomized upon collision.\n\"ray-splitting\" : All obstacles in the billiard allow for ray-splitting.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#DynamicalBilliards.billiard_sinai","page":"High Level API","title":"DynamicalBilliards.billiard_sinai","text":"billiard_sinai(r=0.25, x=1.0, y=1.0; setting = \"standard\")\n\nReturn a vector of obstacles that defines a Sinai billiard of size (x, y) with a disk in its center, of radius r.\n\nIn the periodic case, the system is also known as \"Lorentz Gas\".\n\nSettings\n\n\"standard\" : Specular reflection occurs during collision.\n\"periodic\" : The walls are PeriodicWall type, enforcing periodicity at the boundaries\n\"random\" : The velocity is randomized upon collision.\n\"ray-splitting\" : All obstacles in the billiard allow for ray-splitting.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#DynamicalBilliards.billiard_bunimovich","page":"High Level API","title":"DynamicalBilliards.billiard_bunimovich","text":"billiard_bunimovich(l=1.0, w=1.0)\n\nReturn a vector of Obstacles that define a Buminovich billiard, also called a stadium. The length is considered without the attached semicircles, meaning that the full length of the billiard is l + w. The left and right edges of the stadium are Semicircles.\n\nbilliard_stadium is an alias of billiard_bunimovich.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#DynamicalBilliards.billiard_mushroom","page":"High Level API","title":"DynamicalBilliards.billiard_mushroom","text":"billiard_mushroom(sl = 1.0, sw = 0.2, cr = 1.0, sloc = 0.0; door = true)\n\nCreate a mushroom billiard with stem length sl, stem width sw and cap radius cr. The center of the cap (which is Semicircle) is always at [0, sl]. The center of the stem is located at sloc.\n\nOptionally, the bottom-most Wall is a Door (see escapetime).\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#DynamicalBilliards.billiard_polygon","page":"High Level API","title":"DynamicalBilliards.billiard_polygon","text":"billiard_polygon(n::Int, R, center = [0,0]; setting = \"standard\")\n\nReturn a vector of obstacles that defines a regular-polygonal billiard with n sides, radius r and given center.\n\nNote: R denotes the so-called outer radius, not the inner one.\n\nSettings\n\n\"standard\" : Specular reflection occurs during collision.\n\"periodic\" : The walls are PeriodicWall type, enforcing periodicity at the boundaries. Only available for n=4 or n=6.\n\"random\" : The velocity is randomized upon collision.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#DynamicalBilliards.billiard_vertices","page":"High Level API","title":"DynamicalBilliards.billiard_vertices","text":"billiard_vertices(v, type = FiniteWall)\n\nConstruct a polygon billiard that connects the given vertices v (vector of 2-vectors). The vertices should construct a billiard in a counter-clockwise orientation (i.e. the normal vector always points to the left of v[i+1] - v[i].).\n\ntype decides what kind of walls to use. Ths function assumes that the first entry of v should be connected with the last.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#DynamicalBilliards.billiard_iris","page":"High Level API","title":"DynamicalBilliards.billiard_iris","text":"billiard_iris(a=0.2, b=0.4, w=1.0; setting = \"standard\")\n\nReturn a billiard that is a square of side w enclosing at its center an ellipse with semi axes a, b.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#DynamicalBilliards.billiard_hexagonal_sinai","page":"High Level API","title":"DynamicalBilliards.billiard_hexagonal_sinai","text":"billiard_hexagonal_sinai(r, R, center = [0,0]; setting = \"standard\")\n\nCreate a sinai-like billiard, which is a hexagon of outer radius R, containing at its center (given by center) a disk of radius r. The setting keyword is passed to billiard_polygon.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#DynamicalBilliards.billiard_raysplitting_showcase","page":"High Level API","title":"DynamicalBilliards.billiard_raysplitting_showcase","text":"billiard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -> bd, rayspl\n\nShowcase example billiard for ray-splitting processes. A rectangle (x,y) with a SplitterWall at x/2 and two disks at each side, with respective radii r1, r2.\n\nNotice: This function returns a billiard bd as well as a rayspl dictionary!\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#DynamicalBilliards.billiard_logo","page":"High Level API","title":"DynamicalBilliards.billiard_logo","text":"billiard_logo(;h=1.0, α=0.8, r=0.18, off=0.25) -> bd, ray\n\nCreate the billiard used as logo of DynamicalBilliards and return it along with the tuple of raysplitters.\n\n\n\n\n\n","category":"function"},{"location":"basic/high_level/#Particle-types-1","page":"High Level API","title":"Particle types","text":"","category":"section"},{"location":"basic/high_level/#","page":"High Level API","title":"High Level API","text":"Particle\nMagneticParticle","category":"page"},{"location":"basic/high_level/#DynamicalBilliards.Particle","page":"High Level API","title":"DynamicalBilliards.Particle","text":"Particle(ic::Vector{T}) #where ic = [x0, y0, φ0]\nParticle(x0, y0, φ0)\nParticle(pos::SVector, vel::SVector)\n\nCreate a particle with initial conditions x0, y0, φ0. It propagates as a straight line.\n\nThe field current_cell shows at which cell of a periodic billiard is the particle currently located.\n\n\n\n\n\n","category":"type"},{"location":"basic/high_level/#DynamicalBilliards.MagneticParticle","page":"High Level API","title":"DynamicalBilliards.MagneticParticle","text":"MagneticParticle(ic::AbstractVector{T}, ω::Real) # where ic = [x0, y0, φ0]\nMagneticParticle(x0, y0, φ0, ω)\nMagneticParticle(pos::SVector, vel::SVector, ω)\nMagneticParticle(p::AbstractParticle, ω)\n\nCreate a magnetic particle with initial conditions x0, y0, φ0 and angular velocity ω. It propagates as a circle instead of a line, with radius 1/abs(ω).\n\nThe field current_cell shows at which cell of a periodic billiard is the particle currently located.\n\n\n\n\n\n","category":"type"},{"location":"ray-splitting/#Ray-Splitting-1","page":"Ray-Splitting","title":"Ray-Splitting","text":"","category":"section"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Ray-splitting is a semi-classical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission & refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three simple steps. We will introduce them and demonstrate them using a simple example in this documentation page.","category":"page"},{"location":"ray-splitting/#.-Ray-Splitting-Obstacles-1","page":"Ray-Splitting","title":"1. Ray-Splitting Obstacles","text":"","category":"section"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"The first step is that an Obstacle that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called pflag (propagation flag). This field notes on which side of the obstacle the particle is currently propagating.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"The normal vector as well as the distance from boundary change sign depending on the value of pflag. The obstacles Antidot and SplitterWall are the equivalents of disk and wall for ray-splitting.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Let's create a billiard with a bunch of ray-splitting obstacles!","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"using DynamicalBilliards\nx, y = 2.0, 1.0\nbdr =  billiard_rectangle(x, y)\nsw = SplitterWall([x/2, 0.0], [x/2,y], [-1,0], true)\na1 = Antidot([x/4, y/2], 0.25, \"Left Antidot\")\na2 = Antidot([3x/4, y/2], 0.15, \"Right Antidot\")\nbd = Billiard(a1, a2, sw, bdr...)","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"using PyPlot\nplot(bd)\nsavefig(\"raybil.svg\"); nothing # hide","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"(Image: )","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"<!– (Image: Ray-splitting billiard) –>","category":"page"},{"location":"ray-splitting/#.-The-RaySplitter-structure-1","page":"Ray-Splitting","title":"2. The RaySplitter structure","text":"","category":"section"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"In the second step, you have to define 2+1 functions: transmission probability, refraction angle and optionally new angular velocity after transmission. These functions, as well as which obstacles participate in ray-splitting, are bundled into a special structure:","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"RaySplitter","category":"page"},{"location":"ray-splitting/#DynamicalBilliards.RaySplitter","page":"Ray-Splitting","title":"DynamicalBilliards.RaySplitter","text":"RaySplitter(idxs, transmission, refraction [, newangular]; affect)\n\nReturn a RaySplitter instance, used to perform raysplitting. idxs is a Vector{Int} with the indices of the obstacles that this RaySplitter corresponds to.\n\ntransmission, refraction and newangular are functions. Let φ be the angle of incidence and ω be the angular velocity and pflag the propagation flag (before transmission). The functions have the following signatures:\n\ntransmission(φ, pflag, ω) -> T, transmission probability.\nrefraction(φ, pflag, ω) -> θ, refraction angle. This angle is relative to the normal vector.\nnewangular(ω, pflag) -> newω, new angular velocity after transmission.\n\nThe above three functions use the same convention: the argument pflag is the one the obstacle has before transmission. For example, if a particle is outside an Antidot (with pflag = true here) and is transmitted inside the Antidot (pflag becomes false here), then all three functions will be given their second argument (the Boolean one) as true!\n\naffect is a function, and denotes which obstacles of the billiard are affected when transmission occurs at obstacle i (for which obstacles should the field pflag be reversed). Defaults to idxs = (i) -> i, i.e. only the colliding obstacle is affected. If you want many obstacles to be affected you could write idxs = (i) -> SVector(2,3,5), etc. Keep in mind that the only values of i that can be passed into this function are the ones that are given in the argument idxs!\n\n\n\n\n\n","category":"type"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"If you want different type of transmission/refraction functions for different obstacles, then you define multiple RaySplitters.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Continuing from the above billiard, let's also create some RaySplitter instances for it.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"First define a refraction function","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"refraction(φ, pflag, ω) = pflag ? 0.5φ : 2.0φ","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Then, a transmission probability function. In this example, we want to create a function that given some factor p, it returns a probability weighted with p in one direction of ray-splitting and 1-p in another direction.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"transmission_p(p) = (φ, pflag, ω) -> begin\n    if pflag\n        p*exp(-(φ)^2/2(π/8)^2)\n    else\n        abs(φ) < π/4 ? (1-p)*exp(-(φ)^2/2(π/4)^2) : 0.0\n    end\nend","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Notice also how we defined the function in such a way that critical refraction is respected, i.e. if θ(φ) ≥ π/2 then T(φ) = 0. Although this is necessary from a physical perspective, the code does take care of it by clamping the refraction angle (see below).","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Lastly, for this example we will use magnetic propagation. We define functions such that the antidots also reverse the direction and magnitude of the magnetic field.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"newoantidot(x, bool) =  bool ? -2.0x : -0.5x\nnewowall(x, bool) = bool ? 0.5x : 2.0x","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Now we create the RaySplitter instances we want","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"raywall = RaySplitter([3], transmission_p(0.5), refraction, newowall)\nraya = RaySplitter([1, 2], transmission_p(0.8), refraction, newoantidot)","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Because we want to use same functions for both antidots, we gave both indices in raya, [1, 2] (which are the indices of the antidots in the billiard bd).","category":"page"},{"location":"ray-splitting/#.-Evolution-with-Ray-Splitting-1","page":"Ray-Splitting","title":"3. Evolution with Ray-Splitting","text":"","category":"section"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"The third step is trivial. After you have created your RaySplitter(s), you simply pass them into evolve or animate_evolution as a fourth argument! If you have many instances of RaySplitter you pass a tuple of them.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"For example,","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"p = randominside(bd, 1.0)\nraysplitters = (raywall, raya)\nxt, yt, vxt, vyt, tt = timeseries(p, bd, 100, raysplitters)\nplot(bd)\nplot(xt, yt)\nscatter(xt[1], yt[1], color = \"black\")\nsavefig(\"rayorbit.svg\"); nothing # hide","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"(Image: )","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"You can see that at some points the particle crossed the boundaries of the red obstacles, which allow for ray splitting. It is even cooler to animate this motion using animate_evolution!","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"<video width=\"100%\" height=\"auto\" controls> <source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/ray.mp4?raw=true\" type=\"video/mp4\"> </video>","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"warning: Resetting the billiard\nNotice that evolving a particle inside a billiard always mutates the billiard if ray-splitting is used. This means that you should always set the fields pflag of some obstacles to the values you desire after each call to evolve. If you use the function randominside you must definitely do this!The function reset_billiard!(bd) turns all pflags to true.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"important: Angle of refraction is clamped\nInternally we clamp the output of the angle of refraction function. Let c = DynamicalBilliards.CLAMPING_ANGLE (currently c = 0.1). We clamp θ to -π/2 + c ≤ θ ≤ π/2 - c. This is so that the relocating algorithm does not fall into an infinite loop.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"\tYou can change the value of `c` but very small values can lead to infinite loops in extreme cases.","category":"page"},{"location":"ray-splitting/#The-Ray-Splitting-Algorithm-1","page":"Ray-Splitting","title":"The Ray-Splitting Algorithm","text":"","category":"section"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"In this section we describe the algorithm we follow to implement the ray-splitting process. Let T denote the transmission function, theta the refraction function and omega_textnew the new angular velocity function. The following describes the process after a particle has reached an obstacle that supports ray-splitting.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Find the angle of incidence phi = pi - arccos(vecv cdot vecn) = arccos(vecv cdot (-vecn)) with vecn the normal vector at collision point. Notice that we use here -vecn because the velocity is opposing the normal vector before the collision happens. Using -vecn gives the angle between 0 and pi2 instead of pi2 to pi.\nFind the correct sign of the incidence angle, phi = pm phi. Specifically, use the cross product: if the third entry of vecv times vecn is negative, then have minus sign. The \"correct\" sign debates on whether the velocity vector is to the right or to the left of (-vecn). This is important for finding the correct transmission angle and/or probability.\nCheck if T(phi verbpflag omega)  textrandom(). If not, do standard specular reflection.\nIf ray-splitting happens, then relocate the particle so that it is on the other side of the colliding obstacle. This contrasts the main evolution algorithm of this billiard package.\nRe-compute the correct angle of incidence, as the position of the particle generally changes with relocating.\nFind refraction angle theta(phi verbpflag omega). Notice that this is a relative angle with respect to the normal vector. Also notice that theta may have opposite sign from phi. It depends on the user if they want to add anomalous refraction.\nSet obstacle.pflag = !obstacle.pflag for all obstacles affected by the current RaySplitter. This reverses vecn to -vecn as well! So from now on vecn is the opposite than what it was at the beginning of the algorithm!\nFind the refraction angle in absolute space. First find a = textatan(n_y n_x) and then set Theta = a + theta.\nPerform refraction, i.e. set the particle velocity to the direction of Theta.\nScale the magnetic field, i.e. set p.omega = omega_textnew(omega verbpflag). It is important to note that we use !pflag because we have already changed the pflag field.","category":"page"},{"location":"ray-splitting/#Physics-of-the-Ray-Splitting-Functions-1","page":"Ray-Splitting","title":"Physics of the Ray-Splitting Functions","text":"","category":"section"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"If T is the transmission probability function, then the condition for transmission is simply: T(φ, pflag, ω) > rand(). If it returns true, transmission (i.e. ray-splitting) will happen.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"The functions given to RaySplitter should have some properties in order to have physical meaning. In order to test if the RaySplitter you have defined has physical meaning, the function isphysical is provided","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"isphysical","category":"page"},{"location":"ray-splitting/#DynamicalBilliards.isphysical","page":"Ray-Splitting","title":"DynamicalBilliards.isphysical","text":"isphysical(raysplitter(s))\n\nReturn true if the given raysplitters have physically plausible properties.\n\nSpecifically, check if (φ is the incidence angle, θ the refraction angle):\n\nCritical angle means total reflection: If θ(φ) ≥ π/2 then Tr(φ) = 0\nTransmission probability is even function: Tr(φ) ≈ Tr(-φ) at ω = 0\nRefraction angle is odd function: θ(φ) ≈ -θ(-φ) at ω = 0\nRay reversal is true: θ(θ(φ, pflag, ω), !pflag, ω) ≈ φ\nMagnetic conservation is true: (ωnew(ωnew(ω, pflag), !pflag) ≈ ω\n\n\n\n\n\n","category":"function"},{"location":"ray-splitting/#Snell's-Law-1","page":"Ray-Splitting","title":"Snell's Law","text":"","category":"section"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"In classical geometric optics, the refraction of a ray of light moving from one medium to another is described by Snell's law. For an angle of incidence of phi, the refraction angle theta is determined by the equation","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"fracsin(phi)sin(theta) = fracnn","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"where n and n are the respective refractive indices of the media.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"To easily simulate these relations in DynamicalBilliards, the function law_of_refraction can be used to set up ray-splitting according to this law.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"law_of_refraction","category":"page"},{"location":"ray-splitting/#DynamicalBilliards.law_of_refraction","page":"Ray-Splitting","title":"DynamicalBilliards.law_of_refraction","text":"law_of_refraction(n1, n2 = 1.0) -> t, r\n\nCreate transmission and refraction functions t, r that follow Snell's law, i.e. the transmission probability is set to 1.0 except for the case of total internal reflection. \n\nn1 is the index of refraction for the pflag = false side of an obstacle, while n2 is the index of refraction for pflag = true.\n\n\n\n\n\n","category":"function"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Using the functions returned by law_of_refraction, we can set up a RaySplitter for a billiard.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"using DynamicalBilliards, PyPlot\n# Create a circular \"lens\"\no = Antidot(SVector(1.0, 0.75), 0.5)\n# in a rectangular box\nbd = Billiard(billiard_rectangle(2.5, 1.5)..., o)\n# create a RaySplitter using law of refraction\ntrans, refra = law_of_refraction(1.5)\nrs = (RaySplitter([5], trans, refra),)","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"We now animate the evolution of an array of particles on parallel trajectories to demonstrate the refractive properties of the spherical lens","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"# create parallel particles\nps = [Particle(0.1, y, 0.0) for y in 0.4:0.05:1.1]\n\n# animate\nanimate_evolution(ps, bd, 2.0, rs, colors = [\"C0\" for i ∈ 1:length(ps)],\n\ttailtime=2.5, savename = \"lens\")","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"<video width=\"100%\" height=\"auto\" controls> <source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/lens.mp4?raw=true\" type=\"video/mp4\"> </video>","category":"page"},{"location":"ray-splitting/#Example-of-Affecting-Multiple-Obstacles-1","page":"Ray-Splitting","title":"Example of Affecting Multiple Obstacles","text":"","category":"section"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Here we will show an application of inverse billiards, where particles go in and out of a billiard, while taking advantage of the existence of a magnetic field outside to return.","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"As always, we define the ray-splitting functions:","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"using DynamicalBilliards, PyPlot\ntrans(args...) = 1.0 # always perfect transmission\nrefra(φ, pflag, ω) = pflag ? 0.8φ : 1.25φ # refraction angle\nneww(ω, pflag) = pflag ? 2.0 : 0.4","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"Now, when we define the RaySplitter instance we will choose a different value for affect:","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"ray = RaySplitter([1,2,3,4], trans, refra, neww, affect = (i) -> SVector(1,2,3,4))","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"We initialize a simple rectangular billiard and a particle","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"bd = billiard_rectangle(setting = \"ray-splitting\")\np = MagneticParticle(0.4, 0.6, 0.0, 0.4)","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"and we animate its evolution, by first zooming out of the billiard","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"plot(bd)\nxlim(-1, 2); ylim(-1, 2);\nanimate_evolution(p, bd, 10.0, (ray,); ax = gca(), savename = \"inverse\", tailtime = 3.0)","category":"page"},{"location":"ray-splitting/#","page":"Ray-Splitting","title":"Ray-Splitting","text":"<video width=\"100%\" height=\"auto\" controls> <source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/inverse.mp4?raw=true\" type=\"video/mp4\"> </video>","category":"page"},{"location":"basic/low_level/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"This page is not part of the public API defined by DynamicalBilliards. Consider it something like a developer's guide.","category":"page"},{"location":"basic/low_level/#Implementation-1","page":"Internals","title":"Implementation","text":"","category":"section"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"Before talking about the low level methods that enable everything to work nicely together, let's talk about how this package works.","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"Firstly one defines a Billiard and optionally some RaySplitter instances. Then one creates a particle inside the defined billiard. The algorithm for the propagation of a particle is the following:","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"Calculate the collision of the particle with all obstacles in the billiard.\nFind the collision that happens first (in time), and the obstacle corresponding to that.\nDynamicalBilliards.relocate! the particle, and ensure that it is inside the billiard. This means that DynamicalBilliards.distance between particle and obstacle is either positive or close to machine precision.\n(Optionally) check if there is transmission for ray-splitting: T(φ) > rand()","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"If yes, perform the ray-splitting algorithm (see the Ray-Splitting page).\nIf not, then DynamicalBilliards.resolvecollision! of the particle with the obstacle (specular or periodic conditions).","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"Continue this loop for a given amount of time.","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"Notice that the DynamicalBilliards.relocate! step is very important because it takes care that all particles remain inside the billiard.","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"The exposed bounce! function bundles steps 1-4 together.","category":"page"},{"location":"basic/low_level/#Where-is-\"inside\"?-1","page":"Internals","title":"Where is \"inside\"?","text":"","category":"section"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"If for some reason (finite numeric precision) a particle goes outside a billiard, then it will escape to infinity. But what is inside?","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"\"Inside\" is defined on obstacle level by the function distance:","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"DynamicalBilliards.distance","category":"page"},{"location":"basic/low_level/#DynamicalBilliards.distance","page":"Internals","title":"DynamicalBilliards.distance","text":"distance(p::AbstractParticle, o::Obstacle)\n\nReturn the signed distance between particle p and obstacle o, based on p.pos. Positive distance corresponds to the particle being on the allowed region of the Obstacle. E.g. for a Disk, the distance is positive when the particle is outside of the disk, negative otherwise.\n\ndistance(p::AbstractParticle, bd::Billiard)\n\nReturn minimum distance(p, obst) for all obst in bd. If the distance(p, bd) is negative and bd is convex, this means that the particle is outside the billiard.\n\nWARNING : distance(p, bd) may give negative values for non-convex billiards, or billiards that are composed of several connected sub-billiards.\n\nAll distance functions can also be given a position (vector) instead of a particle.\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"Notice that for very small negative values of distance, collision takes care of finite precision issues and does not return wrong collisions.","category":"page"},{"location":"basic/low_level/#Numerical-Precision-1","page":"Internals","title":"Numerical Precision","text":"","category":"section"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"All core types of DynamicalBilliards are parametrically constructed, with parameter T <: AbstractFloat. This means that the fields of all particles and obstacles contain numbers strictly of type T. You will understand why this choice happened as you continue reading this paragraph.","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"The main concerns during evolution in a billiard table are:","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"The particle must never leak out of the billiard table. This is simply translated to the distance function being positive after any collision and that collision takes care of extreme cases with very small (but negative) distance.\nThe collision time is never infinite, besides the cases of Pinned Particles in a magnetic billiard.","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"These are solved with two ways:","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"After the next collision is computed, relocate! brings the particle to that point and calculates the distance with the colliding obstacle. If it is negative, it translates the particle's position by this distance, along the normal vector.\ncollision takes care of cases where the distance between particle and obstacle is less than accuracy(::T). (This is necessary only for magnetic propagation, as for straight propagation checking the velocity direction with respect to the normal is always enough).","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"Adjusting the global precision of DynamicalBilliards is easy and can be done by choosing the floating precision you would like. This is done by initializing your billiard table with parametric type T, e.g. bd = billiard_sinai(Float16(0.3)). This choice will propagate to the entire bd, all particles resulting from randominside, as well as the entire evolution process.","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"danger: BigFloats\nEvolution with BigFloat in DynamicalBilliards is on average 3 to 4 orders of magnitude slower than with Float64.","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"basic/low_level/#Collision-Times-1","page":"Internals","title":"Collision Times","text":"","category":"section"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"collision\nnext_collision","category":"page"},{"location":"basic/low_level/#DynamicalBilliards.collision","page":"Internals","title":"DynamicalBilliards.collision","text":"collision(p::AbstractParticle, o::Obstacle) → t, cp\n\nFind the collision (if any) between given particle and obstacle. Return the time until collision and the estimated collision point cp.\n\nReturn Inf, SV(0, 0) if the collision is not possible or if the collision happens backwards in time.\n\nIt is the duty of collision to avoid incorrect collisions when the particle is on top of the obstacle (or very close).\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#DynamicalBilliards.next_collision","page":"Internals","title":"DynamicalBilliards.next_collision","text":"next_collision(p::AbstractParticle, bd::Billiard) -> i, tmin, cp\n\nCompute the collision across all obstacles in bd and find the minimum one. Return the index of colliding obstacle, the time and the collision point.\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#Non-Exported-Internals-1","page":"Internals","title":"Non-Exported Internals","text":"","category":"section"},{"location":"basic/low_level/#Obstacle-related-1","page":"Internals","title":"Obstacle related","text":"","category":"section"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"DynamicalBilliards.normalvec\nDynamicalBilliards.cellsize","category":"page"},{"location":"basic/low_level/#DynamicalBilliards.normalvec","page":"Internals","title":"DynamicalBilliards.normalvec","text":"normalvec(obst::Obstacle, position)\n\nReturn the vector normal to the obstacle's boundary at the given position (which is assumed to be very close to the obstacle's boundary).\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#DynamicalBilliards.cellsize","page":"Internals","title":"DynamicalBilliards.cellsize","text":"cellsize(bd)\n\nReturn the delimiters xmin, ymin, xmax, ymax of the given obstacle/billiard.\n\nUsed in randominside(), error checking and plotting.\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#Propagation-1","page":"Internals","title":"Propagation","text":"","category":"section"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"DynamicalBilliards.propagate!\nDynamicalBilliards.resolvecollision!\nDynamicalBilliards.relocate!\nDynamicalBilliards.specular!\nDynamicalBilliards.periodicity!","category":"page"},{"location":"basic/low_level/#DynamicalBilliards.propagate!","page":"Internals","title":"DynamicalBilliards.propagate!","text":"propagate!(p::AbstractParticle, t)\n\nPropagate the particle p for given time t, changing appropriately the the p.pos and p.vel fields.\n\npropagate!(p, position, t)\n\nDo the same, but take advantage of the already calculated position that the particle should end up at.\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#DynamicalBilliards.resolvecollision!","page":"Internals","title":"DynamicalBilliards.resolvecollision!","text":"resolvecollision!(p::AbstractParticle, o::Obstacle)\n\nResolve the collision between particle p and obstacle o, depending on the type of o (do specular! or periodicity!).\n\nresolvecollision!(p, o, T::Function, θ::Function, new_ω::Function)\n\nThis is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to evolve!(). For a calculated incidence angle φ, if T(φ) > rand(), ray-splitting occurs.\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#DynamicalBilliards.relocate!","page":"Internals","title":"DynamicalBilliards.relocate!","text":"relocate!(p::AbstractParticle, o::Obstacle, t, cp)\n\nPropagate the particle to cp and propagate velocities for time t. Check if it is on the correct side of the obstacle. If not, change the particle position by distance along the normalvec of the obstacle.\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#DynamicalBilliards.specular!","page":"Internals","title":"DynamicalBilliards.specular!","text":"specular!(p::AbstractParticle, o::Obstacle)\n\nPerform specular reflection based on the normal vector of the Obstacle.\n\nIn the case where the given obstacle is a RandomObstacle, the specular reflection randomizes the velocity instead (within -π/2+ε to π/2-ε of the normal vector).\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#DynamicalBilliards.periodicity!","page":"Internals","title":"DynamicalBilliards.periodicity!","text":"periodicity!(p::AbstractParticle, w::PeriodicWall)\n\nPerform periodicity conditions of w on p.\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#Timeseries-1","page":"Internals","title":"Timeseries","text":"","category":"section"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"DynamicalBilliards.extrapolate","category":"page"},{"location":"basic/low_level/#DynamicalBilliards.extrapolate","page":"Internals","title":"DynamicalBilliards.extrapolate","text":"extrapolate(particle, prevpos, prevvel, ct, dt[, ω]) → x, y, vx, vy, t\n\nCreate the timeseries that connect a particle's previous position and velocity prevpos, prevvel with the particle's current position and velocity, provided that the collision time between previous and current state is ct.\n\ndt is the sampling time and if the particle is MagneticParticle then you should provide ω, the angular velocity that governed the free flight.\n\nHere is how this function is used (for example)\n\nprevpos, prevvel = p.pos + p.current_cell, p.vel\nfor _ in 1:5\n    i, ct, pos, vel = bounce!(p, bd)\n    x, y, x, vy, t = extrapolate(p, prevpos, prevvel, ct, 0.1)\n    # append x, y, ... to other vectors or do whatever with them\n    prevpos, prevvel = p.pos + p.current_cell, p.vel\nend\n\n\n\n\n\n","category":"function"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"basic/low_level/#","page":"Internals","title":"Internals","text":"warning: Cyclotron center is a field of `MagneticParticle`\nFor almost all operations involving a MagneticParticle, the center of the cyclotron is required. In order to compute this center only when it physically changes, we have made it a field of the struct.This means that after changing the position or velocity of the particle, this center must be changed by doing mp.center = DynamicalBilliards.find_cyclotron(mp). The bounce! function takes care of that in the most opportune moment, but if you want to write your own specific low level function, do not forget this point!","category":"page"},{"location":"lyapunovs/#Lyapunov-Exponents-1","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"","category":"section"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"The Finite Time Lyapunov Spectrum (FTLS) for a 2D billiard system consists of a set of 4 numbers lambda_i    i = 1 4  that characterize how fast the separation of initially close initial conditions grows.","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"It can be shown theoretically that two of these exponents must be zero (lambda_2 =lambda_3 = 0) and the other two are paired in such a way that they sum up to zero, i.e. lambda_1 =  -lambda_4).","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"The function provided to calculate the FTLS is","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"lyapunovspectrum","category":"page"},{"location":"lyapunovs/#DynamicalBilliards.lyapunovspectrum","page":"Lyapunov Exponents","title":"DynamicalBilliards.lyapunovspectrum","text":"lyapunovspectrum([p::AbstractParticle,] bd::Billiard, t)\n\nReturns the finite time lyapunov exponents (averaged over time t) for a given particle in a billiard table using the method outlined in [1]. t can be either Float or Int, meaning total time or total amount of collisions.\n\nReturns zeros for pinned particles.\n\nIf a particle is not given, a random one is picked through randominside. See parallelize for a parallelized version.\n\n[1] : Ch. Dellago et al, Phys. Rev. E 53 (1996)\n\n\n\n\n\n","category":"function"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"Here its basic use is illustrated","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"using DynamicalBilliards\n\nradius = 1.0\nl = 2.0\n\nbd = Billiard(billiard_polygon(6, l; setting = \"periodic\")..., Disk([0., 0.], radius))\n\npar = randominside(bd)\nt = 1000.0\n\nexps = lyapunovspectrum(par, bd, t)","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"In the following example we compute the change of lambda_1 versus the distance between the disks in a hexagonal periodic billiard.","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"using DynamicalBilliards\nusing PyPlot\n\nt = 5000.0\nradius = 1.0\n\nspaces = 2.0:0.1:4.4 #Distances between adjacent disks\nlyap_time = zero(spaces) #Array where the exponents will be stored\n\nfor (i, space) in enumerate(spaces)\n    bd = billiard_polygon(6, space/(sqrt(3)); setting = \"periodic\")\n    disc = Disk([0., 0.], radius)\n    billiard = Billiard(bd.obstacles..., disc)\n    p = randominside(billiard)\n    lyap_time[i] = lyapunovspectrum(p, billiard, t)[1]\nend\nfigure()\nplot(spaces, lyap_time, \"*-\")\nxlabel(\"\\$w\\$\"); ylabel(\"\\$\\\\lambda_1\\$\")\nsavefig(\"lyapos.svg\"); nothing # hide","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"(Image: )","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"The plot of the maximum exponent can be compared with the results reported by Gaspard et. al (see figure 7), showing that using just t = 5000.0 is already enough of a statistical averaging.","category":"page"},{"location":"lyapunovs/#Perturbation-Growth-1","page":"Lyapunov Exponents","title":"Perturbation Growth","text":"","category":"section"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"To be able to inspect the dynamics of perturbation growth in more detail, we also provide the following function:","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"perturbationgrowth","category":"page"},{"location":"lyapunovs/#DynamicalBilliards.perturbationgrowth","page":"Lyapunov Exponents","title":"DynamicalBilliards.perturbationgrowth","text":"perturbationgrowth([p,] bd, t) -> ts, Rs, is\n\nCalculate the evolution of the perturbation vector Δ along the trajectory of p in bd for total time t. Δ is initialised as [1,1,1,1].\n\nIf a particle is not given, a random one is picked through randominside. Returns empty lists for pinned particles.\n\nDescription\n\nThis function safely computes the time evolution of a perturbation vector using the linearized dynamics of the system, as outlined by [1]. Because the dynamics are linear, we can safely re-normalize the perturbation vector after every collision (otherwise the perturbations grow to infinity).\n\nImmediately before and after every collison, this function computes\n\nthe current time.\nthe element-wise ratio of Δ with its previous value\nthe obstacle index of the current obstacle\n\nand returns these in three vectors ts, Rs, is.\n\nTo obtain the actual evolution of the perturbation vector you can use the function perturbationevolution(Rs) which simply does\n\nΔ = Vector{SVector{4,Float64}}(undef, length(R))\nΔ[1] = R[1]\nfor i in 2:length(R)\n    Δ[i] = R[i] .* Δ[i-1]\nend\n\n[1] : Ch. Dellago et al, Phys. Rev. E 53 (1996)\n\n\n\n\n\n","category":"function"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"For example, lets plot the evolution of the perturbation growth using different colors for collisions with walls and disks in the Sinai billiard:","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"using DynamicalBilliards, PyPlot, LinearAlgebra\nbd = billiard_sinai()\n\nts, Rs, is = perturbationgrowth(Particle(0.1, 0.1, 0.1), bd, 10.0)\nΔ = perturbationevolution(Rs)\n\nfigure()\nplot(ts, log.(norm.(Δ)), \"k-\", lw = 0.5)\nscatter(ts, log.(norm.(Δ)), c = [j == 1 ? \"C0\" : \"C1\" for j in is])\nxlabel(\"\\$t\\$\"); ylabel(\"\\$\\\\log(||\\\\Delta ||)\\$\")\nsavefig(\"pertg.svg\"); nothing # hide","category":"page"},{"location":"lyapunovs/#","page":"Lyapunov Exponents","title":"Lyapunov Exponents","text":"(Image: )","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"This page briefly discusses physical aspects of billiard systems.","category":"page"},{"location":"physics/#Pinned-Particles-1","page":"Physics","title":"Pinned Particles","text":"","category":"section"},{"location":"physics/#","page":"Physics","title":"Physics","text":"In the case of propagation with magnetic field, a particle may be \"pinned\" (collision-less): There are no possible collisions that take place and the particle will revolve in circles forever. This can happen for specific initial conditions depending on your billiard table and the angular velocity ω. The function ispinned shows you whether a particle meets the conditions.","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"ispinned","category":"page"},{"location":"physics/#DynamicalBilliards.ispinned","page":"Physics","title":"DynamicalBilliards.ispinned","text":"ispinned(p::MagneticParticle, bd::Billiard)\n\nReturn true if the particle is pinned with respect to the billiard. Pinned particles either have no valid collisions (go in circles forever) or all their valid collisions are with periodic walls, which again means that they go in cirles for ever.\n\n\n\n\n\n","category":"function"},{"location":"physics/#","page":"Physics","title":"Physics","text":"","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"In such event, the convention followed by DynamicalBilliards is the following: evolve! returns the expected output, however all returned vectors have only 2 entries. The collision times always have the entries 0.0, Inf. All other returned vectors have the initial conditions, repeated once.","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"evolve! can be given an additional warning keyword argument in the case of magnetic propagation, e.g. warning = true that throws a  message whenever a pinned particle is evolved.","category":"page"},{"location":"physics/#Velocity-measure-1","page":"Physics","title":"Velocity measure","text":"","category":"section"},{"location":"physics/#","page":"Physics","title":"Physics","text":"Both Particle and MagneticParticle are assumed to always have a velocity vector of measure 1 during evolution. This simplifies the formulas used internally to a significant amount.","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"However, during ray-splitting, the a MagneticParticle may be in areas with different angular velocities (result of the ω_new function). Physically, in such a situation, the velocity measure of the particle could also change. This change depends on the forces acting on the particle (e.g. magnetic field) as well as the relation of the momentum with the velocity (functional type of kinetic energy).","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"In any case, such a change is not accounted for internally by DynamicalBilliards. However it is very easy to implement this by \"re-normalizing\" the angular velocities you use. Since the \"code\" velocity has measure one, the rotation radius is given by","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"r = frac1omega_textcode = fracv_textrealomega_textreal","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"then one simply has to adjust the values of ω given in the code with","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"omega_textcode = fracomega_textrealv_textreal","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"After getting the timeseries:","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"# These are the \"code\"-data. |v| = 1 always\r\nct, poss, vels, omegas = evolve(p, bd, ttotal)\r\nxt, yt, vxt, vyt, t = timeseries(p, bd, ttotal)","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"you only need to make some final adjustment on the vxt, vyt. The position and time data are completely unaffected.","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"omegas_code = omegas\r\n# real angular velocities:\r\nomegas_real = supplied_by_user\r\n# or with some user provided function:\r\nf = o -> (o == 0.5 ? 2o : o*√2)\r\nomegas_real = f.(omegas_code)\r\n# real velocity measure:\r\nvels_real = abs.(omegas_real ./ omegas_code)\r\n\r\ncontt = cumsum(ct)\r\nomega_t = zeros(t)\r\nvxtreal = copy(vxt)\r\nvytreal = copy(vyt)\r\nj = 1\r\nfor i in eachindex(t)\r\n  vxtreal[i] *= vels_real[j]\r\n  vytreal[i] *= vels_real[j]\r\n  omega_t[i] = omegas_real[j]\r\n\r\n  if t[i] >=  contt[j]\r\n    j += 1\r\n  end\r\nend","category":"page"},{"location":"physics/#","page":"Physics","title":"Physics","text":"Now you can be sure that the particle at time t[i] had real velocity [vxtreal[i], vytreal[i]] and was propagating with real angular velocity omega_t[i].","category":"page"},{"location":"tutorials/own_obstacle/#Defining-your-own-Obstacles-1","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"","category":"section"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"In this tutorial we will go through the processes of creating a new obstacle type, a Semicircle. This type is already used in the billiard_bunimovich and billiard_mushroom functions.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"info: Everything uses `SVector{2}`\nFields of Particles and Obstacles contain all their information in 2-dimensional static vectors from module StaticArrays. This is important to keep in mind when extending new methods.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"info: Extends internal APIs\nNotice that implementing your own obstacle requires you to extend methods that do not belong to the public API.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"note: See also the `Ellipse` PR\nPull Request #159 implements the Ellipse obstacle, step by step, by following the tutorial of this page. All commits are commented and it can be a second helpful guide on how to implement an obstacle.","category":"page"},{"location":"tutorials/own_obstacle/#Type-Definition-1","page":"Defining your own Obstacles","title":"Type Definition","text":"","category":"section"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"The first thing you have to do is make your new type a sub-type of Obstacle{T} (or any other abstract sub-type of it). We will do:","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"struct Semicircle{T<:AbstractFloat} <: Circular{T} # <: Obstacle{T}\n    c::SVector{2,T} # this MUST be a static vector\n    r::T\n    facedir::SVector{2,T} # this MUST be a static vector\n    name::String # this is an OPTIONAL field\nend","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"c is the center and r is the radius of the full circle. facedir is the direction which the semicircle is facing, which is also the direction of its \"open\" face.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"name is an optional field, that allows one to easily identify which obstacle is which. It is also used when printing a Billiard. If not used, then string(typeof(obstacle)) is used instead.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"Notice that the struct must be parameterized by T<:AbstractFloat (see the Numerical Precision page for more).","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"For convenience, we will also define:","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"function Semicircle(\n    c::AbstractVector{T}, r::Real, facedir, name = \"Semicircle\") where {T<:Real}\n    S = T <: Integer ? Float64 : T\n    return Semicircle{S}(SVector{2,S}(c), convert(S, abs(r)), name)\nend","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"so that constructing a Semicircle is possible from arbitrary vectors.","category":"page"},{"location":"tutorials/own_obstacle/#Necessary-Methods-1","page":"Defining your own Obstacles","title":"Necessary Methods","text":"","category":"section"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"The following functions must obtain methods for Semicircle (or any other custom Obstacle) in order for it to work with DynamicalBilliards:","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"DynamicalBilliards.normalvec\nDynamicalBilliards.distance (with arguments (position, obstacle))\nDynamicalBilliards.collision with Particle","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"Assuming that upon collision a specular reflection happens, then you don't need to define a method for DynamicalBilliards.specular!. You can however define custom methods for DynamicalBilliards.specular!, which is what we have done e.g. for RandomDisk.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"note: Use `import`!\nNotice that you have to properly import the methods to extend them. For example, do import DynamicalBilliards: normalvec, distance, collision time.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"The first method is very simple, just do:","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"import DynamicalBilliards: normalvec, distance, collision\nnormalvec(d::Semicircle, pos) = normalize(d.c - pos)","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"Since the function is only used during distance and DynamicalBilliards.resolvecollision! and since we will be writing explicit methods for the first, we don't have to care about what happens when the particle is far away from the boundary.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"The distance method is a bit tricky. Since the type already subtypes Circular, the following definition from DynamicalBilliards applies:","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"distance(pos::AbstractVector, d::Circular) = norm(pos - d.c) - d.r","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"However, the method must be expanded. That is because when the particle is on the \"open\" half of the disk, the distance is not correct. We write:","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"SV = SVector{2} #convenience\nfunction distance(pos::AbstractVector{T}, s::Semicircle{T}) where {T}\n    # Check on which half of circle is the particle\n    v1 = pos .- s.c\n    nn = dot(v1, s.facedir)\n    if nn ≤ 0 # I am \"inside semicircle\"\n        return s.r - norm(pos - s.c)\n    else # I am on the \"other side\"\n        end1 = SV(s.c[1] + s.r*s.facedir[2], s.c[2] - s.r*s.facedir[1])\n        end2 = SV(s.c[1] - s.r*s.facedir[2], s.c[2] + s.r*s.facedir[1])\n        return min(norm(pos - end1), norm(pos - end2))\n    end\nend","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"Notice that this definition always returns positive distance when the particle is on the \"other side\".","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"Finally, the method for collision is by far the most trickiest. But, with pen, paper and a significant amount of patience, one can find a way:","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"function collision(p::Particle{T}, d::Semicircle{T})::T where {T}\n\n    dc = p.pos - d.c\n    B = dot(p.vel, dc)         #velocity towards circle center: B > 0\n    C = dot(dc, dc) - d.r*d.r    #being outside of circle: C > 0\n    Δ = B^2 - C\n\n    Δ ≤ 0 && return nocollision(T)\n    sqrtD = sqrt(Δ)\n\n    nn = dot(dc, d.facedir)\n    if nn ≥ 0 # I am NOT inside semicircle\n        # Return most positive time\n        t = -B + sqrtD\n    else # I am inside semicircle:\n        t = -B - sqrtD\n        # these lines make sure that the code works for ANY starting position:\n        if t ≤ 0 || distance(p, d) ≤ accuracy(T)\n            t = -B + sqrtD\n        end\n    end\n    # This check is necessary to not collide with the non-existing side\n    newpos = p.pos + p.vel * t\n    if dot(newpos - d.c, d.facedir) ≥ 0 # collision point on BAD HALF;\n        return nocollision(T)\n    end\n    # If collision time is negative, return Inf:\n    t ≤ 0.0 ? nocollision(T) : (t, p.pos + t*p.vel)\nend","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"And that is all. The obstacle now works perfectly fine for straight propagation.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"note: Ray-Splitting support\nSupporting ray-splitting for your custom obstacle is very easy. The first step is to give it a field called pflag, which is a Bool. The second step is to ensure that collisiontime works properly for particles coming from both directions of the obstacle! Both inside or outside! This is implemented for Ellipse in Pull Request #159.","category":"page"},{"location":"tutorials/own_obstacle/#Optional-Methods-1","page":"Defining your own Obstacles","title":"Optional Methods","text":"","category":"section"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"DynamicalBilliards.cellsize : Enables randominside with this obstacle.\ncollision with MagneticParticle : enables magnetic propagation\nplot with obstacle : enables plotting\nDynamicalBilliards.specular! with offset : Allows lyapunovspectrum to be computed.\nto_bcoords : Allows the boundarymap and boundarymap_portion to be computed.\nfrom_bcoords : Allows phasespace_portion to be computed.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"The DynamicalBilliards.cellsize method is kinda trivial:","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"import DynamicalBilliards: cellsize, plot, to_bcoords, from_bcoords\n\nfunction cellsize(a::Semicircle{T}) where {T}\n    xmin, ymin = a.c - a.r\n    xmax, ymax = a.c + a.r\n    return xmin, ymin, xmax, ymax\nend","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"The collision method for MagneticParticle is also tricky, however it is almost identical with the method for the general Circular obstacle:","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"function collision(p::MagneticParticle{T}, o::Semicircle{T})::T where {T}\n    ω = p.omega\n    pc, rc = cyclotron(p)\n    p1 = o.c\n    r1 = o.r\n    d = norm(p1-pc)\n    if (d >= rc + r1) || (d <= abs(rc-r1))\n        return nocollision(T)\n    end\n    # Solve quadratic:\n    a = (rc^2 - r1^2 + d^2)/2d\n    h = sqrt(rc^2 - a^2)\n    # Collision points (always 2):\n    I1 = SVector{2, T}(\n        pc[1] + a*(p1[1] - pc[1])/d + h*(p1[2] - pc[2])/d,\n        pc[2] + a*(p1[2] - pc[2])/d - h*(p1[1] - pc[1])/d\n    )\n    I2 = SVector{2, T}(\n        pc[1] + a*(p1[1] - pc[1])/d - h*(p1[2] - pc[2])/d,\n        pc[2] + a*(p1[2] - pc[2])/d + h*(p1[1] - pc[1])/d\n    )\n    # Only consider intersections on the \"correct\" side of Semicircle:\n    cond1 = dot(I1-o.c, o.facedir) < 0\n    cond2 = dot(I2-o.c, o.facedir) < 0\n    # Collision time, equiv. to arc-length until collision point:\n    θ, I = nocollision(T)\n    if cond1 || cond2\n        for (Y, cond) in ((I1, cond1), (I2, cond2))\n            if cond\n                φ = realangle(p, o, Y)\n                φ < θ && (θ = φ; I = Y)\n            end\n        end\n    end\n    # Collision time = arc-length until collision point\n    return θ*rc, I\nend\n","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"Then, we add swag by writing a method for plot:","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"using PyPlot\n\nfunction plot(d::Semicircle; kwargs...)\n    theta1 = atan(d.facedir[2], d.facedir[1])*180/π + 90\n    theta2 = theta1 + 180\n    edgecolor = DynamicalBilliards.obcolor(d)\n    s1 = PyPlot.matplotlib.patches.Arc(\n        d.c, 2d.r, 2d.r, theta1 = theta1, theta2 = theta2, edgecolor = edgecolor,\n        lw = 2.0, kwargs...)\n    PyPlot.gca().add_artist(s1)\n    PyPlot.show()\nend","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"To enable computation of Lyapunov exponents in billiards with your obstacle, you have to write another method for specular! that also handles the evolution of perturbation vectors in tangent space. For this, the method has to accept an argument of type Vector{SVector{4, T}}, which contains the four perturbation vectors corresponding to the four Lyapunov exponents.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"Finding a formula for the evolution of the perturbations requires some tricky calculations. Fortunately for us, the results for general circular obstacles were already determined by Dellago, Posch and Hoover [1] – we just have to implement them.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"function specular!(p::Particle{T}, o::Circular{T},\n\toffset::Vector{SVector{4, T}}) where {T<:AbstractFloat}\n\n    n = normalvec(o, p.pos)\n    ti = SV{T}(-p.vel[2],p.vel[1])\n\n    cosa = -dot(n, p.vel)\n    p.vel = p.vel + 2*cosa*n\n\n    tf = SV{T}(-p.vel[2], p.vel[1])\n\n    for k in 1:4\n        δqprev = offset[k][δqind]\n        δpprev = offset[k][δpind]\n        # Formulas from Dellago, Posch and Hoover, PRE 53, 2, 1996: 1485-1501 (eq. 27)\n        # with norm(p) = 1\n        δq  = δqprev - 2*dot(δqprev,n)*n\n        δp  = δpprev - 2*dot(δpprev,n)*n - curvature(o)*2/o.r*dot(δqprev,ti)/cosa*tf\n        ###\n        offset[k] = vcat(δq, δp)\n    end\nend\n\n@inline curvature(::Semicircle) = -1\n@inline curvature(::Disk) = +1\n","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"Note that calculating Lyapunov exponents for magnetic particles requires a separate method, as the formulas are different for magnetic propagation.","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"Finally, we also add a methods for to_bcoords and from_bcoords. For them, see the relevant source file (use @which).","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"References","category":"page"},{"location":"tutorials/own_obstacle/#","page":"Defining your own Obstacles","title":"Defining your own Obstacles","text":"[1] : Ch. Dellago et al., Phys. Rev. E 53, 1485 (1996).","category":"page"},{"location":"basic/phasespaces/#Phase-Spaces-1","page":"Phase Spaces","title":"Phase Spaces","text":"","category":"section"},{"location":"basic/phasespaces/#Coordinate-Systems-1","page":"Phase Spaces","title":"Coordinate Systems","text":"","category":"section"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"Any billiard has two coordinate systems:","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"The \"real\" coordinates, i.e. the coordinates that specify the full, three-dimensional phase space: x y phi.\nThe \"boundary\" coordinates, also known as Birkhoff coordinates, which instead reduce the continuous billiard into a map, by only considering the collision points. These coordinates are only two: xi sin(phi_n), with xi being the parametrization of the arc length and phi_n being the angle as measured from the normal vector.","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"With DynamicalBilliards it is very easy to switch between the two coordinate systems, using:","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"to_bcoords\nfrom_bcoords\narcintervals","category":"page"},{"location":"basic/phasespaces/#DynamicalBilliards.to_bcoords","page":"Phase Spaces","title":"DynamicalBilliards.to_bcoords","text":"to_bcoords(pos, vel, o::Obstacle) -> ξ, sφ\n\nConvert the real coordinates pos, vel to boundary coordinates (also known as Birkhoff coordinates) ξ, sφ, assuming that pos is on the obstacle.\n\nξ is the arc-coordinate, i.e. it parameterizes the arclength of the obstacle. sφ is the sine of the angle between the velocity vector and the vector normal to the obstacle.\n\nThe arc-coordinate ξ is measured as:\n\nthe distance from start point to end point in Walls\nthe arc length measured counterclockwise from the open face in Semicircles\nthe arc length measured counterclockwise from the rightmost point in Circular/Ellipses\n\nNotice that this function returns the local arclength. To get the global arclength parameterizing an entire billiard, simply do ξ += arcintervals(bd)[i] if the index of obstacle o is i.\n\nSee also from_bcoords, which is the inverse function.\n\n\n\n\n\n","category":"function"},{"location":"basic/phasespaces/#DynamicalBilliards.from_bcoords","page":"Phase Spaces","title":"DynamicalBilliards.from_bcoords","text":"from_bcoords(ξ, sφ, o::Obstacle) -> pos, vel\n\nConvert the boundary coordinates ξ, sφ on the obstacle to real coordinates pos, vel.\n\nNote that vel always points away from the obstacle.\n\nThis function is the inverse of to_bcoords.\n\n\n\n\n\nfrom_bcoords(ξ, sφ, bd::Billiard, intervals = arcintervals(bd))\n\nSame as above, but now ξ is considered to be the global arclength, parameterizing the entire billiard, instead of a single obstacle.\n\n\n\n\n\n","category":"function"},{"location":"basic/phasespaces/#DynamicalBilliards.arcintervals","page":"Phase Spaces","title":"DynamicalBilliards.arcintervals","text":"arcintervals(bd::Billiard) -> s\n\nGenerate a vector s, with entries being the delimiters of the arclengths of the obstacles of the billiard. The arclength from s[i] to s[i+1] is the arclength spanned by the ith obstacle.\n\ns is used to transform an arc-coordinate ξ from local to global and vice-versa. A local ξ becomes global by adding s[i] (where i is the index of current obstacle). A global ξ becomes local by subtracting s[i].\n\nSee also boundarymap, to_bcoords, from_bcoords.\n\n\n\n\n\n","category":"function"},{"location":"basic/phasespaces/#Boundary-Maps-1","page":"Phase Spaces","title":"Boundary Maps","text":"","category":"section"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"Boundary maps can be obtained with the high level function","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"boundarymap","category":"page"},{"location":"basic/phasespaces/#DynamicalBilliards.boundarymap","page":"Phase Spaces","title":"DynamicalBilliards.boundarymap","text":"boundarymap(p, bd, t [,intervals]) → bmap, arclengths\n\nCompute the boundary map of the particle p in the billiard bd by evolving the particle for total amount t (either float for time or integer for collision number).\n\nReturn a vector of 2-vectors bmap and also arclengths(bd). The first entry of each element of bmap is the arc-coordinate at collisions xi, while the second  is the sine of incidence angle sin(phi_n).\n\nThe measurement direction of the arclengths of the individual obstacles is dictated by their order in bd. The sine of the angle is computed after specular reflection has taken place.\n\nThe returned values of this function can be used in conjuction with the function plot_boundarymap (requires using PyPlot) to plot the boundary map in an intuitive way.\n\nNotice - this function only works for normal specular reflection. Random reflections or ray-splitting will give unexpected results.\n\nSee also to_bcoords, boundarymap_portion. See parallelize for a parallelized version.\n\n\n\n\n\n","category":"function"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"For example, take a look at boundary maps of the mushroom billiard, which is known to have a mixed phase space:","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"using DynamicalBilliards, PyPlot\n\nbd = billiard_mushroom()\n\nn = 100 # how many particles to create\nt = 200 # how long to evolve each one\n\nbmap, arcs = parallelize(boundarymap, bd, t, n)\n\nusing PyPlot # enables plot_boundarymap function\n\ncolors = [\"C$(rand(1:9))\" for i in 1:n] # random colors\n\nplot_boundarymap(bmap, arcs, color = colors)\ntight_layout()\nsavefig(\"boundarymap.svg\"); nothing # hide","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"(Image: )","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"And of course similarly for magnetic fields","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"bmap, arcs = parallelize(boundarymap, bd, t, n, 1.0)\nplot_boundarymap(bmap, arcs, color = colors)\ntight_layout()\nsavefig(\"boundarymapmag.svg\"); nothing # hide","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"(Image: )","category":"page"},{"location":"basic/phasespaces/#Phase-Space-Portions-1","page":"Phase Spaces","title":"Phase Space Portions","text":"","category":"section"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"It is possible to compute the portion of phase space covered by a particle as it is evolved in time. We have two methods, one for the \"boundary\" coordinates (2D space) and one for the \"real\" coordinates (3D space):","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"boundarymap_portion\nphasespace_portion","category":"page"},{"location":"basic/phasespaces/#DynamicalBilliards.boundarymap_portion","page":"Phase Spaces","title":"DynamicalBilliards.boundarymap_portion","text":"boundarymap_portion(bd::Billiard, t, p::AbstractParticle, δξ, δφ = δξ)\n\nCalculate the portion of the boundary map of the billiard bd covered by the particle p when it is evolved for time t (float or integer). Notice that the\n\nThe boundary map is partitioned into boxes of size (δξ, δφ) and as the particle evolves visited boxes are counted. The returned ratio is this count divided by the total boxes of size (δξ, δφ) needed to cover the boundary map.\n\nImportant: This portion does not equate the portion the particle's orbit covers on the full, three dimensional phase space. Use the function phasespace_portion for that!\n\n\n\n\n\n","category":"function"},{"location":"basic/phasespaces/#DynamicalBilliards.phasespace_portion","page":"Phase Spaces","title":"DynamicalBilliards.phasespace_portion","text":"phasespace_portion(bd::Billiard, t, p::AbstractParticle, δξ, δφ = δξ)\n\nCalculate the portion of the phase space of the billiard bd covered by the particle p when it is evolved for time t (float or integer).\n\nThis function extends boundarymap_portion using a novel approach. For each visited box of the boundary map, bounce! attributes a third dimension (the collision time, equal to collision distance) which expands the two dimensions of the boundary map to the three dimensions of the phase space.\n\nThe true phase space portion is then the weighted portion of boxes visited by the particle, divided by the total weighted sum of boxes. The weights of the boxes are the collision times.\n\n\n\n\n\n","category":"function"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"For example, for mushroom billiards the ratio of the chaotic-to-total phase space is known analytically for both the full 3D [1] space as well as the boundary 2D [2] space:","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"beginaligned\n  g_textc 3D = frac2  pi r^2 - 4  r^2 arccosleft(fracw2  rright) + 4  l w + sqrt4  r^2 - w^2 w2  left(pi r^2 + 2  l wright)\n  g_textc 2D = fracpi w + 2  w arccosleft(fracw2  rright) + 4  l + 4  r - 2  sqrt4  r^2 - w^22  left(pi r + 2  l + 2  rright)\nendaligned","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"We can easily confirm those formulas:","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"using DynamicalBilliards\n\nt = 1000000.0\nl = 1.0; r = 1.0; w = 0.4\n\nbd = billiard_mushroom(l, w, r)\n\np = MushroomTools.randomchaotic(l, w, r)\n\nratio, dic = boundarymap_portion(bd, t, p, 0.01)\ntrueratio = MushroomTools.g_c_2D(l,w,r)\nprintln(\"2D numeric - theory: $(abs(ratio - trueratio))\")\n\nratio = phasespace_portion(bd, t, p, 0.01)\ntrueratio = MushroomTools.g_c_3D(l,w,r)\nprintln(\"3D numeric - theory: $(abs(ratio - trueratio))\")","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"Of course, increasing evolution time and decreasing boxsize will bring higher accuracy.","category":"page"},{"location":"basic/phasespaces/#References-1","page":"Phase Spaces","title":"References","text":"","category":"section"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"[1] : A. H. Barnett & T. Betcke, Quantum mushroom billiards, Chaos, 17(4) (20017)","category":"page"},{"location":"basic/phasespaces/#","page":"Phase Spaces","title":"Phase Spaces","text":"[2] : Lukas Hupe, B.Sc. Thesis (2018), to be published","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: DynamicalBilliards v3.0 Logo: The Julia billiard)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"DynamicalBilliards is an easy-to-use, modular and extendable Julia package for dynamical billiards in two dimensions. It is part of JuliaDynamics, an organization dedicated to creating high quality scientific software.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"info: Latest news\nThe timeseries! function now supports evolving particles until a certain condition (specified by a function) is met.","category":"page"},{"location":"#About-Billiards-1","page":"Introduction","title":"About Billiards","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"A dynamical billiard is a system where a particle is propagating inside a domain, bouncing from obstacle to obstacle (i.e. the boundary of the domain) by a specular reflection at the boundary of the obstacles. This basic idea can be extended in many ways, one of which is replacing the particle orbit from a straight line to a circle.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Billiard systems have been used extensively in mathematics, nonlinear dynamics and chaos and played an important role in the development of nonlinear science. The wikipedia page has many examples of different types of billiards. Also, the scholarpedia entry is a good read on the subject.","category":"page"},{"location":"#Features-1","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Particles are evolved by solving exactly the geometric equations for intersections between lines, circles, ellipses, and other shapes. There are no approximations done regarding the dynamics.\nModular creation of a Billiard from well defined obstacles. Arbitrary billiard shapes can be made and no shape is \"hard coded\".\nFull support for both straight  and magnetic propagation of a particle in a billiard table.\nDuring magnetic propagation the particle orbit is a circle instead of a line!\nAll features exist for both types of propagation!\nSee the High Level API to get started!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Support for creating Random initial conditions in an arbitrary billiard.\nRay-Splitting: a particle may propagate through an obstacle given arbitrary transmission and refraction laws. This is also known as a \"semiclassical billiard\".\nPoincaré Sections (intersections with arbitrary plane).\nBoundary Maps.\nEscape Times & Mean Collision Times.\nLyapunov Exponents.\nSupport for both coordinate systems: 3D real space and boundary coordinates.\nNovel algorithms that compute the portion of either the 2D boundary space or the 3D real space that an orbit covers as a particle evolves. See the Phase Spaces section.\nEasy to use low-level interface, described at the Internals page.\nSpecialized tools for mushroom billiards.\nFull support for Visualizing & Animating billiards and motion in billiards.\nBrutal tests that confirm the package works and overcomes numerical precision issues.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package does not support finite-sized particles and, as a result, there is also no support for collision between particles.","category":"page"},{"location":"#Citing-1","page":"Introduction","title":"Citing","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you have used this package for research that resulted in a publication, please be kind enough to cite the software paper associated with DynamicalBilliards. The DOI is https://doi.org/10.21105/joss.00458 and you can cite as:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"G. Datseris, [The Journal of Open Source Software 2, 458","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(2017)](https://doi.org/10.21105/joss.00458).","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"or if you use BibTeX:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"@article{Datseris2017,\r\n  doi = {10.21105/joss.00458},\r\n  url = {https://doi.org/10.21105/joss.00458},\r\n  year  = {2017},\r\n  month = {nov},\r\n  volume = {2},\r\n  number = {19},\r\n  pages = {458},\r\n  author = {George Datseris},\r\n  title = {{DynamicalBilliards}.jl: An easy-to-use,  modular and extendable Julia package for Dynamical Billiard systems in two dimensions.},\r\n  journal = {The Journal of Open Source Software}\r\n}","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"In addition, if you are using the functionality to compute Lyapunov exponents in billiards, then please cite the following Chaos publication:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"@article{Datseris2019,\r\n  doi = {10.1063/1.5099446},\r\n  url = {https://doi.org/10.1063/1.5099446},\r\n  year = {2019},\r\n  month = sep,\r\n  publisher = {{AIP} Publishing},\r\n  volume = {29},\r\n  number = {9},\r\n  pages = {093115},\r\n  author = {George Datseris and Lukas Hupe and Ragnar Fleischmann},\r\n  title = {Estimating Lyapunov exponents in billiards},\r\n  journal = {Chaos: An Interdisciplinary Journal of Nonlinear Science}\r\n}","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package is registered, simply use ] to get into the package manager mode and then type add DynamicalBilliards to install it. The stable documentation accompanies the version installed with add.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"To confirm the validity of your installation you can run the tests of DynamicalBilliards. This can be done via ] test DynamicalBilliards.","category":"page"},{"location":"#Plotting-1","page":"Introduction","title":"Plotting","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Plotting is done through the PyPlot module. All plotting functions are brought into scope when using PyPlot is done.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"In addition, for animations using the function animate_evolution the ffmpeg software must be accessible from the command line.","category":"page"},{"location":"#How-to-easily-code-a-Billiard-1","page":"Introduction","title":"How to easily code a Billiard","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"We have created a Jupyter notebook that showcases how easy it is to simulate a dynamical billiard using Julia. This notebook is an educative example of both using Multiple Dispatch and of how the internal code of DynamicalBilliards works. It also highlights the extendibility of the core code.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Besides a Jupyter notebook, this tutorial is also available as an interactive article in the new platform NextJournal here.","category":"page"},{"location":"#Support-1","page":"Introduction","title":"Support","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you are having any kind of problems with DynamicalBilliards do not hesitate to seek for support! There are numerous ways to do that:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Visit our official chatroom on Gitter: https://gitter.im/JuliaDynamics/Lobby\nOpen a new issue at our GitHub issues page.","category":"page"},{"location":"#Contributing-1","page":"Introduction","title":"Contributing","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Everyone is welcomed to contribute to DynamicalBilliards! If you have some new algorithm, types of Obstacles or anything new to add, do not hesitate! For formal questions about e.g. structuring of code it is best to contact us through the gitter chatroom or by opening a new Pull Request and asking for a review of your code.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you would like to help but do not have anything new to contribute, please go ahead and take a look at the GitHub issues page of the package. Some of the existing issues are easy to solve and are there specifically for people that would like to contribute.","category":"page"}]
}
