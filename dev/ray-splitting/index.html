<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ray-Splitting · DynamicalBilliards.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DynamicalBilliards.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalBilliards.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../basic/high_level/">High Level API</a></li><li><a class="tocitem" href="../visualizing/">Visualizing &amp; Animating</a></li><li><a class="tocitem" href="../basic/phasespaces/">Phase Spaces</a></li><li class="is-active"><a class="tocitem" href>Ray-Splitting</a><ul class="internal"><li><a class="tocitem" href="#.-Ray-Splitting-Obstacles"><span>1. Ray-Splitting Obstacles</span></a></li><li><a class="tocitem" href="#.-The-RaySplitter-structure"><span>2. The <code>RaySplitter</code> structure</span></a></li><li><a class="tocitem" href="#.-Evolution-with-Ray-Splitting"><span>3. Evolution with Ray-Splitting</span></a></li><li><a class="tocitem" href="#The-Ray-Splitting-Algorithm"><span>The Ray-Splitting Algorithm</span></a></li><li><a class="tocitem" href="#Physics-of-the-Ray-Splitting-Functions"><span>Physics of the Ray-Splitting Functions</span></a></li><li><a class="tocitem" href="#Snell&#39;s-Law"><span>Snell&#39;s Law</span></a></li><li><a class="tocitem" href="#Example-of-Affecting-Multiple-Obstacles"><span>Example of Affecting Multiple Obstacles</span></a></li></ul></li><li><a class="tocitem" href="../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../mushroomtools/">MushroomTools</a></li><li><a class="tocitem" href="../physics/">Physics</a></li><li><a class="tocitem" href="../basic/low_level/">Internals</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/billiard_table/">Defining a Billiard</a></li><li><a class="tocitem" href="../tutorials/own_obstacle/">Defining your own Obstacles</a></li><li><a class="tocitem" href="../tutorials/examples/">Examples</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Ray-Splitting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ray-Splitting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/master/docs/src/ray-splitting.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ray-Splitting"><a class="docs-heading-anchor" href="#Ray-Splitting">Ray-Splitting</a><a id="Ray-Splitting-1"></a><a class="docs-heading-anchor-permalink" href="#Ray-Splitting" title="Permalink"></a></h1><p>Ray-splitting is a semi-classical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission &amp; refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three simple steps. We will introduce them and demonstrate them using a simple example in this documentation page.</p><h2 id=".-Ray-Splitting-Obstacles"><a class="docs-heading-anchor" href="#.-Ray-Splitting-Obstacles">1. Ray-Splitting Obstacles</a><a id=".-Ray-Splitting-Obstacles-1"></a><a class="docs-heading-anchor-permalink" href="#.-Ray-Splitting-Obstacles" title="Permalink"></a></h2><p>The first step is that an <a href="../tutorials/billiard_table/#DynamicalBilliards.Obstacle"><code>Obstacle</code></a> that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called <code>pflag</code> (propagation flag). This field notes on which side of the obstacle the particle is currently propagating.</p><p>The normal vector as well as the distance from boundary change sign depending on the value of <code>pflag</code>. The obstacles <a href="../tutorials/billiard_table/#DynamicalBilliards.Antidot"><code>Antidot</code></a> and <a href="../tutorials/billiard_table/#DynamicalBilliards.SplitterWall"><code>SplitterWall</code></a> are the equivalents of disk and wall for ray-splitting.</p><p>Let&#39;s create a billiard with a bunch of ray-splitting obstacles!</p><pre><code class="language-julia">using DynamicalBilliards
x, y = 2.0, 1.0
bdr =  billiard_rectangle(x, y)
sw = SplitterWall([x/2, 0.0], [x/2,y], [-1,0], true)
a1 = Antidot([x/4, y/2], 0.25, &quot;Left Antidot&quot;)
a2 = Antidot([3x/4, y/2], 0.15, &quot;Right Antidot&quot;)
bd = Billiard(a1, a2, sw, bdr...)</code></pre><pre class="documenter-example-output">Billiard{Float64} with 7 obstacles:
  Left Antidot
  Right Antidot
  Splitter wall
  Bottom wall
  Right wall
  Top wall
  Left wall</pre><pre><code class="language-julia">using PyPlot
plot(bd)</code></pre><p><img src="../raybil.svg" alt/></p><h2 id=".-The-RaySplitter-structure"><a class="docs-heading-anchor" href="#.-The-RaySplitter-structure">2. The <code>RaySplitter</code> structure</a><a id=".-The-RaySplitter-structure-1"></a><a class="docs-heading-anchor-permalink" href="#.-The-RaySplitter-structure" title="Permalink"></a></h2><p>In the second step, you have to define 2+1 functions: transmission probability, refraction angle and optionally new angular velocity after transmission. These functions, as well as which obstacles participate in ray-splitting, are bundled into a special structure:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.RaySplitter" href="#DynamicalBilliards.RaySplitter"><code>DynamicalBilliards.RaySplitter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RaySplitter(idxs, transmission, refraction [, newangular]; affect)</code></pre><p>Return a <code>RaySplitter</code> instance, used to perform raysplitting. <code>idxs</code> is a <code>Vector{Int}</code> with the indices of the obstacles that this <code>RaySplitter</code> corresponds to.</p><p><code>transmission</code>, <code>refraction</code> and <code>newangular</code> are <strong>functions</strong>. Let <code>φ</code> be the angle of incidence and <code>ω</code> be the angular velocity and <code>pflag</code> the propagation flag (before transmission). The functions have the following signatures:</p><ol><li><code>transmission(φ, pflag, ω) -&gt; T</code>, transmission probability.</li><li><code>refraction(φ, pflag, ω) -&gt; θ</code>, refraction angle. This angle is <em>relative</em> to the normal vector.</li><li><code>newangular(ω, pflag) -&gt; newω</code>, new angular velocity after transmission.</li></ol><p>The above three functions use the <strong>same convention</strong>: the argument <code>pflag</code> is the one the obstacle has <strong>before transmission</strong>. For example, if a particle is outside an <a href="../tutorials/billiard_table/#DynamicalBilliards.Antidot"><code>Antidot</code></a> (with <code>pflag = true</code> here) and is transmitted inside the <code>Antidot</code> (<code>pflag</code> becomes <code>false</code> here), then all three functions will be given their second argument (the Boolean one) as <code>true</code>!</p><p><code>affect</code> is a function, and denotes which obstacles of the billiard are affected when transmission occurs at obstacle <code>i</code> (for which obstacles should the field <code>pflag</code> be reversed). Defaults to <code>idxs = (i) -&gt; i</code>, i.e. only the colliding obstacle is affected. If you want many obstacles to be affected you could write <code>idxs = (i) -&gt; SVector(2,3,5)</code>, etc. Keep in mind that the only values of <code>i</code> that can be passed into this function are the ones that are given in the argument <code>idxs</code>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/raysplitting.jl#L8-L38">source</a></section></article><p>If you want different type of transmission/refraction functions for different obstacles, then you define multiple <code>RaySplitter</code>s.</p><p>Continuing from the above billiard, let&#39;s also create some <code>RaySplitter</code> instances for it.</p><p>First define a refraction function</p><pre><code class="language-julia">refraction(φ, pflag, ω) = pflag ? 0.5φ : 2.0φ</code></pre><pre class="documenter-example-output">refraction (generic function with 1 method)</pre><p>Then, a transmission probability function. In this example, we want to create a function that given some factor <code>p</code>, it returns a probability weighted with <code>p</code> in one direction of ray-splitting and <code>1-p</code> in another direction.</p><pre><code class="language-julia">transmission_p(p) = (φ, pflag, ω) -&gt; begin
    if pflag
        p*exp(-(φ)^2/2(π/8)^2)
    else
        abs(φ) &lt; π/4 ? (1-p)*exp(-(φ)^2/2(π/4)^2) : 0.0
    end
end</code></pre><pre class="documenter-example-output">transmission_p (generic function with 1 method)</pre><p>Notice also how we defined the function in such a way that critical refraction is respected, i.e. if <code>θ(φ) ≥ π/2</code> then <code>T(φ) = 0</code>. Although this is necessary from a physical perspective, the code does take care of it by clamping the refraction angle (see below).</p><p>Lastly, for this example we will use magnetic propagation. We define functions such that the antidots also reverse the direction and magnitude of the magnetic field.</p><pre><code class="language-julia">newoantidot(x, bool) =  bool ? -2.0x : -0.5x
newowall(x, bool) = bool ? 0.5x : 2.0x</code></pre><pre class="documenter-example-output">newowall (generic function with 1 method)</pre><p>Now we create the <a href="#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances we want</p><pre><code class="language-julia">raywall = RaySplitter([3], transmission_p(0.5), refraction, newowall)
raya = RaySplitter([1, 2], transmission_p(0.8), refraction, newoantidot)</code></pre><pre class="documenter-example-output">RaySplitter for indices [1, 2]
 transmission: #1
 refraction:   refraction
 new angular:  newoantidot
 affect:       default
</pre><p>Because we want to use same functions for both antidots, we gave both indices in <code>raya</code>, <code>[1, 2]</code> (which are the indices of the antidots in the billiard <code>bd</code>).</p><h2 id=".-Evolution-with-Ray-Splitting"><a class="docs-heading-anchor" href="#.-Evolution-with-Ray-Splitting">3. Evolution with Ray-Splitting</a><a id=".-Evolution-with-Ray-Splitting-1"></a><a class="docs-heading-anchor-permalink" href="#.-Evolution-with-Ray-Splitting" title="Permalink"></a></h2><p>The third step is trivial. After you have created your <code>RaySplitter</code>(s), you simply pass them into <code>evolve</code> or <code>animate_evolution</code> as a fourth argument! If you have many instances of <code>RaySplitter</code> you pass a tuple of them.</p><p>For example,</p><pre><code class="language-julia">using Random
Random.seed!(42)
p = randominside(bd, 1.0)
raysplitters = (raywall, raya)
xt, yt, vxt, vyt, tt = timeseries(p, bd, 100, raysplitters)
plot(bd)
plot(xt, yt)
scatter(xt[1], yt[1], color = &quot;black&quot;)</code></pre><p><img src="../rayorbit.svg" alt/></p><p>You can see that at some points the particle crossed the boundaries of the red obstacles, which allow for ray splitting. It is even cooler to animate this motion using <a href="../visualizing/#DynamicalBilliards.animate_evolution"><code>animate_evolution</code></a>!</p><video width="100%" height="auto" controls>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/ray.mp4?raw=true" type="video/mp4">
</video><div class="admonition is-info"><header class="admonition-header">Resetting the billiard</header><div class="admonition-body"><p>Notice that evolving a particle inside a billiard always mutates the billiard if ray-splitting is used. This means that you should always set the fields <code>pflag</code> of some obstacles to the values you desire after <em>each</em> call to <code>evolve</code>. If you use the function <a href="../basic/high_level/#DynamicalBilliards.randominside"><code>randominside</code></a> you must definitely do this!</p><p>The function <code>reset_billiard!(bd)</code> turns all <code>pflag</code>s to <code>true</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Angle of refraction is clamped</header><div class="admonition-body"><p>Internally we clamp the output of the angle of refraction function. Let <code>c = DynamicalBilliards.CLAMPING_ANGLE</code> (currently <code>c = 0.1</code>). We clamp <code>θ</code> to <code>-π/2 + c ≤ θ ≤ π/2 - c</code>. This is so that the relocating algorithm does not fall into an infinite loop. You can change the value of <code>c</code> but very small values can lead to infinite loops in extreme cases.</p></div></div><h2 id="The-Ray-Splitting-Algorithm"><a class="docs-heading-anchor" href="#The-Ray-Splitting-Algorithm">The Ray-Splitting Algorithm</a><a id="The-Ray-Splitting-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Ray-Splitting-Algorithm" title="Permalink"></a></h2><p>In this section we describe the algorithm we follow to implement the ray-splitting process. Let <span>$T$</span> denote the transmission function, <span>$\theta$</span> the refraction function and <span>$\omega_{\text{new}}$</span> the new angular velocity function. The following describes the process after a particle has reached an obstacle that supports ray-splitting.</p><ol><li><p>Find the angle of incidence <span>$\phi&#39; = \pi - \arccos(\vec{v} \cdot \vec{n}) = \arccos(\vec{v} \cdot (-\vec{n}))$</span> with <span>$\vec{n}$</span> the normal vector at collision point. Notice that we use here <span>$-\vec{n}$</span> because the velocity is opposing the normal vector before the collision happens. Using <span>$-\vec{n}$</span> gives the angle between 0 and <span>$\pi/2$</span> instead of <span>$\pi/2$</span> to <span>$\pi$</span>.</p></li><li><p>Find the <em>correct</em> sign of the incidence angle, <span>$\phi = \pm \phi&#39;$</span>. Specifically, use the cross product: if the third entry of <span>$\vec{v} \times \vec{n}$</span> is negative, then have minus sign. The &quot;correct&quot; sign debates on whether the velocity vector is to the right or to the left of <span>$(-\vec{n})$</span>. This is important for finding the correct transmission angle and/or probability.</p></li><li><p>Check if <span>$T(\phi, \verb|pflag|, \omega) &gt; \text{random}()$</span>. If not, do standard specular reflection.</p></li><li><p>If ray-splitting happens, then relocate the particle so that it is on the <em>other</em> side of the colliding obstacle. This contrasts the main evolution algorithm of this billiard package.</p></li><li><p>Re-compute the <em>correct</em> angle of incidence, as the position of the particle generally changes with relocating.</p></li><li><p>Find refraction angle <span>$\theta(\phi, \verb|pflag|, \omega)$</span>. Notice that this is a relative angle with respect to the normal vector. Also notice that <span>$\theta$</span> may have opposite sign from <span>$\phi$</span>. It depends on the user if they want to add anomalous refraction.</p></li><li><p>Set <code>obstacle.pflag = !obstacle.pflag</code> for <em>all</em> obstacles affected by the current <code>RaySplitter</code>. This reverses <span>$\vec{n}$</span> to <span>$-\vec{n}$</span> as well! So from now on <span>$\vec{n}$</span> is the opposite than what it was at the beginning of the algorithm!</p></li><li><p>Find the refraction angle in absolute space. First find <span>$a = \text{atan}(n_y, n_x)$</span> and then set <span>$\Theta = a + \theta$</span>.</p></li><li><p>Perform refraction, i.e. set the particle velocity to the direction of <span>$\Theta$</span>.</p></li><li><p>Scale the magnetic field, i.e. set <code>p.omega</code> = <span>$\omega_{\text{new}}(\omega, \verb|!pflag|)$</span>. It is important to note that we use <code>!pflag</code> because we have already changed the <code>pflag</code> field.</p></li></ol><h2 id="Physics-of-the-Ray-Splitting-Functions"><a class="docs-heading-anchor" href="#Physics-of-the-Ray-Splitting-Functions">Physics of the Ray-Splitting Functions</a><a id="Physics-of-the-Ray-Splitting-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-of-the-Ray-Splitting-Functions" title="Permalink"></a></h2><p>If <code>T</code> is the transmission probability function, then the condition for transmission is simply: <code>T(φ, pflag, ω) &gt; rand()</code>. If it returns <code>true</code>, transmission (i.e. ray-splitting) will happen.</p><p>The functions given to <a href="#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> should have some properties in order to have physical meaning. In order to test if the <code>RaySplitter</code> you have defined has physical meaning, the function <code>isphysical</code> is provided</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.isphysical" href="#DynamicalBilliards.isphysical"><code>DynamicalBilliards.isphysical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isphysical(raysplitter(s))</code></pre><p>Return <code>true</code> if the given <code>raysplitters</code> have physically plausible properties.</p><p>Specifically, check if (φ is the incidence angle, θ the refraction angle):</p><ul><li>Critical angle means total reflection: If θ(φ) ≥ π/2 then Tr(φ) = 0</li><li>Transmission probability is even function: Tr(φ) ≈ Tr(-φ) at ω = 0</li><li>Refraction angle is odd function: θ(φ) ≈ -θ(-φ) at ω = 0</li><li>Ray reversal is true: θ(θ(φ, pflag, ω), !pflag, ω) ≈ φ</li><li>Magnetic conservation is true: (ω<em>new(ω</em>new(ω, pflag), !pflag) ≈ ω</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/raysplitting.jl#L327-L339">source</a></section></article><h2 id="Snell&#39;s-Law"><a class="docs-heading-anchor" href="#Snell&#39;s-Law">Snell&#39;s Law</a><a id="Snell&#39;s-Law-1"></a><a class="docs-heading-anchor-permalink" href="#Snell&#39;s-Law" title="Permalink"></a></h2><p>In classical geometric optics, the refraction of a ray of light moving from one medium to another is described by Snell&#39;s law. For an angle of incidence of <span>$\phi$</span>, the refraction angle <span>$\theta$</span> is determined by the equation</p><p class="math-container">\[\frac{sin(\phi)}{\sin(\theta)} = \frac{n&#39;}{n}\]</p><p>where <span>$n$</span> and <span>$n&#39;$</span> are the respective refractive indices of the media.</p><p>To easily simulate these relations in <code>DynamicalBilliards</code>, the function <code>law_of_refraction</code> can be used to set up ray-splitting according to this law.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.law_of_refraction" href="#DynamicalBilliards.law_of_refraction"><code>DynamicalBilliards.law_of_refraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">law_of_refraction(n1, n2 = 1.0) -&gt; t, r</code></pre><p>Create transmission and refraction functions <code>t, r</code> that follow Snell&#39;s law, i.e. the transmission probability is set to 1.0 except for the case of total internal reflection. </p><p><code>n1</code> is the index of refraction for the <code>pflag = false</code> side of an obstacle, while <code>n2</code> is the index of refraction for <code>pflag = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/raysplitting.jl#L400-L409">source</a></section></article><p>Using the functions returned by <code>law_of_refraction</code>, we can set up a <code>RaySplitter</code> for a billiard.</p><pre><code class="language-julia">using DynamicalBilliards, PyPlot
# Create a circular &quot;lens&quot;
o = Antidot(SVector(1.0, 0.75), 0.5)
# in a rectangular box
bd = Billiard(billiard_rectangle(2.5, 1.5)..., o)
# create a RaySplitter using law of refraction
trans, refra = law_of_refraction(1.5)
rs = (RaySplitter([5], trans, refra),)</code></pre><pre class="documenter-example-output">(RaySplitter for indices [5],)</pre><p>We now animate the evolution of an array of particles on parallel trajectories to demonstrate the refractive properties of the spherical lens</p><pre><code class="language-julia"># create parallel particles
ps = [Particle(0.1, y, 0.0) for y in 0.4:0.05:1.1]

# animate
animate_evolution(ps, bd, 2.0, rs, colors = [&quot;C0&quot; for i ∈ 1:length(ps)],
  tailtime=2.5, savename = &quot;lens&quot;)</code></pre><video width="100%" height="auto" controls>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/lens.mp4?raw=true" type="video/mp4">
</video><h2 id="Example-of-Affecting-Multiple-Obstacles"><a class="docs-heading-anchor" href="#Example-of-Affecting-Multiple-Obstacles">Example of Affecting Multiple Obstacles</a><a id="Example-of-Affecting-Multiple-Obstacles-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-Affecting-Multiple-Obstacles" title="Permalink"></a></h2><p>Here we will show an application of <em>inverse</em> billiards, where particles go in and out of a billiard, while taking advantage of the existence of a magnetic field outside to return.</p><p>As always, we define the ray-splitting functions:</p><pre><code class="language-julia">using DynamicalBilliards, PyPlot
trans(args...) = 1.0 # always perfect transmission
refra(φ, pflag, ω) = pflag ? 0.8φ : 1.25φ # refraction angle
neww(ω, pflag) = pflag ? 2.0 : 0.4</code></pre><pre class="documenter-example-output">neww (generic function with 1 method)</pre><p>Now, when we define the <a href="#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instance we will choose a different value for <code>affect</code>:</p><pre><code class="language-julia">ray = RaySplitter([1,2,3,4], trans, refra, neww, affect = (i) -&gt; SVector(1,2,3,4))</code></pre><pre class="documenter-example-output">RaySplitter for indices [1, 2, 3, 4]
 transmission: trans
 refraction:   refra
 new angular:  neww
 affect:       #3
</pre><p>We initialize a simple rectangular billiard and a particle</p><pre><code class="language-julia">bd = billiard_rectangle(setting = &quot;ray-splitting&quot;)
p = MagneticParticle(0.4, 0.6, 0.0, 0.4)</code></pre><pre class="documenter-example-output">MagneticParticle{Float64}
position: [0.4, 0.6]
velocity: [1.0, 0.0]
ang. velocity: 0.4</pre><p>and we animate its evolution, by first zooming out of the billiard</p><pre><code class="language-julia">plot(bd)
xlim(-1, 2); ylim(-1, 2);
animate_evolution(p, bd, 10.0, (ray,); ax = gca(), savename = &quot;inverse&quot;, tailtime = 3.0)</code></pre><video width="100%" height="auto" controls>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/billiards/inverse.mp4?raw=true" type="video/mp4">
</video></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basic/phasespaces/">« Phase Spaces</a><a class="docs-footer-nextpage" href="../lyapunovs/">Lyapunov Exponents »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 10 December 2020 01:29">Thursday 10 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
