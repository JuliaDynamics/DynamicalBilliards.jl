<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ray-Splitting · DynamicalBilliards.jl</title><meta name="title" content="Ray-Splitting · DynamicalBilliards.jl"/><meta property="og:title" content="Ray-Splitting · DynamicalBilliards.jl"/><meta property="twitter:title" content="Ray-Splitting · DynamicalBilliards.jl"/><meta name="description" content="Documentation for DynamicalBilliards.jl."/><meta property="og:description" content="Documentation for DynamicalBilliards.jl."/><meta property="twitter:description" content="Documentation for DynamicalBilliards.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DynamicalBilliards.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DynamicalBilliards.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../basic/high_level/">High Level API</a></li><li><a class="tocitem" href="../billiards_visualizations/">Visualizing &amp; Animating</a></li><li><a class="tocitem" href="../basic/phasespaces/">Phase Spaces</a></li><li class="is-active"><a class="tocitem" href>Ray-Splitting</a><ul class="internal"><li><a class="tocitem" href="#1.-Ray-Splitting-Obstacles"><span>1. Ray-Splitting Obstacles</span></a></li><li><a class="tocitem" href="#2.-The-RaySplitter-structure"><span>2. The <code>RaySplitter</code> structure</span></a></li><li><a class="tocitem" href="#3.-Evolution-with-Ray-Splitting"><span>3. Evolution with Ray-Splitting</span></a></li><li><a class="tocitem" href="#The-Ray-Splitting-Algorithm"><span>The Ray-Splitting Algorithm</span></a></li><li><a class="tocitem" href="#Physics-of-the-Ray-Splitting-Functions"><span>Physics of the Ray-Splitting Functions</span></a></li><li><a class="tocitem" href="#Snell&#39;s-Law"><span>Snell&#39;s Law</span></a></li><li><a class="tocitem" href="#Animation-of-Inverse-Billiards"><span>Animation of Inverse Billiards</span></a></li></ul></li><li><a class="tocitem" href="../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../mushroomtools/">MushroomTools</a></li><li><a class="tocitem" href="../physics/">Physics</a></li><li><a class="tocitem" href="../basic/low_level/">Internals</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/billiard_table/">Defining a Billiard</a></li><li><a class="tocitem" href="../tutorials/own_obstacle/">Defining your own Obstacles</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Ray-Splitting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ray-Splitting</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/master/docs/src/ray-splitting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Ray-Splitting"><a class="docs-heading-anchor" href="#Ray-Splitting">Ray-Splitting</a><a id="Ray-Splitting-1"></a><a class="docs-heading-anchor-permalink" href="#Ray-Splitting" title="Permalink"></a></h1><p>Ray-splitting is a semi-classical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission &amp; refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three simple steps. We will introduce them and demonstrate them using a simple example in this documentation page.</p><h2 id="1.-Ray-Splitting-Obstacles"><a class="docs-heading-anchor" href="#1.-Ray-Splitting-Obstacles">1. Ray-Splitting Obstacles</a><a id="1.-Ray-Splitting-Obstacles-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Ray-Splitting-Obstacles" title="Permalink"></a></h2><p>The first step is that an <a href="../tutorials/billiard_table/#DynamicalBilliards.Obstacle"><code>Obstacle</code></a> that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called <code>pflag</code> (propagation flag). This field notes on which side of the obstacle the particle is currently propagating.</p><p>The normal vector as well as the distance from boundary change sign depending on the value of <code>pflag</code>. The obstacles <a href="../tutorials/billiard_table/#DynamicalBilliards.Antidot"><code>Antidot</code></a>, <a href="../tutorials/billiard_table/#DynamicalBilliards.SplitterWall"><code>SplitterWall</code></a> and <a href="../tutorials/billiard_table/#DynamicalBilliards.FiniteSplitterWall"><code>FiniteSplitterWall</code></a> are the equivalents of disk, wall and finite-wall for ray-splitting.</p><p>Let&#39;s create a billiard with a bunch of ray-splitting obstacles!</p><pre><code class="language-julia hljs">using DynamicalBilliards
x, y = 2.0, 1.0
bdr =  billiard_rectangle(x, y)
sw = SplitterWall([x/2, 0.0], [x/2,y], [-1,0], true)
a1 = Antidot([x/4, y/2], 0.25, &quot;Left Antidot&quot;)
a2 = Antidot([3x/4, y/2], 0.15, &quot;Right Antidot&quot;)
bd = Billiard(a1, a2, sw, bdr...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Billiard{Float64} with 7 obstacles:
  Left Antidot
  Right Antidot
  Splitter wall
  Bottom wall
  Right wall
  Top wall
  Left wall</code></pre><pre><code class="language-julia hljs">using CairoMakie
fig, ax = bdplot(bd)
fig</code></pre><img src="3402ce70.png" alt="Example block output"/><p>(notice also that raysplitting obstacles are by default plotted with a different color and with dotted linestyle)</p><h2 id="2.-The-RaySplitter-structure"><a class="docs-heading-anchor" href="#2.-The-RaySplitter-structure">2. The <code>RaySplitter</code> structure</a><a id="2.-The-RaySplitter-structure-1"></a><a class="docs-heading-anchor-permalink" href="#2.-The-RaySplitter-structure" title="Permalink"></a></h2><p>In the second step, you have to define 2+1 functions: transmission probability, refraction angle and optionally new angular velocity after transmission. These functions, as well as which obstacles participate in ray-splitting, are bundled into a special structure:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.RaySplitter" href="#DynamicalBilliards.RaySplitter"><code>DynamicalBilliards.RaySplitter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RaySplitter(idxs, transmission, refraction [, newangular]; affect)</code></pre><p>Return a <code>RaySplitter</code> instance, used to perform raysplitting. <code>idxs</code> is a <code>Vector{Int}</code> with the indices of the obstacles that this <code>RaySplitter</code> corresponds to.</p><p><code>transmission</code>, <code>refraction</code> and <code>newangular</code> are <strong>functions</strong>. Let <code>φ</code> be the angle of incidence and <code>ω</code> be the angular velocity and <code>pflag</code> the propagation flag (before transmission). The functions have the following signatures:</p><ol><li><code>transmission(φ, pflag, ω) -&gt; T</code>, transmission probability.</li><li><code>refraction(φ, pflag, ω) -&gt; θ</code>, refraction angle. This angle is <em>relative</em> to the normal vector.</li><li><code>newangular(ω, pflag) -&gt; newω</code>, new angular velocity after transmission.</li></ol><p>The above three functions use the <strong>same convention</strong>: the argument <code>pflag</code> is the one the obstacle has <strong>before transmission</strong>. For example, if a particle is outside an <a href="../tutorials/billiard_table/#DynamicalBilliards.Antidot"><code>Antidot</code></a> (with <code>pflag = true</code> here) and is transmitted inside the <code>Antidot</code> (<code>pflag</code> becomes <code>false</code> here), then all three functions will be given their second argument (the Boolean one) as <code>true</code>!</p><p><code>affect</code> is a function, and denotes which obstacles of the billiard are affected when transmission occurs at obstacle <code>i</code> (for which obstacles should the field <code>pflag</code> be reversed). Defaults to <code>idxs = (i) -&gt; i</code>, i.e. only the colliding obstacle is affected. If you want many obstacles to be affected you could write <code>idxs = (i) -&gt; SVector(2,3,5)</code>, etc. Keep in mind that the only values of <code>i</code> that can be passed into this function are the ones that are given in the argument <code>idxs</code>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/raysplitting.jl#L8-L38">source</a></section></article><p>If you want different type of transmission/refraction functions for different obstacles, then you define multiple <code>RaySplitter</code>s.</p><p>Continuing from the above billiard, let&#39;s also create some <code>RaySplitter</code> instances for it.</p><p>First define a refraction function</p><pre><code class="language-julia hljs">refraction(φ, pflag, ω) = pflag ? 0.5φ : 2.0φ</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">refraction (generic function with 1 method)</code></pre><p>Then, a transmission probability function. In this example, we want to create a function that given some factor <code>p</code>, it returns a probability weighted with <code>p</code> in one direction of ray-splitting and <code>1-p</code> in another direction.</p><pre><code class="language-julia hljs">transmission_p(p) = (φ, pflag, ω) -&gt; begin
    if pflag
        p*exp(-(φ)^2/2(π/8)^2)
    else
        abs(φ) &lt; π/4 ? (1-p)*exp(-(φ)^2/2(π/4)^2) : 0.0
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">transmission_p (generic function with 1 method)</code></pre><p>Notice also how we defined the function in such a way that critical refraction is respected, i.e. if <code>θ(φ) ≥ π/2</code> then <code>T(φ) = 0</code>. Although this is necessary from a physical perspective, the code does take care of it by clamping the refraction angle (see below).</p><p>Lastly, for this example we will use magnetic propagation. We define functions such that the antidots also reverse the direction and magnitude of the magnetic field.</p><pre><code class="language-julia hljs">newoantidot(x, bool) =  bool ? -2.0x : -0.5x
newowall(x, bool) = bool ? 0.5x : 2.0x</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">newowall (generic function with 1 method)</code></pre><p>Now we create the <a href="#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances we want</p><pre><code class="language-julia hljs">raywall = RaySplitter([3], transmission_p(0.5), refraction, newowall)
raya = RaySplitter([1, 2], transmission_p(0.8), refraction, newoantidot)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RaySplitter for indices [1, 2]
 transmission: #1
 refraction:   refraction
 new angular:  newoantidot
 affect:       default
</code></pre><p>Because we want to use same functions for both antidots, we gave both indices in <code>raya</code>, <code>[1, 2]</code> (which are the indices of the antidots in the billiard <code>bd</code>).</p><h2 id="3.-Evolution-with-Ray-Splitting"><a class="docs-heading-anchor" href="#3.-Evolution-with-Ray-Splitting">3. Evolution with Ray-Splitting</a><a id="3.-Evolution-with-Ray-Splitting-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Evolution-with-Ray-Splitting" title="Permalink"></a></h2><p>The third step is trivial. After you have created your <code>RaySplitter</code>(s), you simply pass them into <code>evolve</code> or <code>timeseries</code> as a fourth argument! If you have many instances of <code>RaySplitter</code> you pass a tuple of them.</p><p>For example,</p><pre><code class="language-julia hljs">using Random, CairoMakie
timeseries = DynamicalBilliards.timeseries
Random.seed!(42)
p = randominside(bd, 1.0)
raysplitters = (raywall, raya)
xt, yt, vxt, vyt, tt = timeseries(p, bd, 100, raysplitters)
fig, ax = bdplot(bd)
lines!(ax, xt, yt)
scatter!(ax, xt[[1, 100]], yt[[1, 100]]; color = &quot;black&quot;)
fig</code></pre><img src="ad556741.png" alt="Example block output"/><p>You can see that at some points the particle crossed the boundaries of the red obstacles, which allow for ray splitting.</p><div class="admonition is-info"><header class="admonition-header">Resetting the billiard</header><div class="admonition-body"><p>Notice that evolving a particle inside a billiard always mutates the billiard if ray-splitting is used. This means that you should always set the fields <code>pflag</code> of some obstacles to the values you desire after <em>each</em> call to <code>evolve</code>. If you use the function <a href="../basic/high_level/#DynamicalBilliards.randominside"><code>randominside</code></a> you must definitely do this!</p><p>The function <code>reset_billiard!(bd)</code> turns all <code>pflag</code>s to <code>true</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Angle of refraction is clamped</header><div class="admonition-body"><p>Internally we clamp the output of the angle of refraction function. Let <code>c = DynamicalBilliards.CLAMPING_ANGLE</code> (currently <code>c = 0.1</code>). We clamp <code>θ</code> to <code>-π/2 + c ≤ θ ≤ π/2 - c</code>. This is so that the relocating algorithm does not fall into an infinite loop. You can change the value of <code>c</code> but very small values can lead to infinite loops in extreme cases.</p></div></div><h2 id="The-Ray-Splitting-Algorithm"><a class="docs-heading-anchor" href="#The-Ray-Splitting-Algorithm">The Ray-Splitting Algorithm</a><a id="The-Ray-Splitting-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Ray-Splitting-Algorithm" title="Permalink"></a></h2><p>In this section we describe the algorithm we follow to implement the ray-splitting process. Let <span>$T$</span> denote the transmission function, <span>$\theta$</span> the refraction function and <span>$\omega_{\text{new}}$</span> the new angular velocity function. The following describes the process after a particle has reached an obstacle that supports ray-splitting.</p><ol><li><p>Find the angle of incidence <span>$\phi&#39; = \pi - \arccos(\vec{v} \cdot \vec{n}) = \arccos(\vec{v} \cdot (-\vec{n}))$</span> with <span>$\vec{n}$</span> the normal vector at collision point. Notice that we use here <span>$-\vec{n}$</span> because the velocity is opposing the normal vector before the collision happens. Using <span>$-\vec{n}$</span> gives the angle between 0 and <span>$\pi/2$</span> instead of <span>$\pi/2$</span> to <span>$\pi$</span>.</p></li><li><p>Find the <em>correct</em> sign of the incidence angle, <span>$\phi = \pm \phi&#39;$</span>. Specifically, use the cross product: if the third entry of <span>$\vec{v} \times \vec{n}$</span> is negative, then have minus sign. The &quot;correct&quot; sign debates on whether the velocity vector is to the right or to the left of <span>$(-\vec{n})$</span>. This is important for finding the correct transmission angle and/or probability.</p></li><li><p>Check if <span>$T(\phi, \verb|pflag|, \omega) &gt; \text{random}()$</span>. If not, do standard specular reflection.</p></li><li><p>If ray-splitting happens, then relocate the particle so that it is on the <em>other</em> side of the colliding obstacle. This contrasts the main evolution algorithm of this billiard package.</p></li><li><p>Re-compute the <em>correct</em> angle of incidence, as the position of the particle generally changes with relocating.</p></li><li><p>Find refraction angle <span>$\theta(\phi, \verb|pflag|, \omega)$</span>. Notice that this is a relative angle with respect to the normal vector. Also notice that <span>$\theta$</span> may have opposite sign from <span>$\phi$</span>. It depends on the user if they want to add anomalous refraction.</p></li><li><p>Set <code>obstacle.pflag = !obstacle.pflag</code> for <em>all</em> obstacles affected by the current <code>RaySplitter</code>. This reverses <span>$\vec{n}$</span> to <span>$-\vec{n}$</span> as well! So from now on <span>$\vec{n}$</span> is the opposite than what it was at the beginning of the algorithm!</p></li><li><p>Find the refraction angle in absolute space. First find <span>$a = \text{atan}(n_y, n_x)$</span> and then set <span>$\Theta = a + \theta$</span>.</p></li><li><p>Perform refraction, i.e. set the particle velocity to the direction of <span>$\Theta$</span>.</p></li><li><p>Scale the magnetic field, i.e. set <code>p.omega</code> = <span>$\omega_{\text{new}}(\omega, \verb|!pflag|)$</span>. It is important to note that we use <code>!pflag</code> because we have already changed the <code>pflag</code> field.</p></li></ol><h2 id="Physics-of-the-Ray-Splitting-Functions"><a class="docs-heading-anchor" href="#Physics-of-the-Ray-Splitting-Functions">Physics of the Ray-Splitting Functions</a><a id="Physics-of-the-Ray-Splitting-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-of-the-Ray-Splitting-Functions" title="Permalink"></a></h2><p>If <code>T</code> is the transmission probability function, then the condition for transmission is simply: <code>T(φ, pflag, ω) &gt; rand()</code>. If it returns <code>true</code>, transmission (i.e. ray-splitting) will happen.</p><p>The functions given to <a href="#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> should have some properties in order to have physical meaning. In order to test if the <code>RaySplitter</code> you have defined has physical meaning, the function <code>isphysical</code> is provided</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.isphysical" href="#DynamicalBilliards.isphysical"><code>DynamicalBilliards.isphysical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isphysical(raysplitter(s))</code></pre><p>Return <code>true</code> if the given <code>raysplitters</code> have physically plausible properties.</p><p>Specifically, check if (φ is the incidence angle, θ the refraction angle):</p><ul><li>Critical angle means total reflection: If θ(φ) ≥ π/2 then Tr(φ) = 0</li><li>Transmission probability is even function: Tr(φ) ≈ Tr(-φ) at ω = 0</li><li>Refraction angle is odd function: θ(φ) ≈ -θ(-φ) at ω = 0</li><li>Ray reversal is true: θ(θ(φ, pflag, ω), !pflag, ω) ≈ φ</li><li>Magnetic conservation is true: (ω<em>new(ω</em>new(ω, pflag), !pflag) ≈ ω</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/raysplitting.jl#L327-L339">source</a></section></article><h2 id="Snell&#39;s-Law"><a class="docs-heading-anchor" href="#Snell&#39;s-Law">Snell&#39;s Law</a><a id="Snell&#39;s-Law-1"></a><a class="docs-heading-anchor-permalink" href="#Snell&#39;s-Law" title="Permalink"></a></h2><p>In classical geometric optics, the refraction of a ray of light moving from one medium to another is described by Snell&#39;s law. For an angle of incidence of <span>$\phi$</span>, the refraction angle <span>$\theta$</span> is determined by the equation</p><p class="math-container">\[\frac{sin(\phi)}{\sin(\theta)} = \frac{n&#39;}{n}\]</p><p>where <span>$n$</span> and <span>$n&#39;$</span> are the respective refractive indices of the media.</p><p>To easily simulate these relations in <code>DynamicalBilliards</code>, the function <code>law_of_refraction</code> can be used to set up ray-splitting according to this law.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.law_of_refraction" href="#DynamicalBilliards.law_of_refraction"><code>DynamicalBilliards.law_of_refraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">law_of_refraction(n1, n2 = 1.0) -&gt; t, r</code></pre><p>Create transmission and refraction functions <code>t, r</code> that follow Snell&#39;s law, i.e. the transmission probability is set to 1.0 except for the case of total internal reflection. </p><p><code>n1</code> is the index of refraction for the <code>pflag = false</code> side of an obstacle, while <code>n2</code> is the index of refraction for <code>pflag = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/raysplitting.jl#L400-L409">source</a></section></article><h2 id="Animation-of-Inverse-Billiards"><a class="docs-heading-anchor" href="#Animation-of-Inverse-Billiards">Animation of Inverse Billiards</a><a id="Animation-of-Inverse-Billiards-1"></a><a class="docs-heading-anchor-permalink" href="#Animation-of-Inverse-Billiards" title="Permalink"></a></h2><p>Here we will show an application of <em>inverse</em> billiards, where particles go in and out of a billiard, while taking advantage of the existence of a strong magnetic field outside of the billiard to return.</p><p>As always, we define the ray-splitting functions:</p><pre><code class="language-julia hljs">using DynamicalBilliards
trans(args...) = 1.0 # always perfect transmission
refra(φ, pflag, ω) = pflag ? 0.8φ : 1.25φ # refraction angle
neww(ω, pflag) = pflag ? 2.0 : 0.4</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">neww (generic function with 1 method)</code></pre><p>Now, when we define the <a href="#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instance we will choose a different value for <code>affect</code>:</p><pre><code class="language-julia hljs">ray = RaySplitter([1,2,3,4], trans, refra, neww, affect = (i) -&gt; SVector(1,2,3,4))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RaySplitter for indices [1, 2, 3, 4]
 transmission: trans
 refraction:   refra
 new angular:  neww
 affect:       #3
</code></pre><p>We initialize a simple rectangular billiard and a particle</p><pre><code class="language-julia hljs">bd = billiard_rectangle(setting = &quot;ray-splitting&quot;)
p = MagneticParticle(0.4, 0.6, 0.0, 0.4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MagneticParticle{Float64}
position: [0.4, 0.6]
velocity: [1.0, 0.0]
ang. velocity: 0.4</code></pre><p><a href="../billiards_visualizations/#DynamicalBilliards.bdplot_interactive"><code>bdplot_interactive</code></a> does not accept ray-splitters yet (but it is easy if you want to do a PR). Nevertheless, doing an animation is still straightforward:</p><pre><code class="language-julia hljs">using CairoMakie
timeseries = DynamicalBilliards.timeseries
fig, ax = bdplot(bd)
xlims!(ax, (-1, 2)); ylims!(ax, (-1, 2)) # zoom out
xt, yt = timeseries(p, bd, 10.0, (ray,))
D = 300
xta = Observable(xt[1:D])
yta = Observable(yt[1:D])
lines!(ax, xta, yta; color = :green)

record(fig, &quot;inverse_billiard.mp4&quot;, D+1:length(xt); framerate = 30) do i
    push!(xta[], xt[i]); popfirst!(xta[])
    push!(yta[], yt[i]); popfirst!(yta[])
    notify.((xta, yta))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;inverse_billiard.mp4&quot;</code></pre><video width="auto" controls autoplay loop>
<source src="../inverse_billiard.mp4" type="video/mp4">
</video></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basic/phasespaces/">« Phase Spaces</a><a class="docs-footer-nextpage" href="../lyapunovs/">Lyapunov Exponents »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 21 June 2024 09:39">Friday 21 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
