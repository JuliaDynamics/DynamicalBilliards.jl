<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>High Level API · DynamicalBilliards.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalBilliards.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalBilliards.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li class="is-active"><a class="tocitem" href>High Level API</a><ul class="internal"><li><a class="tocitem" href="#Billiard"><span>Billiard</span></a></li><li><a class="tocitem" href="#Particles"><span>Particles</span></a></li><li><a class="tocitem" href="#Random-initial-conditions"><span>Random initial conditions</span></a></li><li><a class="tocitem" href="#evolve-and-timeseries"><span><code>evolve</code> &amp; <code>timeseries</code></span></a></li><li><a class="tocitem" href="#Poincaré-Sections"><span>Poincaré Sections</span></a></li><li><a class="tocitem" href="#Escape-Times"><span>Escape Times</span></a></li><li><a class="tocitem" href="#Mean-Collision-Times"><span>Mean Collision Times</span></a></li><li><a class="tocitem" href="#Parallelization"><span>Parallelization</span></a></li><li><a class="tocitem" href="#It&#39;s-all-about-bounce!"><span>It&#39;s all about bounce!</span></a></li><li><a class="tocitem" href="#Standard-Billiards-Library"><span>Standard Billiards Library</span></a></li><li><a class="tocitem" href="#Particle-types"><span>Particle types</span></a></li></ul></li><li><a class="tocitem" href="../../visualizing/">Visualizing &amp; Animating</a></li><li><a class="tocitem" href="../phasespaces/">Phase Spaces</a></li><li><a class="tocitem" href="../../ray-splitting/">Ray-Splitting</a></li><li><a class="tocitem" href="../../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../mushroomtools/">MushroomTools</a></li><li><a class="tocitem" href="../../physics/">Physics</a></li><li><a class="tocitem" href="../low_level/">Internals</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/billiard_table/">Defining a Billiard</a></li><li><a class="tocitem" href="../../tutorials/own_obstacle/">Defining your own Obstacles</a></li><li><a class="tocitem" href="../../tutorials/examples/">Examples</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>High Level API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>High Level API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/master/docs/src/basic/high_level.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="High-Level-API"><a class="docs-heading-anchor" href="#High-Level-API">High Level API</a><a id="High-Level-API-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-API" title="Permalink"></a></h1><p><code>DynamicalBilliards</code> was created with ease-of-use as its main cornerstone. With 3 simple steps, the user can get the output of the propagation of a particle in a billiard.</p><p>In general, the workflow of <code>DynamicalBilliards</code> follows these simple steps:</p><ol><li>Create a billiard.</li><li>Create particles inside that billiard.</li><li>Get the output you want by using one of the high level functions.</li></ol><p>Adding more complexity in your billiard does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> and pass it to the high level functions.</p><p>After reading through this page, you will be able to use almost all aspects of <code>DynamicalBilliards</code> with minimal effort.</p><div class="admonition is-success"><header class="admonition-header">Visualizations</header><div class="admonition-body"><p>Visualizing the billiards, particles, and their motion is one of the most important parts of the <code>DynamicalBilliards</code>. It is not discussed in this page however, but rather in the <a href="../../visualizing/#Visualizing-and-Animating">Visualizing &amp; Animating</a> page.</p></div></div><h2 id="Billiard"><a class="docs-heading-anchor" href="#Billiard">Billiard</a><a id="Billiard-1"></a><a class="docs-heading-anchor-permalink" href="#Billiard" title="Permalink"></a></h2><p>A <a href="../../tutorials/billiard_table/#DynamicalBilliards.Billiard"><code>Billiard</code></a> is simply a collection of <a href="../../tutorials/billiard_table/#DynamicalBilliards.Obstacle"><code>Obstacle</code></a> subtypes. Particles are propagating inside a <code>Billiard</code>, bouncing from obstacle to obstacle while having constant velocity in-between.</p><p>There is a tutorial on how to create your own billiard. In addition, there are many pre-defined billiards that can be found in the <a href="#Standard-Billiards-Library">Standard Billiards Library</a> section. That is why knowing how to construct a <a href="../../tutorials/billiard_table/#DynamicalBilliards.Billiard"><code>Billiard</code></a> is not important at this point.</p><p>In this page we will be using the Bunimovich billiard as an example:</p><pre><code class="language-julia">using DynamicalBilliards
bd = billiard_bunimovich()</code></pre><pre class="documenter-example-output">Billiard{Float64} with 4 obstacles:
  Bottom wall
  Right semicircle
  Top wall
  Left semicircle</pre><h2 id="Particles"><a class="docs-heading-anchor" href="#Particles">Particles</a><a id="Particles-1"></a><a class="docs-heading-anchor-permalink" href="#Particles" title="Permalink"></a></h2><p>A &quot;particle&quot; is that thingy that moves around in the billiard. It always moves with velocity of measure 1, by convention.</p><p>Currently there are two types of particles:</p><ul><li><a href="#DynamicalBilliards.Particle"><code>Particle</code></a>, which propagates as a straight line.</li><li><a href="#DynamicalBilliards.MagneticParticle"><code>MagneticParticle</code></a>, which propagates as a circle instead of a line (similar to electrons in a perpendicular magnetic field).</li></ul><p>To make a particle, provide the constructor with some initial conditions:</p><pre><code class="language-julia">x0 = rand(); y0 = rand();
φ0 = 2π*rand()
p = Particle(x0, y0, φ0)</code></pre><pre class="documenter-example-output">Particle{Float64}
position: [0.03107774051413803, 0.4411394787406657]
velocity: [0.7646759614439227, 0.644414985851363]</pre><p>To create a <code>MagneticParticle</code> simply provide the constructor with one more number, the angular velocity:</p><pre><code class="language-julia">ω = 0.5
mp = MagneticParticle(x0, y0, φ0, ω)</code></pre><pre class="documenter-example-output">MagneticParticle{Float64}
position: [0.03107774051413803, 0.4411394787406657]
velocity: [0.7646759614439227, 0.644414985851363]
ang. velocity: 0.5</pre><p>When creating a billiard or a particle, the object is printed with <code>{Float64}</code> at the end. This shows what type of numbers are used for <em>all</em> numerical operations. If you are curious you can learn more about it in the <a href="../low_level/#Numerical-Precision">Numerical Precision</a>.</p><p>You can initialize several particles with the same direction but slightly different position is the following function:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.particlebeam" href="#DynamicalBilliards.particlebeam"><code>DynamicalBilliards.particlebeam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">particlebeam(x0, y0, φ, N, dx, ω = nothing, T = eltype(x0)) → ps</code></pre><p>Make <code>N</code> particles, all with direction <code>φ</code>, starting at <code>x0, y0</code>. The particles don&#39;t all have the same position, but are instead spread by up to <code>dx</code> in the direction normal to <code>φ</code>.</p><p>The particle element type is <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/particles.jl#L143-L150">source</a></section></article><div class="admonition is-danger"><header class="admonition-header">Particles must be inside the Billiard!</header><div class="admonition-body"><p>Keep in mind that the particle must be initialized <strong>inside a billiard</strong> for any functionality to work properly and make sense. If you are not sure what we mean by that, then you should check out the <a href="../low_level/#Internals">Internals</a> page.</p></div></div><h2 id="Random-initial-conditions"><a class="docs-heading-anchor" href="#Random-initial-conditions">Random initial conditions</a><a id="Random-initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Random-initial-conditions" title="Permalink"></a></h2><p>If you have a <code>Billiard</code> which is not a rectangle, creating many random initial conditions inside it can be a pain. Fortunately, we have the following function:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.randominside" href="#DynamicalBilliards.randominside"><code>DynamicalBilliards.randominside</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randominside(bd::Billiard [, ω]) → p</code></pre><p>Return a particle <code>p</code> with random allowed initial conditions inside the given billiard. If supplied with a second argument the type of the returned particle is <code>MagneticParticle</code>, with angular velocity <code>ω</code>.</p><p><strong>WARNING</strong> : <code>randominside</code> works for any <strong>convex</strong> billiard but it does not work for non-convex billiards. (this is because it uses <code>distance</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/billiardtable.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.randominside_xyφ" href="#DynamicalBilliards.randominside_xyφ"><code>DynamicalBilliards.randominside_xyφ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randominside_xyφ(bd::Billiard) → x, y, φ</code></pre><p>Same as <a href="#DynamicalBilliards.randominside"><code>randominside</code></a> but only returns position and direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/billiardtable.jl#L137-L140">source</a></section></article><hr/><p>For example:</p><pre><code class="language-julia">p = randominside(bd)</code></pre><pre class="documenter-example-output">Particle{Float64}
position: [0.32216792036107744, 0.2764349700109774]
velocity: [-0.656395137388974, -0.7544172742004984]</pre><p>and</p><pre><code class="language-julia">mp = randominside(bd, ω)</code></pre><pre class="documenter-example-output">MagneticParticle{Float64}
position: [0.6648875048740659, 0.6201117661684414]
velocity: [-0.04989793319005876, -0.9987543222751833]
ang. velocity: 0.5</pre><p><code>randominside</code> always creates particles with same number type as the billiard.</p><h2 id="evolve-and-timeseries"><a class="docs-heading-anchor" href="#evolve-and-timeseries"><code>evolve</code> &amp; <code>timeseries</code></a><a id="evolve-and-timeseries-1"></a><a class="docs-heading-anchor-permalink" href="#evolve-and-timeseries" title="Permalink"></a></h2><p>Now that we have created a billiard and a particle inside, we want to evolve it! There is a simple function for that, called <code>evolve!</code> (or <code>evolve</code> if you don&#39;t want to mutate the particle), which returns the time, position and velocities at the collision points:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.evolve!" href="#DynamicalBilliards.evolve!"><code>DynamicalBilliards.evolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evolve!([p::AbstractParticle,] bd::Billiard, t)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code>. If <code>t</code> is of type <code>AbstractFloat</code>, evolve for as much time as <code>t</code>. If however <code>t</code> is of type <code>Int</code>, evolve for as many collisions as <code>t</code>. Return the states of the particle between collisions.</p><p>This function mutates the particle, use <code>evolve</code> otherwise. If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</p><p><strong>Return</strong></p><ul><li><code>ct::Vector{T}</code> : Collision times.</li><li><code>poss::Vector{SVector{2,T}}</code> : Positions at the collisions.</li><li><code>vels::Vector{SVector{2,T}})</code> : Velocities exactly after the collisions.</li><li><code>ω</code>, either <code>T</code> or <code>Vector{T}</code> : Angular velocity/ies (returned only for magnetic particles).</li></ul><p>The time <code>ct[i+1]</code> is the time necessary to reach state <code>poss[i+1], vels[i+1]</code> starting from the state <code>poss[i], vels[i]</code>. That is why <code>ct[1]</code> is always 0 since <code>poss[1], vels[1]</code> are the initial conditions. The angular velocity <code>ω[i]</code> is the one the particle has while propagating from state <code>poss[i], vels[i]</code> to <code>i+1</code>.</p><p>Notice that at any point, the velocity vector <code>vels[i]</code> is the one obdained <em>after</em> the specular reflection of the <code>i-1</code>th collision.</p><p><strong>Ray-splitting billiards</strong></p><pre><code class="language-none">evolve!(p, bd, t, raysplitters)</code></pre><p>To implement ray-splitting, the <code>evolve!</code> function is supplemented with a fourth argument, <code>raysplitters</code> which is a tuple of <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Notice that <code>evolve</code> <strong>always mutates the billiard</strong> if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/timeevolution/timeseries.jl#L5-L39">source</a></section></article><hr/><p>Forget the ray-splitting part for now (see <a href="../../ray-splitting/#Ray-Splitting">Ray-Splitting</a>).</p><p>Let&#39;s see an example:</p><pre><code class="language-julia">ct, poss, vels = evolve(p, bd, 100)
for i in 1:5
  println(round(ct[i], digits=3), &quot;  &quot;, poss[i], &quot;  &quot;, vels[i])
end</code></pre><pre class="documenter-example-output">0.0  [0.32216792036107744, 0.2764349700109774]  [-0.656395137388974, -0.7544172742004984]
0.366  [0.0816504026361996, 0.0]  [-0.656395137388974, 0.7544172742004984]
0.854  [-0.478778941862668, 0.644120521886593]  [0.9637743424599992, 0.26671898473074046]
1.334  [0.8071719264642006, 1.0]  [0.9637743424599992, -0.26671898473074046]
0.574  [1.3599724047346458, 0.8470156593434313]  [0.23122616956322073, -0.972900024930168]</pre><p>Similarly, for magnetic propagation</p><pre><code class="language-julia">ct, poss, vels, ω = evolve(mp, bd, 100)
for i in 1:10
  println(round(ct[i], digits=3), &quot;  &quot;, poss[i], &quot;  &quot;, vels[i])
end</code></pre><pre class="documenter-example-output">0.0  [0.6648875048740659, 0.6201117661684414]  [-0.049897933190058745, -0.9987543222751831]
0.626  [0.7312640036541158, 0.0]  [0.26015794989416186, 0.9655660728851583]
1.011  [0.7417557050808081, 1.0]  [-0.23984205010583823, -0.9708119235985045]
1.011  [0.7522474065075007, 0.0]  [0.2601579498941617, 0.9655660728851583]
1.011  [0.7627391079341932, 1.0]  [-0.23984205010583842, -0.9708119235985044]
1.011  [0.7732308093608857, 0.0]  [0.26015794989416147, 0.9655660728851584]
1.011  [0.783722510787578, 1.0]  [-0.23984205010583864, -0.9708119235985044]
1.011  [0.7942142122142701, 0.0]  [0.26015794989416147, 0.9655660728851584]
1.011  [0.8047059136409622, 1.0]  [-0.23984205010583864, -0.9708119235985044]
1.011  [0.8151976150676543, 0.0]  [0.26015794989416147, 0.9655660728851584]</pre><p>The above return types are helpful in some applications. In other applications however one prefers to have the time series of the individual variables. For this, the <code>timeseries</code> function is used:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.timeseries!" href="#DynamicalBilliards.timeseries!"><code>DynamicalBilliards.timeseries!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timeseries!([p::AbstractParticle,] bd::Billiard, t; dt, warning)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code> for the condition <code>t</code> and return the x, y, vx, vy timeseries and the time vector. If <code>t</code> is of type <code>AbstractFloat</code>, then evolve for as much time as <code>t</code>. If however <code>t</code> is of type <code>Int</code>, evolve for as many collisions as <code>t</code>. Otherwise, <code>t</code> can be any function, that takes as an input <code>t(n, τ, i, p)</code> and returns <code>true</code> when the evolution should terminate. Here <code>n</code> is the amount of obstacles collided with so far, <code>τ</code> the amount time evolved so far, <code>i</code> the obstacle just collided with and <code>p</code> the particle (so you can access e.g. <code>p.pos</code>).</p><p>This function mutates the particle, use <code>timeseries</code> otherwise. If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</p><p>The keyword argument <code>dt</code> is the time step used for interpolating the time series in between collisions. <code>dt</code> is capped by the collision time, as the interpolation <em>always</em> stops at collisions. For straight propagation <code>dt = Inf</code>, while for magnetic <code>dt = 0.01</code>.</p><p>For pinned magnetic particles, <code>timeseries!</code> issues a warning and returns the trajectory of the particle. If <code>t</code> is integer, the trajectory is evolved for one full circle only.</p><p>Internally uses <a href="../low_level/#DynamicalBilliards.extrapolate"><code>DynamicalBilliards.extrapolate</code></a>.</p><p><strong>Ray-splitting billiards</strong></p><pre><code class="language-none">timeseries!(p, bd, t, raysplitters; ...)</code></pre><p>To implement ray-splitting, the <code>timeseries!</code> function is supplemented with a fourth argument, <code>raysplitters</code> which is a tuple of <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Notice that <code>timeseries</code> <strong>always mutates the billiard</strong> if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/timeevolution/timeseries.jl#L107-L141">source</a></section></article><hr/><p>For example:</p><pre><code class="language-julia">xt, yt, vxt, vyt, t = timeseries(p, bd, 100)

# print as a matrix:
hcat(xt, yt, vxt, vyt, t)[1:5, :]</code></pre><pre class="documenter-example-output">5×5 Array{Float64,2}:
  0.322168   0.276435  -0.656395  -0.754417  0.0
  0.0816504  0.0       -0.656395   0.754417  0.366422
 -0.478779   0.644121   0.963774   0.266719  1.22022
  0.807172   1.0        0.963774  -0.266719  2.55451
  1.35997    0.847016   0.231226  -0.9729    3.12809</pre><p>Same story for magnetic particles:</p><pre><code class="language-julia"># evolve the magnetic particle instead:
xt, yt, vxt, vyt, t = timeseries(mp, bd, 100)

# print as a matrix:
hcat(xt, yt, vxt, vyt, t)[1:5, :]</code></pre><pre class="documenter-example-output">5×5 Array{Float64,2}:
 0.664888  0.620112  -0.0498979  -0.998754  0.0
 0.664413  0.610123  -0.0449036  -0.998991  0.01
 0.663989  0.600132  -0.0399081  -0.999203  0.02
 0.663615  0.590139  -0.0349116  -0.99939   0.03
 0.663291  0.580144  -0.0299142  -0.999552  0.04</pre><p>Sometimes we may need information about which obstacles a particle visited, in which sequence, and when. For this we have the following function:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.visited_obstacles!" href="#DynamicalBilliards.visited_obstacles!"><code>DynamicalBilliards.visited_obstacles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visited_obstacles!([p::AbstractParticle,] bd::Billiard, t)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code> exactly like <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a>. However return only:</p><ul><li><code>ts::Vector{T}</code> : Vector of time points of when each collision occured.</li><li><code>obst::Vector{Int}</code> : Vector of obstacle indices in <code>bd</code> that the particle collided with at the time points in <code>ts</code>.</li></ul><p>The first entries are <code>0.0</code> and <code>0</code>. Similarly with <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a> the function does not record collisions with periodic walls.</p><p>Currently does not support raysplitting. Returns empty arrays for pinned particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/timeevolution/highleveltimes.jl#L122-L137">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Type of `t`</header><div class="admonition-body"><p>Remember that the behavior of time evolution depends on the type of the <code>t</code> argument, which represents &quot;total amount&quot;. If it is <code>AbstractFloat</code>, it represents total amount of time, but if it is <code>Int</code> it represents total number of collisions.</p></div></div><h2 id="Poincaré-Sections"><a class="docs-heading-anchor" href="#Poincaré-Sections">Poincaré Sections</a><a id="Poincaré-Sections-1"></a><a class="docs-heading-anchor-permalink" href="#Poincaré-Sections" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.psos" href="#DynamicalBilliards.psos"><code>DynamicalBilliards.psos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">psos(bd::Billiard, plane::InfiniteWall, t, particles)</code></pre><p>Compute the Poincaré section of the <code>particles</code> with the given <code>plane</code>, by evolving each one for time <code>t</code> (either integer or float) inside <code>bd</code>.</p><p>The <code>plane</code> can be an <a href="../../tutorials/billiard_table/#DynamicalBilliards.InfiniteWall"><code>InfiniteWall</code></a> of <em>any</em> orientation, however only crossings of the <code>plane</code> such that <code>dot(velocity, normal) &lt; 0</code> are allowed, with <code>normal</code> the normal unit vector of the <code>plane</code>.</p><p><code>particles</code> can be:</p><ul><li>A single particle.</li><li>A <code>Vector</code> of particles.</li><li>An integer <code>n</code> optionally followed by an angular velocity <code>ω</code>.</li></ul><p>Return the positions <code>poss</code> and velocities <code>vels</code> at the instances of crossing the <code>plane</code>. If given more than one particle, the result is a vector of vectors of vectors.</p><p><em>Notice</em> - This function can handle pinned particles. If a pinned particle can intersect with the <code>plane</code>, then an intersection is returned. If however it can&#39;t then empty vectors are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/poincare.jl#L3-L24">source</a></section></article><hr/><p>For example, the surface of section in the periodic Sinai billiard with magnetic field reveals the mixed nature of the phase-space:</p><pre><code class="language-julia">using DynamicalBilliards, PyPlot
t = 100; r = 0.15
bd = billiard_sinai(r, setting = &quot;periodic&quot;)

# the direction of the normal vector is IMPORTANT!!!
# (always keep in mind that ω &gt; 0  means counter-clockwise rotation!)
plane = InfiniteWall([0.5, 0.0], [0.5, 1.0], [-1.0, 0.0])

posvector, velvector = psos(bd, plane, t, 1000, 2.0)
c(a) = length(a) == 1 ? &quot;C1&quot; : &quot;C0&quot;

figure()
for i in 1:length(posvector)
    poss = posvector[i] # vector of positions
    vels = velvector[i] # vector of velocities at the section
    L = length(poss)
    if L &gt; 0
        #plot y vs vy
        y = [a[2] for a in poss]
        vy = [a[2] for a in vels]

        plot(y, vy, ls = &quot;None&quot;, color = c(y), ms = 2.0, alpha = 0.75, marker = &quot;o&quot;)
    end
end
xlabel(&quot;\$y\$&quot;); ylabel(&quot;\$v_y\$&quot;)</code></pre><p><img src="../psos.png" alt/></p><div class="admonition is-info"><header class="admonition-header">`psos` operates on the unit cell</header><div class="admonition-body"><p>The <code>psos</code> function always calculates the crossings <em>within</em> the unit cell of a periodic billiard. This means that no information about the &quot;actual&quot; position of the particle is stored, everything is modulo the unit cell.</p><p>This can be seen very well in the above example, where there aren&#39;t any entries in the region <code>0.5 - r ≤ y ≤ 0.5 + r</code>.</p></div></div><p>Of course it is very easy to &quot;re-normalize&quot; the result such that it is coherent. The only change we have to do is simply replace the line <code>y = [a[2] for a in poss]</code> with</p><pre><code class="language-julia">y = [a[2] &lt; 0.5 ? a[2] + 1 : a[2]  for a in poss]</code></pre><h2 id="Escape-Times"><a class="docs-heading-anchor" href="#Escape-Times">Escape Times</a><a id="Escape-Times-1"></a><a class="docs-heading-anchor-permalink" href="#Escape-Times" title="Permalink"></a></h2><p>It is very easy to create your own function that calculates an &quot;escape time&quot;: the time until the particle leaves the billiard by meeting a specified condition. There is also a high-level function for this though:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.escapetime" href="#DynamicalBilliards.escapetime"><code>DynamicalBilliards.escapetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">escapetime([p,] bd, t; warning = false)</code></pre><p>Calculate the escape time of a particle <code>p</code> in the billiard <code>bd</code>, which is the time until colliding with any &quot;door&quot; in <code>bd</code>. As a &quot;door&quot; is considered any <a href="../../tutorials/billiard_table/#DynamicalBilliards.FiniteWall"><code>FiniteWall</code></a> with field <code>isdoor = true</code>.</p><p>If the particle evolves for more than <code>t</code> (integer or float) without colliding with the <code>Door</code> (i.e. escaping) the returned result is <code>Inf</code>.</p><p>A warning can be thrown if the result is <code>Inf</code>. Enable this using the keyword <code>warning = true</code>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/timeevolution/highleveltimes.jl#L5-L20">source</a></section></article><p>To create a &quot;door&quot; simply use <a href="../../tutorials/billiard_table/#DynamicalBilliards.FiniteWall"><code>FiniteWall</code></a>.</p><p>For example, the default implementation of the mushroom billiard has a &quot;door&quot; at the bottom of the stem. Thus,</p><pre><code class="language-julia">using Statistics
bd = billiard_mushroom()
et = zeros(100)
for i ∈ 1:100
    particle = randominside(bd)
    et[i] = escapetime(particle, bd, 10000)
end
println(&quot;Out of 100 particles, $(count(x-&gt; x != Inf, et)) escaped&quot;)
println(&quot;Mean escape time was $(mean(et[et .!= Inf]))&quot;)</code></pre><pre class="documenter-example-output">Out of 100 particles, 16 escaped
Mean escape time was 2.709754977716437</pre><p>Of course, <code>escapetime</code> works with <code>MagneticParticle</code> as well</p><pre><code class="language-julia">escapetime(randominside(bd, 1.0), bd, 10000)</code></pre><pre class="documenter-example-output">353.31687340351255</pre><h2 id="Mean-Collision-Times"><a class="docs-heading-anchor" href="#Mean-Collision-Times">Mean Collision Times</a><a id="Mean-Collision-Times-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-Collision-Times" title="Permalink"></a></h2><p>Because the computation of a mean collision time (average time between collisions in a billiard) is often a useful quantity, the following function computes it</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.meancollisiontime" href="#DynamicalBilliards.meancollisiontime"><code>DynamicalBilliards.meancollisiontime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">meancollisiontime([p,] bd, t) → κ</code></pre><p>Compute the mean collision time <code>κ</code> of the particle <code>p</code> in the billiard <code>bd</code> by evolving for total amount <code>t</code> (either float for time or integer for collision number).</p><p>Collision times are counted only between obstacles that are <em>not</em> <a href="../../tutorials/billiard_table/#DynamicalBilliards.PeriodicWall"><code>PeriodicWall</code></a>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/timeevolution/highleveltimes.jl#L70-L80">source</a></section></article><p>For example,</p><pre><code class="language-julia">bd = billiard_sinai()
meancollisiontime(randominside(bd), bd, 10000.0)</code></pre><pre class="documenter-example-output">0.4496647870160442</pre><h2 id="Parallelization"><a class="docs-heading-anchor" href="#Parallelization">Parallelization</a><a id="Parallelization-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.parallelize" href="#DynamicalBilliards.parallelize"><code>DynamicalBilliards.parallelize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parallelize(f, bd::Billiard, t, particles; partype = :threads)</code></pre><p>Parallelize function <code>f</code> across the available particles. The parallelization type can be <code>:threads</code> or <code>:pmap</code>, which use threads or a worker pool initialized with <code>addprocs</code> <em>before</em> <code>using DynamicalBilliards</code>.</p><p><code>particles</code> can be:</p><ul><li>A <code>Vector</code> of particles.</li><li>An integer <code>n</code> optionally followed by an angular velocity <code>ω</code>. This uses <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</li></ul><p>The functions usable here are:</p><ul><li><a href="#DynamicalBilliards.meancollisiontime"><code>meancollisiontime</code></a></li><li><a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a></li><li><a href="../../lyapunovs/#DynamicalBilliards.lyapunovspectrum"><code>lyapunovspectrum</code></a> (returns only the maximal exponents)</li><li><a href="../phasespaces/#DynamicalBilliards.boundarymap"><code>boundarymap</code></a> (returns vector of vectors of 2-vectors <em>and</em> <code>arcintervals</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/parallel.jl#L9-L25">source</a></section></article><hr/><p>Here are some examples</p><pre><code class="language-julia">bd = billiard_stadium()
particles = [randominside(bd) for i in 1:1000]
parallelize(meancollisiontime, bd, 1000, particles)</code></pre><pre class="documenter-example-output">1000-element Array{Float64,1}:
 1.1293414665080956
 1.0659342989746416
 1.1311488896774442
 1.1254859450394448
 1.1014770284791555
 1.106749268989628
 1.09981277095985
 1.0986886592486025
 1.1005948263044165
 1.1070080868861645
 ⋮
 1.0744406740635404
 1.0595445349955894
 1.0341616578971382
 1.1099180369888983
 1.104966049010919
 0.9986642237989313
 1.1233703761612552
 1.0771417287193146
 1.1297564600710337</pre><pre><code class="language-julia">parallelize(lyapunovspectrum, bd, 1000, particles)</code></pre><pre class="documenter-example-output">1000-element Array{Float64,1}:
 0.8762687116173551
 0.8726451444202687
 0.9060851258896571
 0.8926663836726618
 0.8480697904416588
 0.8193556502265895
 0.8352785434649889
 0.857488222519429
 0.8964165071232801
 0.9133204087168916
 ⋮
 0.8613611749298768
 0.9095975358638215
 0.9547277127700204
 0.8647519195670197
 0.8484372089741313
 0.4092359254431276
 0.9104768493300973
 0.8583784244548279
 0.8678472022907735</pre><h2 id="It&#39;s-all-about-bounce!"><a class="docs-heading-anchor" href="#It&#39;s-all-about-bounce!">It&#39;s all about bounce!</a><a id="It&#39;s-all-about-bounce!-1"></a><a class="docs-heading-anchor-permalink" href="#It&#39;s-all-about-bounce!" title="Permalink"></a></h2><p>The main propagation algorithm used by <code>DynamicalBilliards</code> is bundled in the following well-behaving function:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.bounce!" href="#DynamicalBilliards.bounce!"><code>DynamicalBilliards.bounce!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bounce!(p::AbstractParticle, bd::Billiard) → i, t, pos, vel</code></pre><p>&quot;Bounce&quot; the particle (advance for one collision) in the billiard. Takes care of finite-precision issues.</p><p>Return:</p><ul><li>index of the obstacle that the particle just collided with</li><li>the time from the previous collision until the current collision <code>t</code></li><li>position and velocity of the particle at the current collision (<em>after</em> the collision has been resolved!). The position is given in the unit cell of periodic billiards. Do <code>pos += p.current_cell</code> for the position in real space.</li></ul><pre><code class="language-julia">bounce!(p, bd, raysplit) → i, t, pos, vel</code></pre><p>Ray-splitting version of <code>bounce!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/timeevolution/propagation.jl#L9-L25">source</a></section></article><hr/><p><code>bounce!</code> is the function used internally by all high-level functions, like <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a>, <a href="../phasespaces/#DynamicalBilliards.boundarymap"><code>boundarymap</code></a>, <a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a>, etc.</p><p>This is the function a user should use if they want to calculate other things besides what is already available in the high level API.</p><h2 id="Standard-Billiards-Library"><a class="docs-heading-anchor" href="#Standard-Billiards-Library">Standard Billiards Library</a><a id="Standard-Billiards-Library-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Billiards-Library" title="Permalink"></a></h2><div class="admonition is-success"><header class="admonition-header">You can also use keywords!</header><div class="admonition-body"><p>All standard billiards have a function version that accepts keyword arguments instead of positional arguments, for ease of use.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_rectangle" href="#DynamicalBilliards.billiard_rectangle"><code>DynamicalBilliards.billiard_rectangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_rectangle(x=1.0, y=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a rectangle billiard of size (<code>x</code>, <code>y</code>).</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li><li>&quot;ray-splitting&quot; : All obstacles in the billiard allow for ray-splitting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/standard_billiards.jl#L11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_sinai" href="#DynamicalBilliards.billiard_sinai"><code>DynamicalBilliards.billiard_sinai</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_sinai(r=0.25, x=1.0, y=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a Sinai billiard of size (<code>x</code>, <code>y</code>) with a disk in its center, of radius <code>r</code>.</p><p>In the periodic case, the system is also known as &quot;Lorentz Gas&quot;.</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li><li>&quot;ray-splitting&quot; : All obstacles in the billiard allow for ray-splitting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/standard_billiards.jl#L70-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_bunimovich" href="#DynamicalBilliards.billiard_bunimovich"><code>DynamicalBilliards.billiard_bunimovich</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_bunimovich(l=1.0, w=1.0)</code></pre><p>Return a vector of <code>Obstacle</code>s that define a Buminovich billiard, also called a stadium. The length is considered <em>without</em> the attached semicircles, meaning that the full length of the billiard is <code>l + w</code>. The left and right edges of the stadium are <a href="../../tutorials/billiard_table/#DynamicalBilliards.Semicircle"><code>Semicircle</code></a>s.</p><p><code>billiard_stadium</code> is an alias of <code>billiard_bunimovich</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/standard_billiards.jl#L272-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_mushroom" href="#DynamicalBilliards.billiard_mushroom"><code>DynamicalBilliards.billiard_mushroom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_mushroom(sl = 1.0, sw = 0.2, cr = 1.0, sloc = 0.0; door = true)</code></pre><p>Create a mushroom billiard with stem length <code>sl</code>, stem width <code>sw</code> and cap radius <code>cr</code>. The center of the cap (which is Semicircle) is always at <code>[0, sl]</code>. The center of the stem is located at <code>sloc</code>.</p><p>Optionally, the bottom-most <code>Wall</code> is a <code>Door</code> (see <a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/standard_billiards.jl#L234-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_polygon" href="#DynamicalBilliards.billiard_polygon"><code>DynamicalBilliards.billiard_polygon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_polygon(n::Int, R, center = [0,0]; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a regular-polygonal billiard with <code>n</code> sides, radius <code>r</code> and given <code>center</code>.</p><p>Note: <code>R</code> denotes the so-called outer radius, not the inner one.</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries. Only available for <code>n=4</code> or <code>n=6</code>.</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/standard_billiards.jl#L113-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_vertices" href="#DynamicalBilliards.billiard_vertices"><code>DynamicalBilliards.billiard_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_vertices(v, type = FiniteWall)</code></pre><p>Construct a polygon billiard that connects the given vertices <code>v</code> (vector of 2-vectors). The vertices should construct a billiard in a counter-clockwise orientation (i.e. the normal vector always points to the left of <code>v[i+1] - v[i]</code>.).</p><p><code>type</code> decides what kind of walls to use. Ths function assumes that the first entry of <code>v</code> should be connected with the last.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/standard_billiards.jl#L373-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_iris" href="#DynamicalBilliards.billiard_iris"><code>DynamicalBilliards.billiard_iris</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_iris(a=0.2, b=0.4, w=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a billiard that is a square of side <code>w</code> enclosing at its center an ellipse with semi axes <code>a</code>, <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/standard_billiards.jl#L360-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_hexagonal_sinai" href="#DynamicalBilliards.billiard_hexagonal_sinai"><code>DynamicalBilliards.billiard_hexagonal_sinai</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_hexagonal_sinai(r, R, center = [0,0]; setting = &quot;standard&quot;)</code></pre><p>Create a sinai-like billiard, which is a hexagon of outer radius <code>R</code>, containing at its center (given by <code>center</code>) a disk of radius <code>r</code>. The <code>setting</code> keyword is passed to <code>billiard_polygon</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/standard_billiards.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_raysplitting_showcase" href="#DynamicalBilliards.billiard_raysplitting_showcase"><code>DynamicalBilliards.billiard_raysplitting_showcase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -&gt; bd, rayspl</code></pre><p>Showcase example billiard for ray-splitting processes. A rectangle <code>(x,y)</code> with a SplitterWall at <code>x/2</code> and two disks at each side, with respective radii <code>r1</code>, <code>r2</code>.</p><p><strong>Notice</strong>: This function returns a billiard <code>bd</code> as well as a <code>rayspl</code> dictionary!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/standard_billiards.jl#L197-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_logo" href="#DynamicalBilliards.billiard_logo"><code>DynamicalBilliards.billiard_logo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_logo(;h=1.0, α=0.8, r=0.18, off=0.25, T = Float64) -&gt; bd, ray</code></pre><p>Create the billiard used as logo of <code>DynamicalBilliards</code> and return it along with the tuple of raysplitters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/standard_billiards.jl#L295-L299">source</a></section></article><h2 id="Particle-types"><a class="docs-heading-anchor" href="#Particle-types">Particle types</a><a id="Particle-types-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.Particle" href="#DynamicalBilliards.Particle"><code>DynamicalBilliards.Particle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Particle(ic::Vector{T}) #where ic = [x0, y0, φ0]
Particle(x0, y0, φ0)
Particle(pos::SVector, vel::SVector)</code></pre><p>Create a particle with initial conditions <code>x0, y0, φ0</code>. It propagates as a straight line.</p><p>The field <code>current_cell</code> shows at which cell of a periodic billiard is the particle currently located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/particles.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.MagneticParticle" href="#DynamicalBilliards.MagneticParticle"><code>DynamicalBilliards.MagneticParticle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MagneticParticle(ic::AbstractVector{T}, ω::Real) # where ic = [x0, y0, φ0]
MagneticParticle(x0, y0, φ0, ω)
MagneticParticle(pos::SVector, vel::SVector, ω)
MagneticParticle(p::AbstractParticle, ω)</code></pre><p>Create a <em>magnetic</em> particle with initial conditions <code>x0, y0, φ0</code> and angular velocity <code>ω</code>. It propagates as a circle instead of a line, with radius <code>1/abs(ω)</code>.</p><p>The field <code>current_cell</code> shows at which cell of a periodic billiard is the particle currently located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/46696a644640faa2a82e18f5db613b164aa47470/src/billiards/particles.jl#L58-L71">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><a class="docs-footer-nextpage" href="../../visualizing/">Visualizing &amp; Animating »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 10 December 2020 01:29">Thursday 10 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
