<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>High Level API · DynamicalBilliards.jl</title><meta name="title" content="High Level API · DynamicalBilliards.jl"/><meta property="og:title" content="High Level API · DynamicalBilliards.jl"/><meta property="twitter:title" content="High Level API · DynamicalBilliards.jl"/><meta name="description" content="Documentation for DynamicalBilliards.jl."/><meta property="og:description" content="Documentation for DynamicalBilliards.jl."/><meta property="twitter:description" content="Documentation for DynamicalBilliards.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalBilliards.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DynamicalBilliards.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li class="is-active"><a class="tocitem" href>High Level API</a><ul class="internal"><li><a class="tocitem" href="#Billiard"><span>Billiard</span></a></li><li><a class="tocitem" href="#Particles"><span>Particles</span></a></li><li><a class="tocitem" href="#Random-initial-conditions"><span>Random initial conditions</span></a></li><li><a class="tocitem" href="#evolve-and-timeseries"><span><code>evolve</code> &amp; <code>timeseries</code></span></a></li><li><a class="tocitem" href="#Poincaré-Sections"><span>Poincaré Sections</span></a></li><li><a class="tocitem" href="#Escape-Times"><span>Escape Times</span></a></li><li><a class="tocitem" href="#Mean-Collision-Times"><span>Mean Collision Times</span></a></li><li><a class="tocitem" href="#Parallelization"><span>Parallelization</span></a></li><li><a class="tocitem" href="#It&#39;s-all-about-bounce!"><span>It&#39;s all about bounce!</span></a></li><li><a class="tocitem" href="#Standard-Billiards-Library"><span>Standard Billiards Library</span></a></li><li><a class="tocitem" href="#Particle-types"><span>Particle types</span></a></li></ul></li><li><a class="tocitem" href="../../billiards_visualizations/">Visualizing &amp; Animating</a></li><li><a class="tocitem" href="../phasespaces/">Phase Spaces</a></li><li><a class="tocitem" href="../../ray-splitting/">Ray-Splitting</a></li><li><a class="tocitem" href="../../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../mushroomtools/">MushroomTools</a></li><li><a class="tocitem" href="../../physics/">Physics</a></li><li><a class="tocitem" href="../low_level/">Internals</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/billiard_table/">Defining a Billiard</a></li><li><a class="tocitem" href="../../tutorials/own_obstacle/">Defining your own Obstacles</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>High Level API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>High Level API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/master/docs/src/basic/high_level.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="High-Level-API"><a class="docs-heading-anchor" href="#High-Level-API">High Level API</a><a id="High-Level-API-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-API" title="Permalink"></a></h1><p><code>DynamicalBilliards</code> was created with ease-of-use as its main cornerstone. With 3 simple steps, the user can get the output of the propagation of a particle in a billiard.</p><p>In general, the workflow of <code>DynamicalBilliards</code> follows these simple steps:</p><ol><li>Create a billiard.</li><li>Create particles inside that billiard.</li><li>Get the output you want by using one of the high level functions.</li></ol><p>Adding more complexity in your billiard does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> and pass it to the high level functions.</p><p>After reading through this page, you will be able to use almost all aspects of <code>DynamicalBilliards</code> with minimal effort.</p><div class="admonition is-success"><header class="admonition-header">Visualizations</header><div class="admonition-body"><p>Visualizing the billiards, particles, and their motion is one of the most important parts of the <code>DynamicalBilliards</code>. It is not discussed in this page however, but rather in the <a href="../../billiards_visualizations/#visualizations">Visualizing &amp; Animating</a> page.</p></div></div><h2 id="Billiard"><a class="docs-heading-anchor" href="#Billiard">Billiard</a><a id="Billiard-1"></a><a class="docs-heading-anchor-permalink" href="#Billiard" title="Permalink"></a></h2><p>A <a href="#Billiard"><code>Billiard</code></a> is simply a collection of <a href="../../tutorials/billiard_table/#DynamicalBilliards.Obstacle"><code>Obstacle</code></a> subtypes. Particles are propagating inside a <code>Billiard</code>, bouncing from obstacle to obstacle while having constant velocity in-between.</p><p>There is a tutorial on how to create your own billiard. In addition, there are many pre-defined billiards that can be found in the <a href="#Standard-Billiards-Library">Standard Billiards Library</a> section. That is why knowing how to construct a <a href="#Billiard"><code>Billiard</code></a> is not important at this point.</p><p>In this page we will be using the Bunimovich billiard as an example:</p><pre><code class="language-julia hljs">using DynamicalBilliards
bd = billiard_bunimovich()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Billiard{Float64} with 4 obstacles:
  Bottom wall
  Right semicircle
  Top wall
  Left semicircle</code></pre><h2 id="Particles"><a class="docs-heading-anchor" href="#Particles">Particles</a><a id="Particles-1"></a><a class="docs-heading-anchor-permalink" href="#Particles" title="Permalink"></a></h2><p>A &quot;particle&quot; is that thingy that moves around in the billiard. It always moves with velocity of measure 1, by convention.</p><p>Currently there are two types of particles:</p><ul><li><a href="#DynamicalBilliards.Particle"><code>Particle</code></a>, which propagates as a straight line.</li><li><a href="#DynamicalBilliards.MagneticParticle"><code>MagneticParticle</code></a>, which propagates as a circle instead of a line (similar to electrons in a perpendicular magnetic field).</li></ul><p>To make a particle, provide the constructor with some initial conditions:</p><pre><code class="language-julia hljs">x0 = rand(); y0 = rand();
φ0 = 2π*rand()
p = Particle(x0, y0, φ0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Particle{Float64}
position: [0.8351881435134845, 0.8192446867530516]
velocity: [0.39923985891529484, 0.916846516628217]</code></pre><p>To create a <code>MagneticParticle</code> simply provide the constructor with one more number, the angular velocity:</p><pre><code class="language-julia hljs">ω = 0.5
mp = MagneticParticle(x0, y0, φ0, ω)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MagneticParticle{Float64}
position: [0.8351881435134845, 0.8192446867530516]
velocity: [0.39923985891529484, 0.916846516628217]
ang. velocity: 0.5</code></pre><p>When creating a billiard or a particle, the object is printed with <code>{Float64}</code> at the end. This shows what type of numbers are used for <em>all</em> numerical operations. If you are curious you can learn more about it in the <a href="../low_level/#Numerical-Precision">Numerical Precision</a>.</p><p>You can initialize several particles with the same direction but slightly different position is the following function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.particlebeam" href="#DynamicalBilliards.particlebeam"><code>DynamicalBilliards.particlebeam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">particlebeam(x0, y0, φ, N, dx, ω = nothing, T = eltype(x0)) → ps</code></pre><p>Make <code>N</code> particles, all with direction <code>φ</code>, starting at <code>x0, y0</code>. The particles don&#39;t all have the same position, but are instead spread by up to <code>dx</code> in the direction normal to <code>φ</code>.</p><p>The particle element type is <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/particles.jl#L143-L150">source</a></section></article><div class="admonition is-danger"><header class="admonition-header">Particles must be inside the Billiard!</header><div class="admonition-body"><p>Keep in mind that the particle must be initialized <strong>inside a billiard</strong> for any functionality to work properly and make sense. If you are not sure what we mean by that, then you should check out the <a href="../low_level/#Internals">Internals</a> page.</p></div></div><h2 id="Random-initial-conditions"><a class="docs-heading-anchor" href="#Random-initial-conditions">Random initial conditions</a><a id="Random-initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Random-initial-conditions" title="Permalink"></a></h2><p>If you have a <code>Billiard</code> which is not a rectangle, creating many random initial conditions inside it can be a pain. Fortunately, we have the following function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.randominside" href="#DynamicalBilliards.randominside"><code>DynamicalBilliards.randominside</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">randominside(bd::Billiard [, ω]) → p</code></pre><p>Return a particle <code>p</code> with random allowed initial conditions inside the given billiard. If supplied with a second argument the type of the returned particle is <code>MagneticParticle</code>, with angular velocity <code>ω</code>.</p><p><strong>WARNING</strong> : <code>randominside</code> works for any <strong>convex</strong> billiard but it does not work for non-convex billiards. (this is because it uses <code>distance</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/billiardtable.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.randominside_xyφ" href="#DynamicalBilliards.randominside_xyφ"><code>DynamicalBilliards.randominside_xyφ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">randominside_xyφ(bd::Billiard) → x, y, φ</code></pre><p>Same as <a href="#DynamicalBilliards.randominside"><code>randominside</code></a> but only returns position and direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/billiardtable.jl#L137-L140">source</a></section></article><p>For example:</p><pre><code class="language-julia hljs">p = randominside(bd)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Particle{Float64}
position: [1.1175298699463314, 0.9116367144893559]
velocity: [-0.8420827488356939, 0.5393483513586759]</code></pre><p>and</p><pre><code class="language-julia hljs">mp = randominside(bd, ω)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MagneticParticle{Float64}
position: [0.3013316474465286, 0.39466733078013116]
velocity: [-0.5816498723205017, -0.8134392577381202]
ang. velocity: 0.5</code></pre><p><code>randominside</code> always creates particles with same number type as the billiard.</p><h2 id="evolve-and-timeseries"><a class="docs-heading-anchor" href="#evolve-and-timeseries"><code>evolve</code> &amp; <code>timeseries</code></a><a id="evolve-and-timeseries-1"></a><a class="docs-heading-anchor-permalink" href="#evolve-and-timeseries" title="Permalink"></a></h2><p>Now that we have created a billiard and a particle inside, we want to evolve it! There is a simple function for that, called <code>evolve!</code> (or <code>evolve</code> if you don&#39;t want to mutate the particle), which returns the time, position and velocities at the collision points:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.evolve!" href="#DynamicalBilliards.evolve!"><code>DynamicalBilliards.evolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evolve!([p::AbstractParticle,] bd::Billiard, t)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code>. If <code>t</code> is of type <code>AbstractFloat</code>, evolve for as much time as <code>t</code>. If however <code>t</code> is of type <code>Int</code>, evolve for as many collisions as <code>t</code>. Return the states of the particle between collisions.</p><p>This function mutates the particle, use <code>evolve</code> otherwise. If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</p><p><strong>Return</strong></p><ul><li><code>ct::Vector{T}</code> : Collision times.</li><li><code>poss::Vector{SVector{2,T}}</code> : Positions at the collisions.</li><li><code>vels::Vector{SVector{2,T}})</code> : Velocities exactly after the collisions.</li><li><code>ω</code>, either <code>T</code> or <code>Vector{T}</code> : Angular velocity/ies (returned only for magnetic particles).</li></ul><p>The time <code>ct[i+1]</code> is the time necessary to reach state <code>poss[i+1], vels[i+1]</code> starting from the state <code>poss[i], vels[i]</code>. That is why <code>ct[1]</code> is always 0 since <code>poss[1], vels[1]</code> are the initial conditions. The angular velocity <code>ω[i]</code> is the one the particle has while propagating from state <code>poss[i], vels[i]</code> to <code>i+1</code>.</p><p>Notice that at any point, the velocity vector <code>vels[i]</code> is the one obdained <em>after</em> the specular reflection of the <code>i-1</code>th collision.</p><p><strong>Ray-splitting billiards</strong></p><pre><code class="nohighlight hljs">evolve!(p, bd, t, raysplitters)</code></pre><p>To implement ray-splitting, the <code>evolve!</code> function is supplemented with a fourth argument, <code>raysplitters</code> which is a tuple of <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Notice that <code>evolve</code> <strong>always mutates the billiard</strong> if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/timeevolution/timeseries.jl#L5-L39">source</a></section></article><p>Forget the ray-splitting part for now (see <a href="../../ray-splitting/#Ray-Splitting">Ray-Splitting</a>).</p><p>Let&#39;s see an example:</p><pre><code class="language-julia hljs">ct, poss, vels = evolve(p, bd, 100)
for i in 1:5
  println(round(ct[i], digits=3), &quot;  &quot;, poss[i], &quot;  &quot;, vels[i])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0  [1.1175298699463314, 0.9116367144893559]  [-0.8420827488356939, 0.5393483513586759]
0.164  [0.9795685724444261, 1.0]  [-0.8420827488356939, -0.5393483513586759]
1.583  [-0.35336906842675897, 0.14626238328500563]  [0.5384702613023018, 0.842644514426476]
1.013  [0.1921899540146541, 1.0]  [0.5384702613023018, -0.842644514426476]
1.187  [0.8312141831924794, 1.1102230246251565e-16]  [0.5384702613023018, 0.842644514426476]</code></pre><p>Similarly, for magnetic propagation</p><pre><code class="language-julia hljs">ct, poss, vels, ω = evolve(mp, bd, 100)
for i in 1:10
  println(round(ct[i], digits=3), &quot;  &quot;, poss[i], &quot;  &quot;, vels[i])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0  [0.3013316474465286, 0.39466733078013116]  [-0.5816498723205017, -0.8134392577381202]
0.453  [0.08180711581674549, 0.0]  [-0.3843162069304361, 0.9232015235530118]
0.909  [-0.44276600449202685, 0.7322891845656324]  [0.9703118281340256, -0.24185730541624018]
1.623  [1.1159312554457164, 0.986374283870745]  [0.5101447815498561, -0.8600885430334776]
0.607  [1.4996481438592184, 0.5187545284674471]  [-0.6917671909604265, -0.7221205948529107]
0.607  [1.1520662464176716, 0.0236851286171727]  [-0.8811896484766224, 0.4727629463247375]
1.579  [-0.37886291334868244, 0.1737134803750716]  [0.43126722147378904, 0.9022242424598654]
0.82  [-0.18459237148335833, 0.964678013671994]  [0.7117987890916097, -0.702383430789564]
1.829  [1.491223220885588, 0.40672756429261414]  [-0.872142951220924, 0.48925113452669433]
2.071  [-0.4885786796155667, 0.393741476459018]  [0.9953908376225877, -0.09590140967161626]</code></pre><p>The above return types are helpful in some applications. In other applications however one prefers to have the time series of the individual variables. For this, the <code>timeseries</code> function is used:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.timeseries!" href="#DynamicalBilliards.timeseries!"><code>DynamicalBilliards.timeseries!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">timeseries!([p::AbstractParticle,] bd::Billiard, t; dt, warning)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code> for the condition <code>t</code> and return the x, y, vx, vy timeseries and the time vector. If <code>t</code> is of type <code>AbstractFloat</code>, then evolve for as much time as <code>t</code>. If however <code>t</code> is of type <code>Int</code>, evolve for as many collisions as <code>t</code>. Otherwise, <code>t</code> can be any function, that takes as an input <code>t(n, τ, i, p)</code> and returns <code>true</code> when the evolution should terminate. Here <code>n</code> is the amount of obstacles collided with so far, <code>τ</code> the amount time evolved so far, <code>i</code> the obstacle just collided with and <code>p</code> the particle (so you can access e.g. <code>p.pos</code>).</p><p>This function mutates the particle, use <code>timeseries</code> otherwise. If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</p><p>The keyword argument <code>dt</code> is the time step used for interpolating the time series in between collisions. <code>dt</code> is capped by the collision time, as the interpolation <em>always</em> stops at collisions. For straight propagation <code>dt = Inf</code>, while for magnetic <code>dt = 0.01</code>.</p><p>For pinned magnetic particles, <code>timeseries!</code> issues a warning and returns the trajectory of the particle. If <code>t</code> is integer, the trajectory is evolved for one full circle only.</p><p>Internally uses <a href="../low_level/#DynamicalBilliards.extrapolate"><code>DynamicalBilliards.extrapolate</code></a>.</p><p><strong>Ray-splitting billiards</strong></p><pre><code class="nohighlight hljs">timeseries!(p, bd, t, raysplitters; ...)</code></pre><p>To implement ray-splitting, the <code>timeseries!</code> function is supplemented with a fourth argument, <code>raysplitters</code> which is a tuple of <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Notice that <code>timeseries</code> <strong>always mutates the billiard</strong> if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/timeevolution/timeseries.jl#L107-L141">source</a></section></article><p>For example:</p><pre><code class="language-julia hljs">xt, yt, vxt, vyt, t = timeseries(p, bd, 100)

# print as a matrix:
hcat(xt, yt, vxt, vyt, t)[1:5, :]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×5 Matrix{Float64}:
  1.11753   0.911637     -0.842083   0.539348  0.0
  0.979569  1.0          -0.842083  -0.539348  0.163833
 -0.353369  0.146262      0.53847    0.842645  1.74674
  0.19219   1.0           0.53847   -0.842645  2.7599
  0.831214  1.11022e-16   0.53847    0.842645  3.94664</code></pre><p>Same story for magnetic particles:</p><pre><code class="language-julia hljs"># evolve the magnetic particle instead:
xt, yt, vxt, vyt, t = timeseries(mp, bd, 100)

# print as a matrix:
hcat(xt, yt, vxt, vyt, t)[1:5, :]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×5 Matrix{Float64}:
 0.301332  0.394667  -0.58165   -0.813439  0.0
 0.295536  0.386518  -0.577575  -0.816337  0.01
 0.28978   0.378341  -0.573487  -0.819215  0.02
 0.284066  0.370134  -0.569383  -0.822072  0.03
 0.278393  0.361899  -0.565266  -0.824909  0.04</code></pre><p>Sometimes we may need information about which obstacles a particle visited, in which sequence, and when. For this we have the following function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.visited_obstacles!" href="#DynamicalBilliards.visited_obstacles!"><code>DynamicalBilliards.visited_obstacles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visited_obstacles!([p::AbstractParticle,] bd::Billiard, t)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code> exactly like <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a>. However return only:</p><ul><li><code>ts::Vector{T}</code> : Vector of time points of when each collision occured.</li><li><code>obst::Vector{Int}</code> : Vector of obstacle indices in <code>bd</code> that the particle collided with at the time points in <code>ts</code>.</li></ul><p>The first entries are <code>0.0</code> and <code>0</code>. Similarly with <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a> the function does not record collisions with periodic walls.</p><p>Currently does not support raysplitting. Returns empty arrays for pinned particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/timeevolution/highleveltimes.jl#L125-L140">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Type of `t`</header><div class="admonition-body"><p>Remember that the behavior of time evolution depends on the type of the <code>t</code> argument, which represents &quot;total amount&quot;. If it is <code>AbstractFloat</code>, it represents total amount of time, but if it is <code>Int</code> it represents total number of collisions.</p></div></div><h2 id="Poincaré-Sections"><a class="docs-heading-anchor" href="#Poincaré-Sections">Poincaré Sections</a><a id="Poincaré-Sections-1"></a><a class="docs-heading-anchor-permalink" href="#Poincaré-Sections" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.psos" href="#DynamicalBilliards.psos"><code>DynamicalBilliards.psos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">psos(bd::Billiard, plane::InfiniteWall, t, particles)</code></pre><p>Compute the Poincaré section of the <code>particles</code> with the given <code>plane</code>, by evolving each one for time <code>t</code> (either integer or float) inside <code>bd</code>.</p><p>The <code>plane</code> can be an <a href="../../tutorials/billiard_table/#DynamicalBilliards.InfiniteWall"><code>InfiniteWall</code></a> of <em>any</em> orientation, however only crossings of the <code>plane</code> such that <code>dot(velocity, normal) &lt; 0</code> are allowed, with <code>normal</code> the normal unit vector of the <code>plane</code>.</p><p><code>particles</code> can be:</p><ul><li>A single particle.</li><li>A <code>Vector</code> of particles.</li><li>An integer <code>n</code> optionally followed by an angular velocity <code>ω</code>.</li></ul><p>Return the positions <code>poss</code> and velocities <code>vels</code> at the instances of crossing the <code>plane</code>. If given more than one particle, the result is a vector of vectors of vectors.</p><p><em>Notice</em> - This function can handle pinned particles. If a pinned particle can intersect with the <code>plane</code>, then an intersection is returned. If however it can&#39;t then empty vectors are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/poincare.jl#L3-L24">source</a></section></article><p>For example, the surface of section in the periodic Sinai billiard with magnetic field reveals the mixed nature of the phase-space:</p><pre><code class="language-julia hljs">using DynamicalBilliards, CairoMakie
t = 100; r = 0.15
bd = billiard_sinai(r, setting = &quot;periodic&quot;)

# the direction of the normal vector is IMPORTANT!!!
# (always keep in mind that ω &gt; 0  means counter-clockwise rotation!)
plane = InfiniteWall([0.5, 0.0], [0.5, 1.0], [-1.0, 0.0])

posvector, velvector = psos(bd, plane, t, 1000, 2.0)
c(a) = length(a) == 1 ? &quot;#6D44D0&quot; : &quot;#DA5210&quot;

fig = Figure(); ax = Axis(fig[1,1]; xlabel = L&quot;y&quot;, ylabel=L&quot;v_y&quot;)

for i in 1:length(posvector)
    poss = posvector[i] # vector of positions
    vels = velvector[i] # vector of velocities at the section
    L = length(poss)
    if L &gt; 0
        #plot y vs vy
        y = [a[2] for a in poss]
        vy = [a[2] for a in vels]
        scatter!(y, vy; color = c(y), markersize = 2)
    end
end
fig</code></pre><img src="a5566d1d.png" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">`psos` operates on the unit cell</header><div class="admonition-body"><p>The <code>psos</code> function always calculates the crossings <em>within</em> the unit cell of a periodic billiard. This means that no information about the &quot;actual&quot; position of the particle is stored, everything is modulo the unit cell.</p><p>This can be seen very well in the above example, where there aren&#39;t any entries in the region <code>0.5 - r ≤ y ≤ 0.5 + r</code>.</p></div></div><p>Of course it is very easy to &quot;re-normalize&quot; the result such that it is coherent. The only change we have to do is simply replace the line <code>y = [a[2] for a in poss]</code> with</p><pre><code class="language-julia hljs">y = [a[2] &lt; 0.5 ? a[2] + 1 : a[2]  for a in poss]</code></pre><h2 id="Escape-Times"><a class="docs-heading-anchor" href="#Escape-Times">Escape Times</a><a id="Escape-Times-1"></a><a class="docs-heading-anchor-permalink" href="#Escape-Times" title="Permalink"></a></h2><p>It is very easy to create your own function that calculates an &quot;escape time&quot;: the time until the particle leaves the billiard by meeting a specified condition. There is also a high-level function for this though:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.escapetime" href="#DynamicalBilliards.escapetime"><code>DynamicalBilliards.escapetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">escapetime([p,] bd, t; warning = false)</code></pre><p>Calculate the escape time of a particle <code>p</code> in the billiard <code>bd</code>, which is the time until colliding with any &quot;door&quot; in <code>bd</code>. As a &quot;door&quot; is considered any <a href="../../tutorials/billiard_table/#DynamicalBilliards.FiniteWall"><code>FiniteWall</code></a> with field <code>isdoor = true</code>.</p><p>If the particle evolves for more than <code>t</code> (integer or float) without colliding with the <code>Door</code> (i.e. escaping) the returned result is <code>Inf</code>.</p><p>A warning can be thrown if the result is <code>Inf</code>. Enable this using the keyword <code>warning = true</code>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/timeevolution/highleveltimes.jl#L5-L20">source</a></section></article><p>To create a &quot;door&quot; simply use <a href="../../tutorials/billiard_table/#DynamicalBilliards.FiniteWall"><code>FiniteWall</code></a>.</p><p>For example, the default implementation of the mushroom billiard has a &quot;door&quot; at the bottom of the stem. Thus,</p><pre><code class="language-julia hljs">using Statistics
bd = billiard_mushroom()
et = zeros(100)
for i ∈ 1:100
    particle = randominside(bd)
    et[i] = escapetime(particle, bd, 10000)
end
println(&quot;Out of 100 particles, $(count(x-&gt; x != Inf, et)) escaped&quot;)
println(&quot;Mean escape time was $(mean(et[et .!= Inf]))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Out of 100 particles, 23 escaped
Mean escape time was 6.806621169997773</code></pre><p>Of course, <code>escapetime</code> works with <code>MagneticParticle</code> as well</p><pre><code class="language-julia hljs">escapetime(randominside(bd, 1.0), bd, 10000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">83.70867396746934</code></pre><h2 id="Mean-Collision-Times"><a class="docs-heading-anchor" href="#Mean-Collision-Times">Mean Collision Times</a><a id="Mean-Collision-Times-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-Collision-Times" title="Permalink"></a></h2><p>Because the computation of a mean collision time (average time between collisions in a billiard) is often a useful quantity, the following function computes it</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.meancollisiontime" href="#DynamicalBilliards.meancollisiontime"><code>DynamicalBilliards.meancollisiontime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">meancollisiontime([p,] bd, t) → κ</code></pre><p>Compute the mean collision time <code>κ</code> of the particle <code>p</code> in the billiard <code>bd</code> by evolving for total amount <code>t</code> (either float for time or integer for collision number).</p><p>Collision times are counted only between obstacles that are <em>not</em> <a href="../../tutorials/billiard_table/#DynamicalBilliards.PeriodicWall"><code>PeriodicWall</code></a>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/timeevolution/highleveltimes.jl#L73-L83">source</a></section></article><p>For example,</p><pre><code class="language-julia hljs">bd = billiard_sinai()
meancollisiontime(randominside(bd), bd, 10000.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.455705047712392</code></pre><h2 id="Parallelization"><a class="docs-heading-anchor" href="#Parallelization">Parallelization</a><a id="Parallelization-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.parallelize" href="#DynamicalBilliards.parallelize"><code>DynamicalBilliards.parallelize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parallelize(f, bd::Billiard, t, particles; partype = :threads)</code></pre><p>Parallelize function <code>f</code> across the available particles. The parallelization type can be <code>:threads</code> or <code>:pmap</code>, which use threads or a worker pool initialized with <code>addprocs</code> <em>before</em> <code>using DynamicalBilliards</code>.</p><p><code>particles</code> can be:</p><ul><li>A <code>Vector</code> of particles.</li><li>An integer <code>n</code> optionally followed by an angular velocity <code>ω</code>. This uses <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</li></ul><p>The functions usable here are:</p><ul><li><a href="#DynamicalBilliards.meancollisiontime"><code>meancollisiontime</code></a></li><li><a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a></li><li><a href="../../lyapunovs/#DynamicalBilliards.lyapunovspectrum"><code>lyapunovspectrum</code></a> (returns only the maximal exponents)</li><li><a href="../phasespaces/#DynamicalBilliards.boundarymap"><code>boundarymap</code></a> (returns vector of vectors of 2-vectors <em>and</em> <code>arcintervals</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/parallel.jl#L9-L25">source</a></section></article><p>Here are some examples</p><pre><code class="language-julia hljs">bd = billiard_stadium()
particles = [randominside(bd) for i in 1:1000]
parallelize(meancollisiontime, bd, 1000, particles)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000-element Vector{Float64}:
 1.0911931050960788
 1.1143498305587527
 1.0804095934233868
 1.079245473144379
 1.1391768177241426
 1.0375691058152232
 1.119758441109758
 1.074341893002397
 1.1033671241036371
 1.0455108393335315
 ⋮
 1.0950349703130853
 1.081499611829668
 1.065281645515326
 1.0496785538443612
 1.139837366656638
 1.1106213457693743
 1.0759472191909856
 1.0920698019624837
 1.0866983153129903</code></pre><pre><code class="language-julia hljs">parallelize(lyapunovspectrum, bd, 1000, particles)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000-element Vector{Float64}:
 0.8968067178536954
 0.8910371722057758
 0.8415404680237077
 0.8526916351093605
 0.8788544706420249
 0.8338437536736311
 0.8320015812975936
 0.8698092829912604
 0.8621559697161493
 0.5978318497811886
 ⋮
 0.8654841146346096
 0.6990919498610223
 0.906593330845827
 0.9603219703301735
 0.8927064649799904
 0.853310929554065
 0.8263737759593881
 0.8101951096526985
 0.8277969242434021</code></pre><h2 id="It&#39;s-all-about-bounce!"><a class="docs-heading-anchor" href="#It&#39;s-all-about-bounce!">It&#39;s all about bounce!</a><a id="It&#39;s-all-about-bounce!-1"></a><a class="docs-heading-anchor-permalink" href="#It&#39;s-all-about-bounce!" title="Permalink"></a></h2><p>The main propagation algorithm used by <code>DynamicalBilliards</code> is bundled in the following well-behaving function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.bounce!" href="#DynamicalBilliards.bounce!"><code>DynamicalBilliards.bounce!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bounce!(p::AbstractParticle, bd::Billiard) → i, t, pos, vel</code></pre><p>&quot;Bounce&quot; the particle (advance for one collision) in the billiard. Takes care of finite-precision issues.</p><p>Return:</p><ul><li>index of the obstacle that the particle just collided with</li><li>the time from the previous collision until the current collision <code>t</code></li><li>position and velocity of the particle at the current collision (<em>after</em> the collision has been resolved!). The position is given in the unit cell of periodic billiards. Do <code>pos += p.current_cell</code> for the position in real space.</li></ul><pre><code class="language-julia hljs">bounce!(p, bd, raysplit) → i, t, pos, vel</code></pre><p>Ray-splitting version of <code>bounce!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/timeevolution/propagation.jl#L9-L25">source</a></section></article><p><code>bounce!</code> is the function used internally by all high-level functions, like <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a>, <a href="../phasespaces/#DynamicalBilliards.boundarymap"><code>boundarymap</code></a>, <a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a>, etc.</p><p>This is the function a user should use if they want to calculate other things besides what is already available in the high level API.</p><h2 id="Standard-Billiards-Library"><a class="docs-heading-anchor" href="#Standard-Billiards-Library">Standard Billiards Library</a><a id="Standard-Billiards-Library-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Billiards-Library" title="Permalink"></a></h2><div class="admonition is-success"><header class="admonition-header">You can also use keywords!</header><div class="admonition-body"><p>All standard billiards have a function version that accepts keyword arguments instead of positional arguments, for ease of use.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.billiard_rectangle" href="#DynamicalBilliards.billiard_rectangle"><code>DynamicalBilliards.billiard_rectangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">billiard_rectangle(x=1.0, y=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a rectangle billiard of size (<code>x</code>, <code>y</code>).</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li><li>&quot;ray-splitting&quot; : All obstacles in the billiard allow for ray-splitting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/standard_billiards.jl#L11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.billiard_sinai" href="#DynamicalBilliards.billiard_sinai"><code>DynamicalBilliards.billiard_sinai</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">billiard_sinai(r=0.25, x=1.0, y=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a Sinai billiard of size (<code>x</code>, <code>y</code>) with a disk in its center, of radius <code>r</code>.</p><p>In the periodic case, the system is also known as &quot;Lorentz Gas&quot;.</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li><li>&quot;ray-splitting&quot; : All obstacles in the billiard allow for ray-splitting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/standard_billiards.jl#L70-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.billiard_bunimovich" href="#DynamicalBilliards.billiard_bunimovich"><code>DynamicalBilliards.billiard_bunimovich</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">billiard_bunimovich(l=1.0, w=1.0)</code></pre><p>Return a vector of <code>Obstacle</code>s that define a Buminovich billiard, also called a stadium. The length is considered <em>without</em> the attached semicircles, meaning that the full length of the billiard is <code>l + w</code>. The left and right edges of the stadium are <a href="../../tutorials/billiard_table/#DynamicalBilliards.Semicircle"><code>Semicircle</code></a>s.</p><p><code>billiard_stadium</code> is an alias of <code>billiard_bunimovich</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/standard_billiards.jl#L272-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.billiard_mushroom" href="#DynamicalBilliards.billiard_mushroom"><code>DynamicalBilliards.billiard_mushroom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">billiard_mushroom(sl = 1.0, sw = 0.2, cr = 1.0, sloc = 0.0; door = true)</code></pre><p>Create a mushroom billiard with stem length <code>sl</code>, stem width <code>sw</code> and cap radius <code>cr</code>. The center of the cap (which is Semicircle) is always at <code>[0, sl]</code>. The center of the stem is located at <code>sloc</code>.</p><p>Optionally, the bottom-most <code>Wall</code> is a <code>Door</code> (see <a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/standard_billiards.jl#L234-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.billiard_polygon" href="#DynamicalBilliards.billiard_polygon"><code>DynamicalBilliards.billiard_polygon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">billiard_polygon(n::Int, R, center = [0,0]; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a regular-polygonal billiard with <code>n</code> sides, radius <code>r</code> and given <code>center</code>.</p><p>Note: <code>R</code> denotes the so-called outer radius, not the inner one.</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries. Only available for <code>n=4</code> or <code>n=6</code>.</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/standard_billiards.jl#L113-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.billiard_vertices" href="#DynamicalBilliards.billiard_vertices"><code>DynamicalBilliards.billiard_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">billiard_vertices(v, type = FiniteWall)</code></pre><p>Construct a polygon billiard that connects the given vertices <code>v</code> (vector of 2-vectors). The vertices should construct a billiard in a counter-clockwise orientation (i.e. the normal vector always points to the left of <code>v[i+1] - v[i]</code>.).</p><p><code>type</code> decides what kind of walls to use. Ths function assumes that the first entry of <code>v</code> should be connected with the last.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/standard_billiards.jl#L373-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.billiard_iris" href="#DynamicalBilliards.billiard_iris"><code>DynamicalBilliards.billiard_iris</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">billiard_iris(a=0.2, b=0.4, w=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a billiard that is a square of side <code>w</code> enclosing at its center an ellipse with semi axes <code>a</code>, <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/standard_billiards.jl#L360-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.billiard_hexagonal_sinai" href="#DynamicalBilliards.billiard_hexagonal_sinai"><code>DynamicalBilliards.billiard_hexagonal_sinai</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">billiard_hexagonal_sinai(r, R, center = [0,0]; setting = &quot;standard&quot;)</code></pre><p>Create a sinai-like billiard, which is a hexagon of outer radius <code>R</code>, containing at its center (given by <code>center</code>) a disk of radius <code>r</code>. The <code>setting</code> keyword is passed to <code>billiard_polygon</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/standard_billiards.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.billiard_raysplitting_showcase" href="#DynamicalBilliards.billiard_raysplitting_showcase"><code>DynamicalBilliards.billiard_raysplitting_showcase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">billiard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -&gt; bd, rayspl</code></pre><p>Showcase example billiard for ray-splitting processes. A rectangle <code>(x,y)</code> with a SplitterWall at <code>x/2</code> and two disks at each side, with respective radii <code>r1</code>, <code>r2</code>.</p><p><strong>Notice</strong>: This function returns a billiard <code>bd</code> as well as a <code>rayspl</code> dictionary!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/standard_billiards.jl#L197-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.billiard_logo" href="#DynamicalBilliards.billiard_logo"><code>DynamicalBilliards.billiard_logo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">billiard_logo(;h=1.0, α=0.8, r=0.18, off=0.25, T = Float64) -&gt; bd, ray</code></pre><p>Create the billiard used as logo of <code>DynamicalBilliards</code> and return it along with the tuple of raysplitters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/standard_billiards.jl#L295-L299">source</a></section></article><h2 id="Particle-types"><a class="docs-heading-anchor" href="#Particle-types">Particle types</a><a id="Particle-types-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.Particle" href="#DynamicalBilliards.Particle"><code>DynamicalBilliards.Particle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Particle(ic::Vector{T}) #where ic = [x0, y0, φ0]
Particle(x0, y0, φ0)
Particle(pos::SVector, vel::SVector)</code></pre><p>Create a particle with initial conditions <code>x0, y0, φ0</code>. It propagates as a straight line.</p><p>The field <code>current_cell</code> shows at which cell of a periodic billiard is the particle currently located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/particles.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalBilliards.MagneticParticle" href="#DynamicalBilliards.MagneticParticle"><code>DynamicalBilliards.MagneticParticle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MagneticParticle(ic::AbstractVector{T}, ω::Real) # where ic = [x0, y0, φ0]
MagneticParticle(x0, y0, φ0, ω)
MagneticParticle(pos::SVector, vel::SVector, ω)
MagneticParticle(p::AbstractParticle, ω)</code></pre><p>Create a <em>magnetic</em> particle with initial conditions <code>x0, y0, φ0</code> and angular velocity <code>ω</code>. It propagates as a circle instead of a line, with radius <code>1/abs(ω)</code>.</p><p>The field <code>current_cell</code> shows at which cell of a periodic billiard is the particle currently located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/f062b1d3021361df650f367e396294ca03cdeaaf/src/billiards/particles.jl#L58-L71">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><a class="docs-footer-nextpage" href="../../billiards_visualizations/">Visualizing &amp; Animating »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 21 June 2024 10:05">Friday 21 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
