{
    "docs": [
        {
            "location": "/", 
            "text": "DynamicalBilliards\n is an easy-to-use, modular and extendable Julia package for dynamical billiards in two dimensions.\n\n\n\n\nJuliaDynamics\n\n\nDynamicalBilliards\n is part of \nJuliaDynamics\n, check out our \nwebsite\n for more cool stuff!\n\n\n\n\n\n\nJulia Billiard logo animation\n\n\nCheck out the example in the \ntutorials\n page to see the code that created and animated the \"Julia Billiard\", which is the logo of our package!\n\n\n\n\n\n\nAbout Billiards\n\n\nA dynamical billiard is a system where a particle is propagating inside a domain, bouncing from obstacle to obstacle (i.e. the \nboundary\n of the domain) by a specular reflection at the boundary of the obstacles. This basic idea can be extended in many ways, one of which is replacing the particle orbit from a straight line to a circle.\n\n\nBilliard systems have been used extensively in mathematics, nonlinear dynamics and chaos and played an important role in the development of nonlinear science. The \nwikipedia page\n has many examples of different types of billiards. Also, the \nscholarpedia\n entry is a good read on the subject.\n\n\n\n\nFeatures\n\n\n\n\nModular creation of a \nbilliard\n from well defined obstacles. Arbitrary billiard shapes can be made and no shape is \"hard coded\".\n\n\n\n\nFull support for both \nstraight\n  and \nmagnetic\n propagation of a particle in a billiard table.\n\n\n\n\nDuring magnetic propagation the particle orbit is a circle instead of a line!\n\n\nAll features exist for both types of propagation!\n\n\nSee the \nhigh level API\n to get started!\n\n\n\n\n\n\n\n\nSupport for creating \nrandom initial conditions\n in an arbitrary billiard.\n\n\n\n\nRay-splitting implementation\n: a particle may propagate through an obstacle given arbitrary transmission and refraction laws. This is also known as a \"semiclassical billiard\".\n\n\nPoincar\u00e9 surfaces of section\n (intersections with arbitrary plane).\n\n\nBoundary maps\n.\n\n\nEscape times\n \n \nmean collision times\n.\n\n\nLyapunov exponents\n.\n\n\nSupport for both \ncoordinate systems\n: 3D real space and boundary coordinates.\n\n\nNovel algorithms that compute the portion of either the 2D boundary space or the 3D real space that an orbit covers as a particle evolves. See the \nphase spaces\n section.\n\n\nEasy to use \nlow-level interface\n.\n\n\nSpecialized tools for \nmushroom billiards\n.\n\n\nFull support for \nvisualizing and animating\n billiards and motion in billiards.\n\n\nBrutal tests that confirm the package works and overcomes numerical precision issues.\n\n\n\n\nThis package does not support finite-sized particles and, as a result, there is also no support for collision between particles.\n\n\n\n\nHow to easily code a Billiard\n\n\nWe have created a \nJupyter notebook\n that showcases how easy it is to simulate a dynamical billiard using Julia. This \nnotebook\n is an educative example of both using Multiple Dispatch and of how the internal code of \nDynamicalBilliards\n works. It also highlights the extendibility of the core code.\n\n\nIf you are interested in learning idiomatic Julia code and understanding the source code of our package, we highly recommend taking a look at this \nnotebook\n.\n\n\n\n\nCiting\n\n\nIf you have used this package for research that resulted in a publication, please be kind enough to cite the paper associated with \nDynamicalBilliards\n. The DOI is https://doi.org/10.21105/joss.00458 and you can cite as:\n\n\n\n\nG. Datseris, [The Journal of Open Source Software \n2\n, 458\n\n\n\n\n(2017)](https://doi.org/10.21105/joss.00458).\n\n\nor if you use BibTeX:\n\n\n@article{Datseris2017,\n  doi = {10.21105/joss.00458},\n  url = {https://doi.org/10.21105/joss.00458},\n  year  = {2017},\n  month = {nov},\n  volume = {2},\n  number = {19},\n  pages = {458},\n  author = {George Datseris},\n  title = {{DynamicalBilliards}.jl: An easy-to-use,  modular and extendable Julia package for Dynamical Billiard systems in two dimensions.},\n  journal = {The Journal of Open Source Software}\n}\n\n\n\n\n\n\n\nInstallation\n\n\nThis package is registered, simply use \n]\n to get into the package manager mode and then type \nadd DynamicalBilliards\n to install it. The \nstable documentation\n accompanies the version installed with \nadd\n.\n\n\nTo confirm the validity of your installation you can run the tests of \nDynamicalBilliards\n. This can be done via \n] test DynamicalBilliards\n.\n\n\n\n\nPlotting\n\n\nPlotting is done through the \nPyPlot\n module. All plotting functions are brought into scope when \nusing PyPlot\n is done.\n\n\nIn addition, for animations using the function \nanimate_evolution\n the \nffmpeg\n software must be accessible from the command line.\n\n\n\n\n\n\nSupport\n\n\nIf you are having any kind of problems with \nDynamicalBilliards\n do not hesitate to seek for support! There are numerous ways to do that:\n\n\n\n\nVisit our \nofficial chatroom\n on Gitter: https://gitter.im/JuliaDynamics/Lobby\n\n\nOpen a new issue at our \nGitHub issues page\n.\n\n\n\n\n\n\n\n\nContributing\n\n\nEveryone is welcomed to contribute to \nDynamicalBilliards\n! If you have some new algorithm, types of Obstacles or anything new to add, do not hesitate! For formal questions about e.g. structuring of code it is best to contact us through the \ngitter chatroom\n or by opening a new Pull Request and asking for a review of your code.\n\n\nIf you would like to help but do not have anything new to contribute, please go ahead and take a look at the \nGitHub issues page\n of the package. Some of the existing issues are easy to solve and are there specifically for people that would like to contribute.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#about-billiards", 
            "text": "A dynamical billiard is a system where a particle is propagating inside a domain, bouncing from obstacle to obstacle (i.e. the  boundary  of the domain) by a specular reflection at the boundary of the obstacles. This basic idea can be extended in many ways, one of which is replacing the particle orbit from a straight line to a circle.  Billiard systems have been used extensively in mathematics, nonlinear dynamics and chaos and played an important role in the development of nonlinear science. The  wikipedia page  has many examples of different types of billiards. Also, the  scholarpedia  entry is a good read on the subject.", 
            "title": "About Billiards"
        }, 
        {
            "location": "/#features", 
            "text": "Modular creation of a  billiard  from well defined obstacles. Arbitrary billiard shapes can be made and no shape is \"hard coded\".   Full support for both  straight   and  magnetic  propagation of a particle in a billiard table.   During magnetic propagation the particle orbit is a circle instead of a line!  All features exist for both types of propagation!  See the  high level API  to get started!     Support for creating  random initial conditions  in an arbitrary billiard.   Ray-splitting implementation : a particle may propagate through an obstacle given arbitrary transmission and refraction laws. This is also known as a \"semiclassical billiard\".  Poincar\u00e9 surfaces of section  (intersections with arbitrary plane).  Boundary maps .  Escape times     mean collision times .  Lyapunov exponents .  Support for both  coordinate systems : 3D real space and boundary coordinates.  Novel algorithms that compute the portion of either the 2D boundary space or the 3D real space that an orbit covers as a particle evolves. See the  phase spaces  section.  Easy to use  low-level interface .  Specialized tools for  mushroom billiards .  Full support for  visualizing and animating  billiards and motion in billiards.  Brutal tests that confirm the package works and overcomes numerical precision issues.   This package does not support finite-sized particles and, as a result, there is also no support for collision between particles.", 
            "title": "Features"
        }, 
        {
            "location": "/#how-to-easily-code-a-billiard", 
            "text": "We have created a  Jupyter notebook  that showcases how easy it is to simulate a dynamical billiard using Julia. This  notebook  is an educative example of both using Multiple Dispatch and of how the internal code of  DynamicalBilliards  works. It also highlights the extendibility of the core code.  If you are interested in learning idiomatic Julia code and understanding the source code of our package, we highly recommend taking a look at this  notebook .", 
            "title": "How to easily code a Billiard"
        }, 
        {
            "location": "/#citing", 
            "text": "If you have used this package for research that resulted in a publication, please be kind enough to cite the paper associated with  DynamicalBilliards . The DOI is https://doi.org/10.21105/joss.00458 and you can cite as:   G. Datseris, [The Journal of Open Source Software  2 , 458   (2017)](https://doi.org/10.21105/joss.00458).  or if you use BibTeX:  @article{Datseris2017,\n  doi = {10.21105/joss.00458},\n  url = {https://doi.org/10.21105/joss.00458},\n  year  = {2017},\n  month = {nov},\n  volume = {2},\n  number = {19},\n  pages = {458},\n  author = {George Datseris},\n  title = {{DynamicalBilliards}.jl: An easy-to-use,  modular and extendable Julia package for Dynamical Billiard systems in two dimensions.},\n  journal = {The Journal of Open Source Software}\n}", 
            "title": "Citing"
        }, 
        {
            "location": "/#installation", 
            "text": "This package is registered, simply use  ]  to get into the package manager mode and then type  add DynamicalBilliards  to install it. The  stable documentation  accompanies the version installed with  add .  To confirm the validity of your installation you can run the tests of  DynamicalBilliards . This can be done via  ] test DynamicalBilliards .", 
            "title": "Installation"
        }, 
        {
            "location": "/#plotting", 
            "text": "Plotting is done through the  PyPlot  module. All plotting functions are brought into scope when  using PyPlot  is done.  In addition, for animations using the function  animate_evolution  the  ffmpeg  software must be accessible from the command line.", 
            "title": "Plotting"
        }, 
        {
            "location": "/#support", 
            "text": "If you are having any kind of problems with  DynamicalBilliards  do not hesitate to seek for support! There are numerous ways to do that:   Visit our  official chatroom  on Gitter: https://gitter.im/JuliaDynamics/Lobby  Open a new issue at our  GitHub issues page .", 
            "title": "Support"
        }, 
        {
            "location": "/#contributing", 
            "text": "Everyone is welcomed to contribute to  DynamicalBilliards ! If you have some new algorithm, types of Obstacles or anything new to add, do not hesitate! For formal questions about e.g. structuring of code it is best to contact us through the  gitter chatroom  or by opening a new Pull Request and asking for a review of your code.  If you would like to help but do not have anything new to contribute, please go ahead and take a look at the  GitHub issues page  of the package. Some of the existing issues are easy to solve and are there specifically for people that would like to contribute.", 
            "title": "Contributing"
        }, 
        {
            "location": "/basic/high_level/", 
            "text": "High Level API\n\n\nDynamicalBilliards\n was created with ease-of-use as its main cornerstone. With 3 simple steps, the user can get the output of the propagation of a particle in a billiard.\n\n\nIn general, the workflow of \nDynamicalBilliards\n follows these simple steps:\n\n\n\n\nCreate a billiard.\n\n\nCreate particles inside that billiard.\n\n\nGet the output you want by using one of the high level functions.\n\n\n\n\nAdding more complexity in your billiard does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a \nRaySplitter\n and pass it to the high level functions.\n\n\nAfter reading through this page, you will be able to use almost all aspects of \nDynamicalBilliards\n with minimal effort.\n\n\n\n\nVisualizations\n\n\nVisualizing the billiards, particles and their motion is one of the most important parts of the \nDynamicalBilliards\n. It is not discussed in this page however, but rather in the \nVisualizing\n page.\n\n\n\n\n\n\n\n\nBilliard\n\n\nA \nBilliard\n is simply a collection of \nObstacle\n subtypes. Particles are propagating inside a \nBilliard\n, bouncing from obstacle to obstacle while having constant velocity in-between.\n\n\nThere is a \ntutorial\n on how to create your own billiard. In addition, there are many pre-defined billiards that can be found in the \nStandard Billiards Library\n section. That is why knowing how to construct a \nBilliard\n is not important at this point.\n\n\nIn this page we will be using the Bunimovich billiard as an example:\n\n\nusing\n \nDynamicalBilliards\n\n\nbd\n \n=\n \nbilliard_bunimovich\n()\n\n\n\n\n\n\nBilliard{Float64} with 4 obstacles:\n  Bottom wall\n  Right semicircle\n  Top wall\n  Left semicircle\n\n\n\n\n\n\n\nParticles\n\n\nA \"particle\" is that thingy that moves around in the billiard. It always moves with velocity of measure 1, by convention.\n\n\nCurrently there are two types of particles:\n\n\n\n\nParticle\n, which propagates as a straight line.\n\n\nMagneticParticle\n, which propagates as a circle instead of a line (similar to electrons in a perpendicular magnetic field).\n\n\n\n\nThere are two ways to create a particle. The first one is to provide the constructor with some initial conditions:\n\n\nx0\n \n=\n \nrand\n();\n \ny0\n \n=\n \nrand\n();\n\n\n\u03c60\n \n=\n \n2\n\u03c0\n*\nrand\n()\n\n\np\n \n=\n \nParticle\n(\nx0\n,\n \ny0\n,\n \n\u03c60\n)\n\n\n\n\n\n\nParticle{Float64}\nposition: [0.880973, 0.0220769]\nvelocity: [-0.975532, -0.219857]\n\n\n\n\n\nTo create a \nMagneticParticle\n simply provide the constructor with one more number, the angular velocity:\n\n\n\u03c9\n \n=\n \n0.5\n\n\nmp\n \n=\n \nMagneticParticle\n(\nx0\n,\n \ny0\n,\n \n\u03c60\n,\n \n\u03c9\n)\n\n\n\n\n\n\nMagneticParticle{Float64}\nposition: [0.880973, 0.0220769]\nvelocity: [-0.975532, -0.219857]\nang. velocity: 0.5\n\n\n\n\n\n\n\nWhy the \n{Float64}\n ?\n\n\nWhen creating a billiard or a particle, the object is printed with \n{Float64}\n at the end. This shows what type of numbers are used for \nall\n numerical operations. If you are curious you can learn more about it in the \nnumerical precision page\n.\n\n\n\n\n\n\nParticles must be inside the Billiard!\n\n\nKeep in mind that the particle must be initialized \ninside a billiard\n for any functionality to work properly and make sense. If you are not sure what we mean by that, then you should check out the \nInternals page\n.\n\n\n\n\n\n\nRandom initial conditions\n\n\nIf you have a \nBilliard\n which is not a rectangle, creating many random initial conditions inside it can be a pain. Fortunately, the second way to create a particle is to use the following function:\n\n\n#\n\n\nDynamicalBilliards.randominside\n \n \nFunction\n.\n\n\nrandominside(bd::Billiard [, \u03c9])\n\n\n\n\n\nReturn a particle with random allowed initial conditions inside the given billiard. If supplied with a second argument the type of the returned particle is \nMagneticParticle\n, with angular velocity \n\u03c9\n.\n\n\nsource\n\n\n\n\nFor example:\n\n\np\n \n=\n \nrandominside\n(\nbd\n)\n\n\n\n\n\n\nParticle{Float64}\nposition: [0.038848, 0.654178]\nvelocity: [0.915616, 0.402055]\n\n\n\n\n\nand\n\n\nmp\n \n=\n \nrandominside\n(\nbd\n,\n \n\u03c9\n)\n\n\n\n\n\n\nMagneticParticle{Float64}\nposition: [0.948562, 0.135134]\nvelocity: [-0.998558, -0.053677]\nang. velocity: 0.5\n\n\n\n\n\nrandominside\n always creates particles with same number type as the billiard.\n\n\n\n\nevolve\n \n \ntimeseries\n\n\nNow that we have created a billiard and a particle inside, we want to evolve it! There is a simple function for that, called \nevolve!\n (or \nevolve\n if you don't want to mutate the particle), which returns the time, position and velocities at the collision points:\n\n\n#\n\n\nDynamicalBilliards.evolve!\n \n \nFunction\n.\n\n\nevolve!([p::AbstractParticle,] bd::Billiard, t)\n\n\n\n\n\nEvolve the given particle \np\n inside the billiard \nbd\n. If \nt\n is of type \nAbstractFloat\n, evolve for as much time as \nt\n. If however \nt\n is of type \nInt\n, evolve for as many collisions as \nt\n. Return the states of the particle between collisions.\n\n\nThis function mutates the particle, use \nevolve\n otherwise. If a particle is not given, a random one is picked through \nrandominside\n.\n\n\nReturn\n\n\n\n\nct::Vector{T}\n : Collision times.\n\n\nposs::Vector{SVector{2,T}}\n : Positions at the collisions.\n\n\nvels::Vector{SVector{2,T}})\n : Velocities exactly after the collisions.\n\n\n\u03c9\n, either \nT\n or \nVector{T}\n : Angular velocity/ies (returned only for magnetic particles).\n\n\n\n\nThe time \nct[i+1]\n is the time necessary to reach state \nposs[i+1], vels[i+1]\n starting from the state \nposs[i], vels[i]\n. That is why \nct[1]\n is always 0 since \nposs[1], vels[1]\n are the initial conditions. The angular velocity \n\u03c9[i]\n is the one the particle has while propagating from state \nposs[i], vels[i]\n to \ni+1\n.\n\n\nNotice that at any point, the velocity vector \nvels[i]\n is the one obdained \nafter\n the specular reflection of the \ni-1\nth collision.\n\n\nRay-splitting billiards\n\n\nevolve!(p, bd, t, raysplitters)\n\n\n\n\n\nTo implement ray-splitting, the \nevolve!\n function is supplemented with a fourth argument, \nraysplitters\n which is a tuple of \nRaySplitter\n instances. Notice that \nevolve\n \nalways mutates the billiard\n if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.\n\n\nsource\n\n\n\n\nForget the ray-splitting part for now (see \nRay-Splitting\n).\n\n\nLet's see an example:\n\n\nct\n,\n \nposs\n,\n \nvels\n \n=\n \nevolve\n(\np\n,\n \nbd\n,\n \n100\n)\n\n\nfor\n \ni\n \nin\n \n1\n:\n5\n\n  \nprintln\n(\nround\n(\nct\n[\ni\n],\n \ndigits\n=\n3\n),\n \n  \n,\n \nposs\n[\ni\n],\n \n  \n,\n \nvels\n[\ni\n])\n\n\nend\n\n\n\n\n\n\n0.0  [0.038848, 0.654178]  [0.915616, 0.402055]\n0.86  [0.826403, 1.0]  [0.915616, -0.402055]\n0.675  [1.44474, 0.728482]  [-0.206385, -0.978471]\n0.631  [1.31458, 0.111358]  [-0.999998, 0.00199848]\n1.633  [-0.318565, 0.114622]  [-0.190093, 0.981766]\n\n\n\n\n\nSimilarly, for magnetic propagation\n\n\nct\n,\n \nposs\n,\n \nvels\n,\n \n\u03c9\n \n=\n \nevolve\n(\nmp\n,\n \nbd\n,\n \n100\n)\n\n\nfor\n \ni\n \nin\n \n1\n:\n10\n\n  \nprintln\n(\nround\n(\nct\n[\ni\n],\n \ndigits\n=\n3\n),\n \n  \n,\n \nposs\n[\ni\n],\n \n  \n,\n \nvels\n[\ni\n])\n\n\nend\n\n\n\n\n\n\n0.0  [0.948562, 0.135134]  [-0.998558, -0.053677]\n0.64  [0.325833, 0.0]  [-0.930991, 0.365042]\n0.687  [-0.343962, 0.137109]  [-0.0835968, 0.9965]\n0.557  [-0.466871, 0.678973]  [0.888719, 0.458453]\n0.557  [-0.0132447, 0.999825]  [0.763563, -0.645734]\n1.625  [1.49847, 0.539114]  [-0.99893, -0.0462516]\n1.414  [0.222739, 0.0]  [-0.729373, 0.684116]\n0.845  [-0.495445, 0.432665]  [0.824659, 0.56563]\n0.796  [0.0553505, 1.0]  [0.540992, -0.841028]\n1.588  [1.32959, 0.124004]  [-0.0739231, 0.997264]\n\n\n\n\n\nThe above return types are helpful in some applications. In other applications however one prefers to have the time series of the individual variables. For this, the \ntimeseries\n function is used:\n\n\n#\n\n\nDynamicalBilliards.timeseries!\n \n \nFunction\n.\n\n\ntimeseries\n!(\n[\np\n::AbstractParticle\n,\n]\n \nbd\n::\nBilliard\n,\n \nt\n;\n \ndt\n,\n \nwarning\n)\n\n\n\n\n\n\nEvolves the given particle \np\n inside the billiard \nbd\n.  If \nt\n is of type \nAbstractFloat\n, evolve for as much time as \nt\n. If however \nt\n is of type \nInt\n, evolve for as many collisions as \nt\n. Returns the time series for position and velocity as well as the time vector.\n\n\nThis function mutates the particle, use \ntimeseries\n otherwise. If a particle is not given, a random one is picked through \nrandominside\n.\n\n\nThe keyword argument \ndt\n is the time step used for interpolating the time series in between collisions. \ndt\n is capped by the collision time, as the interpolation \nalways\n stops at collisions. For straight propagation \ndt = Inf\n, while for magnetic \ndt = 0.01\n.\n\n\nFor pinned magnetic particles, \ntimeseries!\n issues a warning and returns the trajectory of the particle. If \nt\n is integer, the trajectory is evolved for one full circle only\n\n\nReturn:\n\n\n\n\nx position time-series\n\n\ny position time-series\n\n\nx velocity time-series\n\n\ny velocity time-series\n\n\ntime vector\n\n\n\n\nRay-splitting billiards\n\n\ntimeseries!(p, bd, t, raysplitters; ...)\n\n\n\n\n\nTo implement ray-splitting, the \ntimeseries!\n function is supplemented with a fourth argument, \nraysplitters\n which is a tuple of \nRaySplitter\n instances. Notice that \ntimeseries\n \nalways mutates the billiard\n if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.\n\n\nsource\n\n\n\n\nFor example:\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \ntimeseries\n(\np\n,\n \nbd\n,\n \n100\n)\n\n\n\n# print as a matrix:\n\n\nhcat\n(\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n)[\n1\n:\n5\n,\n \n:\n]\n\n\n\n\n\n\n5\u00d75 Array{Float64,2}:\n  0.038848  0.654178   0.915616   0.402055    0.0\n  0.826403  1.0        0.915616  -0.402055    0.860137\n  1.44474   0.728482  -0.206385  -0.978471    0.675326\n  1.31458   0.111358  -0.999998   0.00199848  0.630702\n -0.318565  0.114622  -0.190093   0.981766    1.63314\n\n\n\n\n\nSame story for magnetic particles:\n\n\n# evolve the magnetic particle instead:\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \ntimeseries\n(\nmp\n,\n \nbd\n,\n \n100\n)\n\n\n\n# print as a matrix:\n\n\nhcat\n(\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n)[\n1\n:\n5\n,\n \n:\n]\n\n\n\n\n\n\n5\u00d75 Array{Float64,2}:\n 0.948562  0.135134  -0.998558  -0.053677   0.0\n 0.938578  0.134573  -0.998277  -0.0586691  0.01\n 0.928597  0.133961  -0.997972  -0.0636597  0.02\n 0.918619  0.1333    -0.997641  -0.0686488  0.03\n 0.908644  0.132588  -0.997285  -0.0736361  0.04\n\n\n\n\n\n\n\nType of \nt\n\n\nRemember that the behavior of \nevolve!\n depends on the type of the third argument, which represents \"total amount\". If it is \nAbstractFloat\n, it represents total amount of time, but if it is \nInt\n it represents total number of collisions.\n\n\n\n\n\n\nPoincar\u00e9 Sections\n\n\n#\n\n\nDynamicalBilliards.psos\n \n \nFunction\n.\n\n\npsos(bd::Billiard, plane::InfiniteWall, t, particles)\n\n\n\n\n\nCompute the Poincar\u00e9 section of the \nparticles\n with the given \nplane\n, by evolving each one for time \nt\n (either integer or float) inside \nbd\n.\n\n\nThe \nplane\n can be an \nInfiniteWall\n of \nany\n orientation, however only crossings of the \nplane\n such that \ndot(velocity, normal) \n 0\n are allowed, with \nnormal\n the normal unit vector of the \nplane\n.\n\n\nparticles\n can be:\n\n\n\n\nA single particle.\n\n\nA \nVector\n of particles.\n\n\nAn integer \nn\n optionally followed by an angular velocity \n\u03c9\n.\n\n\n\n\nReturn the positions \nposs\n and velocities \nvels\n at the instances of crossing the \nplane\n. If given more than one particle, the result is a vector of vectors of vectors.\n\n\nNotice\n - This function can handle pinned particles. If a pinned particle can intersect with the \nplane\n, then an intersection is returned. If however it can't then empty vectors are returned.\n\n\nsource\n\n\n\n\nFor example, the surface of section in the periodic Sinai billiard with magnetic field reveals the mixed nature of the phase-space:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\nt\n \n=\n \n100\n;\n \nr\n \n=\n \n0.15\n\n\nbd\n \n=\n \nbilliard_sinai\n(\nr\n,\n \nsetting\n \n=\n \nperiodic\n)\n\n\n\n# the direction of the normal vector is IMPORTANT!!!\n\n\n# (always keep in mind that \u03c9 \n 0  means counter-clockwise rotation!)\n\n\nplane\n \n=\n \nInfiniteWall\n([\n0.5\n,\n \n0.0\n],\n \n[\n0.5\n,\n \n1.0\n],\n \n[\n-\n1.0\n,\n \n0.0\n])\n\n\n\nposvector\n,\n \nvelvector\n \n=\n \npsos\n(\nbd\n,\n \nplane\n,\n \nt\n,\n \n1000\n,\n \n2.0\n)\n\n\nc\n(\na\n)\n \n=\n \nlength\n(\na\n)\n \n==\n \n1\n \n?\n \nC1\n \n:\n \nC0\n\n\n\nfigure\n()\n\n\nfor\n \ni\n \nin\n \n1\n:\nlength\n(\nposvector\n)\n\n    \nposs\n \n=\n \nposvector\n[\ni\n]\n \n# vector of positions\n\n    \nvels\n \n=\n \nvelvector\n[\ni\n]\n \n# vector of velocities at the section\n\n    \nL\n \n=\n \nlength\n(\nposs\n)\n\n    \nif\n \nL\n \n \n0\n\n        \n#plot y vs vy\n\n        \ny\n \n=\n \n[\na\n[\n2\n]\n \nfor\n \na\n \nin\n \nposs\n]\n\n        \nvy\n \n=\n \n[\na\n[\n2\n]\n \nfor\n \na\n \nin\n \nvels\n]\n\n\n        \nplot\n(\ny\n,\n \nvy\n,\n \nls\n \n=\n \nNone\n,\n \ncolor\n \n=\n \nc\n(\ny\n),\n \nms\n \n=\n \n2.0\n,\n \nalpha\n \n=\n \n0.75\n,\n \nmarker\n \n=\n \no\n)\n\n    \nend\n\n\nend\n\n\nxlabel\n(\n\\$\ny\n\\$\n);\n \nylabel\n(\n\\$\nv_y\n\\$\n)\n\n\n\n\n\n\n\n\n\n\npsos\n operates on the unit cell\n\n\nThe \npsos\n function always calculates the crossings \nwithin\n the unit cell of a periodic billiard. This means that no information about the \"actual\" position of the particle is stored, everything is modulo the unit cell.\n\n\nThis can be seen very well in the above example, where there aren't any entries in the region \n0.5 - r \u2264 y \u2264 0.5 + r\n.\n\n\n\n\nOf course it is very easy to \"re-normalize\" the result such that it is coherent. The only change we have to do is simply replace the line \ny = [a[2] for a in poss]\n with\n\n\ny\n \n=\n \n[\na\n[\n2\n]\n \n \n0.5\n \n?\n \na\n[\n2\n]\n \n+\n \n1\n \n:\n \na\n[\n2\n]\n  \nfor\n \na\n \nin\n \nposs\n]\n\n\n\n\n\n\n\n\nEscape Times\n\n\nIt is very easy to create your own function that calculates an \"escape time\": the time until the particle leaves the billiard by meeting a specified condition. There is also a high-level function for this though:\n\n\n#\n\n\nDynamicalBilliards.escapetime\n \n \nFunction\n.\n\n\nescapetime([p,] bd, t; warning = false)\n\n\n\n\n\nCalculate the escape time of a particle \np\n in the billiard \nbd\n, which is the time until colliding with any \"door\" in \nbd\n. As a \"door\" is considered any \nFiniteWall\n with field \nisdoor = true\n.\n\n\nIf the particle evolves for more than \nt\n (integer or float) without colliding with the \nDoor\n (i.e. escaping) the returned result is \nInf\n.\n\n\nA warning can be thrown if the result is \nInf\n. Enable this using the keyword \nwarning = true\n.\n\n\nIf a particle is not given, a random one is picked through \nrandominside\n. See \nparallelize\n for a parallelized version.\n\n\nsource\n\n\n\n\nCreating a door\n\n\nTo create a \"door\" simply visit the \nlibrary page\n to learn more about the individual obstacle types (specifically \nFiniteWall\n). To be able to combine them into a \nBilliard\n you should also check out the tutorial on \ndefining your own billiard\n.\n\n\n\n\nFor example, the default implementation of the mushroom billiard has a \"door\" at the bottom of the stem. Thus,\n\n\nusing\n \nStatistics\n\n\nbd\n \n=\n \nbilliard_mushroom\n()\n\n\net\n \n=\n \nzeros\n(\n100\n)\n\n\nfor\n \ni\n \n\u2208\n \n1\n:\n100\n\n    \nparticle\n \n=\n \nrandominside\n(\nbd\n)\n\n    \net\n[\ni\n]\n \n=\n \nescapetime\n(\nparticle\n,\n \nbd\n,\n \n10000\n)\n\n\nend\n\n\nprintln\n(\nOut of 100 particles, \n$\n(\ncount\n(\nx\n-\n \nx\n \n!=\n \nInf\n,\n \net\n))\n escaped\n)\n\n\nprintln\n(\nMean escape time was \n$\n(\nmean\n(\net\n[\net\n \n.!=\n \nInf\n]))\n)\n\n\n\n\n\n\nOut of 100 particles, 20 escaped\nMean escape time was 3.8881125805238144\n\n\n\n\n\nOf course, \nescapetime\n works with \nMagneticParticle\n as well\n\n\nescapetime\n(\nrandominside\n(\nbd\n,\n \n1.0\n),\n \nbd\n,\n \n10000\n)\n\n\n\n\n\n\n113.20014708776995\n\n\n\n\n\n\n\nMean Collision Times\n\n\nBecause the computation of a mean collision time (average time between collisions in a billiard) is often a useful quantity, the following function computes it\n\n\n#\n\n\nDynamicalBilliards.meancollisiontime\n \n \nFunction\n.\n\n\nmeancollisiontime([p,] bd, t) \u2192 \u03ba\n\n\n\n\n\nCompute the mean collision time \n\u03ba\n of the particle \np\n in the billiard \nbd\n by evolving for total amount \nt\n (either float for time or integer for collision number).\n\n\nCollision times are counted only between obstacles that are \nnot\n \nPeriodicWall\n.\n\n\nIf a particle is not given, a random one is picked through \nrandominside\n. See \nparallelize\n for a parallelized version.\n\n\nsource\n\n\nFor example,\n\n\nbd\n \n=\n \nbilliard_sinai\n()\n\n\nmeancollisiontime\n(\nrandominside\n(\nbd\n),\n \nbd\n,\n \n10000.0\n)\n\n\n\n\n\n\n0.4527977399765889\n\n\n\n\n\n\n\nParallelization\n\n\n#\n\n\nDynamicalBilliards.parallelize\n \n \nFunction\n.\n\n\nparallelize\n(\nf\n,\n \nbd\n::\nBilliard\n,\n \nt\n,\n \nparticles\n;\n \npartype\n \n=\n \n:\nthreads\n)\n\n\n\n\n\n\nParallelize function \nf\n across the available particles. The parallelization type can be \n:threads\n or \n:pmap\n, which use threads or a worker pool initialized with \naddprocs\n \nbefore\n \nusing DynamicalBilliards\n.\n\n\nparticles\n can be:\n\n\n\n\nA \nVector\n of particles.\n\n\nAn integer \nn\n optionally followed by an angular velocity \n\u03c9\n. This uses \nrandominside\n.\n\n\n\n\nThe functions usable here are:\n\n\n\n\nmeancollisiontime\n\n\nescapetime\n\n\nlyapunovspectrum\n (returns only the maximal exponents)\n\n\nboundarymap\n (returns vector of vectors of 2-vectors \nand\n \narcintervals\n)\n\n\n\n\nsource\n\n\n\n\nHere are some examples\n\n\nbd\n \n=\n \nbilliard_stadium\n()\n\n\nparticles\n \n=\n \n[\nrandominside\n(\nbd\n)\n \nfor\n \ni\n \nin\n \n1\n:\n1000\n]\n\n\nparallelize\n(\nmeancollisiontime\n,\n \nbd\n,\n \n1000\n,\n \nparticles\n)\n\n\n\n\n\n\n1000-element Array{Float64,1}:\n 1.033275725102876\n 1.0764263141507806\n 1.0893951878350467\n 1.0760898390898481\n 1.0716702420929383\n 1.097868859926868\n 1.1145152590125753\n 1.0843808478896486\n 1.093027900061257\n 1.0558866936531512\n \u22ee\n 1.0996077777135995\n 1.101143601438325\n 1.093637580020895\n 1.1142043995282398\n 1.1003694082296218\n 1.0918468530409204\n 1.1054947355616762\n 1.03590632934719\n 1.1055415909958775\n\n\n\n\n\nparallelize\n(\nlyapunovspectrum\n,\n \nbd\n,\n \n1000\n,\n \nparticles\n)\n\n\n\n\n\n\n1000-element Array{Float64,1}:\n 0.7191804683739932\n 0.8915161531119421\n 0.9243608176719682\n 0.8778835507078612\n 0.8734528560484212\n 0.800556715770099\n 0.8754138667639091\n 0.939409968626747\n 0.909752551541436\n 0.7819268504043572\n \u22ee\n 0.8598287148547583\n 0.894915064232914\n 0.8826955731919575\n 0.8806918634939603\n 0.8849636276267762\n 0.8191055171845738\n 0.8490040497275966\n 0.9504621101927881\n 0.8717917922652306\n\n\n\n\n\n\n\nIt's all about bounce!\n\n\nThe main propagation algorithm used by \nDynamicalBilliards\n is bundled in the following well-behaving function:\n\n\n#\n\n\nDynamicalBilliards.bounce!\n \n \nFunction\n.\n\n\nbounce!(p::AbstractParticle, bd::Billiard) \u2192 i, t, pos, vel\n\n\n\n\n\n\"Bounce\" the particle (advance for one collision) in the billiard. Takes care of finite-precision issues.\n\n\nReturn:\n\n\n\n\nindex of the obstacle that the particle just collided with\n\n\nthe time from the previous collision until the current collision \nt\n\n\nposition and velocity of the particle at the current collision (\nafter\n the collision has been resolved!). The position is given in the unit cell of periodic billiards. Do \npos += p.current_cell\n for the position in real space.\n\n\n\n\nbounce!\n(\np\n,\n \nbd\n,\n \nraysplit\n)\n \n\u2192\n \ni\n,\n \nt\n,\n \npos\n,\n \nvel\n\n\n\n\n\n\nRay-splitting version of \nbounce!\n.\n\n\nsource\n\n\n\n\nbounce!\n is the function used internally by all high-level functions, like \nevolve!\n, \nboundarymap\n, \nescapetime\n, etc.\n\n\nThis is the function a user should use if they want to calculate other things besides what is already available in the high level API.\n\n\n\n\nStandard Billiards Library\n\n\n\n\nYou can also use keywords!\n\n\nAll standard billiards have a function version that accepts keyword arguments instead of positional arguments, for ease of use.\n\n\n\n\n#\n\n\nDynamicalBilliards.billiard_rectangle\n \n \nFunction\n.\n\n\nbilliard_rectangle(x=1.0, y=1.0; setting = \nstandard\n)\n\n\n\n\n\nReturn a vector of obstacles that defines a rectangle billiard of size (\nx\n, \ny\n).\n\n\nSettings\n\n\n\n\n\"standard\" : Specular reflection occurs during collision.\n\n\n\"periodic\" : The walls are \nPeriodicWall\n type, enforcing periodicity at the boundaries\n\n\n\"random\" : The velocity is randomized upon collision.\n\n\n\"ray-splitting\" : All obstacles in the billiard allow for ray-splitting.\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_sinai\n \n \nFunction\n.\n\n\nbilliard_sinai(r=0.25, x=1.0, y=1.0; setting = \nstandard\n)\n\n\n\n\n\nReturn a vector of obstacles that defines a Sinai billiard of size (\nx\n, \ny\n) with a disk in its center, of radius \nr\n.\n\n\nIn the periodic case, the system is also known as \"Lorentz Gas\".\n\n\nSettings\n\n\n\n\n\"standard\" : Specular reflection occurs during collision.\n\n\n\"periodic\" : The walls are \nPeriodicWall\n type, enforcing periodicity at the boundaries\n\n\n\"random\" : The velocity is randomized upon collision.\n\n\n\"ray-splitting\" : All obstacles in the billiard allow for ray-splitting.\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_bunimovich\n \n \nFunction\n.\n\n\nbilliard_bunimovich(l=1.0, w=1.0)\n\n\n\n\n\nReturn a vector of \nObstacle\ns that define a Buminovich billiard, also called a stadium. The length is considered \nwithout\n the attached semicircles, meaning that the full length of the billiard is \nl + w\n. The left and right edges of the stadium are \nSemicircle\ns.\n\n\nbilliard_stadium\n is an alias of \nbilliard_bunimovich\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_mushroom\n \n \nFunction\n.\n\n\nbilliard_mushroom(sl = 1.0, sw = 0.2, cr = 1.0, sloc = 0.0; door = true)\n\n\n\n\n\nCreate a mushroom billiard with stem length \nsl\n, stem width \nsw\n and cap radius \ncr\n. The center of the cap (which is Semicircle) is always at \n[0, sl]\n. The center of the stem is located at \nsloc\n.\n\n\nOptionally, the bottom-most \nWall\n is a \nDoor\n (see \nescapetime\n).\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_polygon\n \n \nFunction\n.\n\n\nbilliard_polygon\n(\nn\n::\nInt\n,\n \nR\n,\n \ncenter\n \n=\n \n[\n0\n,\n0\n]\n;\n \nsetting\n \n=\n \nstandard\n)\n\n\n\n\n\n\nReturn a vector of obstacles that defines a regular-polygonal billiard with \nn\n sides, radius \nr\n and given \ncenter\n.\n\n\nNote: \nR\n denotes the so-called outer radius, not the inner one.\n\n\nSettings\n\n\n\n\n\"standard\" : Specular reflection occurs during collision.\n\n\n\"periodic\" : The walls are \nPeriodicWall\n type, enforcing periodicity at the boundaries. Only available for \nn=4\n or \nn=6\n.\n\n\n\"random\" : The velocity is randomized upon collision.\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_hexagonal_sinai\n \n \nFunction\n.\n\n\nbilliard_hexagonal_sinai(r, R, center = [0,0]; setting = \nstandard\n)\n\n\n\n\n\nCreate a sinai-like billiard, which is a hexagon of outer radius \nR\n, containing at its center (given by \ncenter\n) a disk of radius \nr\n. The \nsetting\n keyword is passed to \nbilliard_polygon\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_raysplitting_showcase\n \n \nFunction\n.\n\n\nbilliard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -\n bd, rayspl\n\n\n\n\n\nShowcase example billiard for ray-splitting processes. A rectangle \n(x,y)\n with a SplitterWall at \nx/2\n and two disks at each side, with respective radii \nr1\n, \nr2\n.\n\n\nNotice\n: This function returns a billiard \nbd\n as well as a \nrayspl\n dictionary!\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_logo\n \n \nFunction\n.\n\n\nbilliard_logo(;h=1.0, \u03b1=0.8, r=0.18, off=0.25) -\n bd, ray\n\n\n\n\n\nCreate the billiard used as logo of \nDynamicalBilliards\n and return it along with the tuple of raysplitters.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.billiard_iris\n \n \nFunction\n.\n\n\nbilliard_iris(a=0.2, b=0.4, w=1.0; setting = \nstandard\n)\n\n\n\n\n\nReturn a billiard that is a square of side \nw\n enclosing at its center an ellipse with semi axes \na\n, \nb\n.\n\n\nsource\n\n\n\n\nParticle types\n\n\n#\n\n\nDynamicalBilliards.Particle\n \n \nType\n.\n\n\nParticle\n(\nic\n::\nVector\n{\nT\n})\n \n#where ic = [x0, y0, \u03c60]\n\n\nParticle\n(\nx0\n,\n \ny0\n,\n \n\u03c60\n)\n\n\nParticle\n(\npos\n::\nSVector\n,\n \nvel\n::\nSVector\n)\n\n\n\n\n\n\nCreate a particle with initial conditions \nx0, y0, \u03c60\n. It propagates as a straight line.\n\n\nThe field \ncurrent_cell\n shows at which cell of a periodic billiard is the particle currently located.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MagneticParticle\n \n \nType\n.\n\n\nMagneticParticle\n(\nic\n::\nAbstractVector\n{\nT\n},\n \n\u03c9\n::\nReal\n)\n \n# where ic = [x0, y0, \u03c60]\n\n\nMagneticParticle\n(\nx0\n,\n \ny0\n,\n \n\u03c60\n,\n \n\u03c9\n)\n\n\nMagneticParticle\n(\npos\n::\nSVector\n,\n \nvel\n::\nSVector\n,\n \n\u03c9\n)\n\n\nMagneticParticle\n(\np\n::\nAbstractParticle\n,\n \n\u03c9\n)\n\n\n\n\n\n\nCreate a \nmagnetic\n particle with initial conditions \nx0, y0, \u03c60\n and angular velocity \n\u03c9\n. It propagates as a circle instead of a line, with radius \n1/abs(\u03c9)\n.\n\n\nThe field \ncurrent_cell\n shows at which cell of a periodic billiard is the particle currently located.\n\n\nsource", 
            "title": "High Level API"
        }, 
        {
            "location": "/basic/high_level/#high-level-api", 
            "text": "DynamicalBilliards  was created with ease-of-use as its main cornerstone. With 3 simple steps, the user can get the output of the propagation of a particle in a billiard.  In general, the workflow of  DynamicalBilliards  follows these simple steps:   Create a billiard.  Create particles inside that billiard.  Get the output you want by using one of the high level functions.   Adding more complexity in your billiard does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a  RaySplitter  and pass it to the high level functions.  After reading through this page, you will be able to use almost all aspects of  DynamicalBilliards  with minimal effort.   Visualizations  Visualizing the billiards, particles and their motion is one of the most important parts of the  DynamicalBilliards . It is not discussed in this page however, but rather in the  Visualizing  page.", 
            "title": "High Level API"
        }, 
        {
            "location": "/basic/high_level/#billiard", 
            "text": "A  Billiard  is simply a collection of  Obstacle  subtypes. Particles are propagating inside a  Billiard , bouncing from obstacle to obstacle while having constant velocity in-between.  There is a  tutorial  on how to create your own billiard. In addition, there are many pre-defined billiards that can be found in the  Standard Billiards Library  section. That is why knowing how to construct a  Billiard  is not important at this point.  In this page we will be using the Bunimovich billiard as an example:  using   DynamicalBilliards  bd   =   billiard_bunimovich ()   Billiard{Float64} with 4 obstacles:\n  Bottom wall\n  Right semicircle\n  Top wall\n  Left semicircle", 
            "title": "Billiard"
        }, 
        {
            "location": "/basic/high_level/#particles", 
            "text": "A \"particle\" is that thingy that moves around in the billiard. It always moves with velocity of measure 1, by convention.  Currently there are two types of particles:   Particle , which propagates as a straight line.  MagneticParticle , which propagates as a circle instead of a line (similar to electrons in a perpendicular magnetic field).   There are two ways to create a particle. The first one is to provide the constructor with some initial conditions:  x0   =   rand ();   y0   =   rand ();  \u03c60   =   2 \u03c0 * rand ()  p   =   Particle ( x0 ,   y0 ,   \u03c60 )   Particle{Float64}\nposition: [0.880973, 0.0220769]\nvelocity: [-0.975532, -0.219857]  To create a  MagneticParticle  simply provide the constructor with one more number, the angular velocity:  \u03c9   =   0.5  mp   =   MagneticParticle ( x0 ,   y0 ,   \u03c60 ,   \u03c9 )   MagneticParticle{Float64}\nposition: [0.880973, 0.0220769]\nvelocity: [-0.975532, -0.219857]\nang. velocity: 0.5   Why the  {Float64}  ?  When creating a billiard or a particle, the object is printed with  {Float64}  at the end. This shows what type of numbers are used for  all  numerical operations. If you are curious you can learn more about it in the  numerical precision page .    Particles must be inside the Billiard!  Keep in mind that the particle must be initialized  inside a billiard  for any functionality to work properly and make sense. If you are not sure what we mean by that, then you should check out the  Internals page .", 
            "title": "Particles"
        }, 
        {
            "location": "/basic/high_level/#random-initial-conditions", 
            "text": "If you have a  Billiard  which is not a rectangle, creating many random initial conditions inside it can be a pain. Fortunately, the second way to create a particle is to use the following function:  #  DynamicalBilliards.randominside     Function .  randominside(bd::Billiard [, \u03c9])  Return a particle with random allowed initial conditions inside the given billiard. If supplied with a second argument the type of the returned particle is  MagneticParticle , with angular velocity  \u03c9 .  source   For example:  p   =   randominside ( bd )   Particle{Float64}\nposition: [0.038848, 0.654178]\nvelocity: [0.915616, 0.402055]  and  mp   =   randominside ( bd ,   \u03c9 )   MagneticParticle{Float64}\nposition: [0.948562, 0.135134]\nvelocity: [-0.998558, -0.053677]\nang. velocity: 0.5  randominside  always creates particles with same number type as the billiard.", 
            "title": "Random initial conditions"
        }, 
        {
            "location": "/basic/high_level/#evolve-timeseries", 
            "text": "Now that we have created a billiard and a particle inside, we want to evolve it! There is a simple function for that, called  evolve!  (or  evolve  if you don't want to mutate the particle), which returns the time, position and velocities at the collision points:  #  DynamicalBilliards.evolve!     Function .  evolve!([p::AbstractParticle,] bd::Billiard, t)  Evolve the given particle  p  inside the billiard  bd . If  t  is of type  AbstractFloat , evolve for as much time as  t . If however  t  is of type  Int , evolve for as many collisions as  t . Return the states of the particle between collisions.  This function mutates the particle, use  evolve  otherwise. If a particle is not given, a random one is picked through  randominside .  Return   ct::Vector{T}  : Collision times.  poss::Vector{SVector{2,T}}  : Positions at the collisions.  vels::Vector{SVector{2,T}})  : Velocities exactly after the collisions.  \u03c9 , either  T  or  Vector{T}  : Angular velocity/ies (returned only for magnetic particles).   The time  ct[i+1]  is the time necessary to reach state  poss[i+1], vels[i+1]  starting from the state  poss[i], vels[i] . That is why  ct[1]  is always 0 since  poss[1], vels[1]  are the initial conditions. The angular velocity  \u03c9[i]  is the one the particle has while propagating from state  poss[i], vels[i]  to  i+1 .  Notice that at any point, the velocity vector  vels[i]  is the one obdained  after  the specular reflection of the  i-1 th collision.  Ray-splitting billiards  evolve!(p, bd, t, raysplitters)  To implement ray-splitting, the  evolve!  function is supplemented with a fourth argument,  raysplitters  which is a tuple of  RaySplitter  instances. Notice that  evolve   always mutates the billiard  if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.  source   Forget the ray-splitting part for now (see  Ray-Splitting ).  Let's see an example:  ct ,   poss ,   vels   =   evolve ( p ,   bd ,   100 )  for   i   in   1 : 5 \n   println ( round ( ct [ i ],   digits = 3 ),      ,   poss [ i ],      ,   vels [ i ])  end   0.0  [0.038848, 0.654178]  [0.915616, 0.402055]\n0.86  [0.826403, 1.0]  [0.915616, -0.402055]\n0.675  [1.44474, 0.728482]  [-0.206385, -0.978471]\n0.631  [1.31458, 0.111358]  [-0.999998, 0.00199848]\n1.633  [-0.318565, 0.114622]  [-0.190093, 0.981766]  Similarly, for magnetic propagation  ct ,   poss ,   vels ,   \u03c9   =   evolve ( mp ,   bd ,   100 )  for   i   in   1 : 10 \n   println ( round ( ct [ i ],   digits = 3 ),      ,   poss [ i ],      ,   vels [ i ])  end   0.0  [0.948562, 0.135134]  [-0.998558, -0.053677]\n0.64  [0.325833, 0.0]  [-0.930991, 0.365042]\n0.687  [-0.343962, 0.137109]  [-0.0835968, 0.9965]\n0.557  [-0.466871, 0.678973]  [0.888719, 0.458453]\n0.557  [-0.0132447, 0.999825]  [0.763563, -0.645734]\n1.625  [1.49847, 0.539114]  [-0.99893, -0.0462516]\n1.414  [0.222739, 0.0]  [-0.729373, 0.684116]\n0.845  [-0.495445, 0.432665]  [0.824659, 0.56563]\n0.796  [0.0553505, 1.0]  [0.540992, -0.841028]\n1.588  [1.32959, 0.124004]  [-0.0739231, 0.997264]  The above return types are helpful in some applications. In other applications however one prefers to have the time series of the individual variables. For this, the  timeseries  function is used:  #  DynamicalBilliards.timeseries!     Function .  timeseries !( [ p ::AbstractParticle , ]   bd :: Billiard ,   t ;   dt ,   warning )   Evolves the given particle  p  inside the billiard  bd .  If  t  is of type  AbstractFloat , evolve for as much time as  t . If however  t  is of type  Int , evolve for as many collisions as  t . Returns the time series for position and velocity as well as the time vector.  This function mutates the particle, use  timeseries  otherwise. If a particle is not given, a random one is picked through  randominside .  The keyword argument  dt  is the time step used for interpolating the time series in between collisions.  dt  is capped by the collision time, as the interpolation  always  stops at collisions. For straight propagation  dt = Inf , while for magnetic  dt = 0.01 .  For pinned magnetic particles,  timeseries!  issues a warning and returns the trajectory of the particle. If  t  is integer, the trajectory is evolved for one full circle only  Return:   x position time-series  y position time-series  x velocity time-series  y velocity time-series  time vector   Ray-splitting billiards  timeseries!(p, bd, t, raysplitters; ...)  To implement ray-splitting, the  timeseries!  function is supplemented with a fourth argument,  raysplitters  which is a tuple of  RaySplitter  instances. Notice that  timeseries   always mutates the billiard  if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.  source   For example:  xt ,   yt ,   vxt ,   vyt ,   t   =   timeseries ( p ,   bd ,   100 )  # print as a matrix:  hcat ( xt ,   yt ,   vxt ,   vyt ,   t )[ 1 : 5 ,   : ]   5\u00d75 Array{Float64,2}:\n  0.038848  0.654178   0.915616   0.402055    0.0\n  0.826403  1.0        0.915616  -0.402055    0.860137\n  1.44474   0.728482  -0.206385  -0.978471    0.675326\n  1.31458   0.111358  -0.999998   0.00199848  0.630702\n -0.318565  0.114622  -0.190093   0.981766    1.63314  Same story for magnetic particles:  # evolve the magnetic particle instead:  xt ,   yt ,   vxt ,   vyt ,   t   =   timeseries ( mp ,   bd ,   100 )  # print as a matrix:  hcat ( xt ,   yt ,   vxt ,   vyt ,   t )[ 1 : 5 ,   : ]   5\u00d75 Array{Float64,2}:\n 0.948562  0.135134  -0.998558  -0.053677   0.0\n 0.938578  0.134573  -0.998277  -0.0586691  0.01\n 0.928597  0.133961  -0.997972  -0.0636597  0.02\n 0.918619  0.1333    -0.997641  -0.0686488  0.03\n 0.908644  0.132588  -0.997285  -0.0736361  0.04   Type of  t  Remember that the behavior of  evolve!  depends on the type of the third argument, which represents \"total amount\". If it is  AbstractFloat , it represents total amount of time, but if it is  Int  it represents total number of collisions.", 
            "title": "evolve &amp; timeseries"
        }, 
        {
            "location": "/basic/high_level/#poincare-sections", 
            "text": "#  DynamicalBilliards.psos     Function .  psos(bd::Billiard, plane::InfiniteWall, t, particles)  Compute the Poincar\u00e9 section of the  particles  with the given  plane , by evolving each one for time  t  (either integer or float) inside  bd .  The  plane  can be an  InfiniteWall  of  any  orientation, however only crossings of the  plane  such that  dot(velocity, normal)   0  are allowed, with  normal  the normal unit vector of the  plane .  particles  can be:   A single particle.  A  Vector  of particles.  An integer  n  optionally followed by an angular velocity  \u03c9 .   Return the positions  poss  and velocities  vels  at the instances of crossing the  plane . If given more than one particle, the result is a vector of vectors of vectors.  Notice  - This function can handle pinned particles. If a pinned particle can intersect with the  plane , then an intersection is returned. If however it can't then empty vectors are returned.  source   For example, the surface of section in the periodic Sinai billiard with magnetic field reveals the mixed nature of the phase-space:  using   DynamicalBilliards ,   PyPlot  t   =   100 ;   r   =   0.15  bd   =   billiard_sinai ( r ,   setting   =   periodic )  # the direction of the normal vector is IMPORTANT!!!  # (always keep in mind that \u03c9   0  means counter-clockwise rotation!)  plane   =   InfiniteWall ([ 0.5 ,   0.0 ],   [ 0.5 ,   1.0 ],   [ - 1.0 ,   0.0 ])  posvector ,   velvector   =   psos ( bd ,   plane ,   t ,   1000 ,   2.0 )  c ( a )   =   length ( a )   ==   1   ?   C1   :   C0  figure ()  for   i   in   1 : length ( posvector ) \n     poss   =   posvector [ i ]   # vector of positions \n     vels   =   velvector [ i ]   # vector of velocities at the section \n     L   =   length ( poss ) \n     if   L     0 \n         #plot y vs vy \n         y   =   [ a [ 2 ]   for   a   in   poss ] \n         vy   =   [ a [ 2 ]   for   a   in   vels ] \n\n         plot ( y ,   vy ,   ls   =   None ,   color   =   c ( y ),   ms   =   2.0 ,   alpha   =   0.75 ,   marker   =   o ) \n     end  end  xlabel ( \\$ y \\$ );   ylabel ( \\$ v_y \\$ )     psos  operates on the unit cell  The  psos  function always calculates the crossings  within  the unit cell of a periodic billiard. This means that no information about the \"actual\" position of the particle is stored, everything is modulo the unit cell.  This can be seen very well in the above example, where there aren't any entries in the region  0.5 - r \u2264 y \u2264 0.5 + r .   Of course it is very easy to \"re-normalize\" the result such that it is coherent. The only change we have to do is simply replace the line  y = [a[2] for a in poss]  with  y   =   [ a [ 2 ]     0.5   ?   a [ 2 ]   +   1   :   a [ 2 ]    for   a   in   poss ]", 
            "title": "Poincar\u00e9 Sections"
        }, 
        {
            "location": "/basic/high_level/#escape-times", 
            "text": "It is very easy to create your own function that calculates an \"escape time\": the time until the particle leaves the billiard by meeting a specified condition. There is also a high-level function for this though:  #  DynamicalBilliards.escapetime     Function .  escapetime([p,] bd, t; warning = false)  Calculate the escape time of a particle  p  in the billiard  bd , which is the time until colliding with any \"door\" in  bd . As a \"door\" is considered any  FiniteWall  with field  isdoor = true .  If the particle evolves for more than  t  (integer or float) without colliding with the  Door  (i.e. escaping) the returned result is  Inf .  A warning can be thrown if the result is  Inf . Enable this using the keyword  warning = true .  If a particle is not given, a random one is picked through  randominside . See  parallelize  for a parallelized version.  source   Creating a door  To create a \"door\" simply visit the  library page  to learn more about the individual obstacle types (specifically  FiniteWall ). To be able to combine them into a  Billiard  you should also check out the tutorial on  defining your own billiard .   For example, the default implementation of the mushroom billiard has a \"door\" at the bottom of the stem. Thus,  using   Statistics  bd   =   billiard_mushroom ()  et   =   zeros ( 100 )  for   i   \u2208   1 : 100 \n     particle   =   randominside ( bd ) \n     et [ i ]   =   escapetime ( particle ,   bd ,   10000 )  end  println ( Out of 100 particles,  $ ( count ( x -   x   !=   Inf ,   et ))  escaped )  println ( Mean escape time was  $ ( mean ( et [ et   .!=   Inf ])) )   Out of 100 particles, 20 escaped\nMean escape time was 3.8881125805238144  Of course,  escapetime  works with  MagneticParticle  as well  escapetime ( randominside ( bd ,   1.0 ),   bd ,   10000 )   113.20014708776995", 
            "title": "Escape Times"
        }, 
        {
            "location": "/basic/high_level/#mean-collision-times", 
            "text": "Because the computation of a mean collision time (average time between collisions in a billiard) is often a useful quantity, the following function computes it  #  DynamicalBilliards.meancollisiontime     Function .  meancollisiontime([p,] bd, t) \u2192 \u03ba  Compute the mean collision time  \u03ba  of the particle  p  in the billiard  bd  by evolving for total amount  t  (either float for time or integer for collision number).  Collision times are counted only between obstacles that are  not   PeriodicWall .  If a particle is not given, a random one is picked through  randominside . See  parallelize  for a parallelized version.  source  For example,  bd   =   billiard_sinai ()  meancollisiontime ( randominside ( bd ),   bd ,   10000.0 )   0.4527977399765889", 
            "title": "Mean Collision Times"
        }, 
        {
            "location": "/basic/high_level/#parallelization", 
            "text": "#  DynamicalBilliards.parallelize     Function .  parallelize ( f ,   bd :: Billiard ,   t ,   particles ;   partype   =   : threads )   Parallelize function  f  across the available particles. The parallelization type can be  :threads  or  :pmap , which use threads or a worker pool initialized with  addprocs   before   using DynamicalBilliards .  particles  can be:   A  Vector  of particles.  An integer  n  optionally followed by an angular velocity  \u03c9 . This uses  randominside .   The functions usable here are:   meancollisiontime  escapetime  lyapunovspectrum  (returns only the maximal exponents)  boundarymap  (returns vector of vectors of 2-vectors  and   arcintervals )   source   Here are some examples  bd   =   billiard_stadium ()  particles   =   [ randominside ( bd )   for   i   in   1 : 1000 ]  parallelize ( meancollisiontime ,   bd ,   1000 ,   particles )   1000-element Array{Float64,1}:\n 1.033275725102876\n 1.0764263141507806\n 1.0893951878350467\n 1.0760898390898481\n 1.0716702420929383\n 1.097868859926868\n 1.1145152590125753\n 1.0843808478896486\n 1.093027900061257\n 1.0558866936531512\n \u22ee\n 1.0996077777135995\n 1.101143601438325\n 1.093637580020895\n 1.1142043995282398\n 1.1003694082296218\n 1.0918468530409204\n 1.1054947355616762\n 1.03590632934719\n 1.1055415909958775  parallelize ( lyapunovspectrum ,   bd ,   1000 ,   particles )   1000-element Array{Float64,1}:\n 0.7191804683739932\n 0.8915161531119421\n 0.9243608176719682\n 0.8778835507078612\n 0.8734528560484212\n 0.800556715770099\n 0.8754138667639091\n 0.939409968626747\n 0.909752551541436\n 0.7819268504043572\n \u22ee\n 0.8598287148547583\n 0.894915064232914\n 0.8826955731919575\n 0.8806918634939603\n 0.8849636276267762\n 0.8191055171845738\n 0.8490040497275966\n 0.9504621101927881\n 0.8717917922652306", 
            "title": "Parallelization"
        }, 
        {
            "location": "/basic/high_level/#its-all-about-bounce", 
            "text": "The main propagation algorithm used by  DynamicalBilliards  is bundled in the following well-behaving function:  #  DynamicalBilliards.bounce!     Function .  bounce!(p::AbstractParticle, bd::Billiard) \u2192 i, t, pos, vel  \"Bounce\" the particle (advance for one collision) in the billiard. Takes care of finite-precision issues.  Return:   index of the obstacle that the particle just collided with  the time from the previous collision until the current collision  t  position and velocity of the particle at the current collision ( after  the collision has been resolved!). The position is given in the unit cell of periodic billiards. Do  pos += p.current_cell  for the position in real space.   bounce! ( p ,   bd ,   raysplit )   \u2192   i ,   t ,   pos ,   vel   Ray-splitting version of  bounce! .  source   bounce!  is the function used internally by all high-level functions, like  evolve! ,  boundarymap ,  escapetime , etc.  This is the function a user should use if they want to calculate other things besides what is already available in the high level API.", 
            "title": "It's all about bounce!"
        }, 
        {
            "location": "/basic/high_level/#standard-billiards-library", 
            "text": "You can also use keywords!  All standard billiards have a function version that accepts keyword arguments instead of positional arguments, for ease of use.   #  DynamicalBilliards.billiard_rectangle     Function .  billiard_rectangle(x=1.0, y=1.0; setting =  standard )  Return a vector of obstacles that defines a rectangle billiard of size ( x ,  y ).  Settings   \"standard\" : Specular reflection occurs during collision.  \"periodic\" : The walls are  PeriodicWall  type, enforcing periodicity at the boundaries  \"random\" : The velocity is randomized upon collision.  \"ray-splitting\" : All obstacles in the billiard allow for ray-splitting.   source  #  DynamicalBilliards.billiard_sinai     Function .  billiard_sinai(r=0.25, x=1.0, y=1.0; setting =  standard )  Return a vector of obstacles that defines a Sinai billiard of size ( x ,  y ) with a disk in its center, of radius  r .  In the periodic case, the system is also known as \"Lorentz Gas\".  Settings   \"standard\" : Specular reflection occurs during collision.  \"periodic\" : The walls are  PeriodicWall  type, enforcing periodicity at the boundaries  \"random\" : The velocity is randomized upon collision.  \"ray-splitting\" : All obstacles in the billiard allow for ray-splitting.   source  #  DynamicalBilliards.billiard_bunimovich     Function .  billiard_bunimovich(l=1.0, w=1.0)  Return a vector of  Obstacle s that define a Buminovich billiard, also called a stadium. The length is considered  without  the attached semicircles, meaning that the full length of the billiard is  l + w . The left and right edges of the stadium are  Semicircle s.  billiard_stadium  is an alias of  billiard_bunimovich .  source  #  DynamicalBilliards.billiard_mushroom     Function .  billiard_mushroom(sl = 1.0, sw = 0.2, cr = 1.0, sloc = 0.0; door = true)  Create a mushroom billiard with stem length  sl , stem width  sw  and cap radius  cr . The center of the cap (which is Semicircle) is always at  [0, sl] . The center of the stem is located at  sloc .  Optionally, the bottom-most  Wall  is a  Door  (see  escapetime ).  source  #  DynamicalBilliards.billiard_polygon     Function .  billiard_polygon ( n :: Int ,   R ,   center   =   [ 0 , 0 ] ;   setting   =   standard )   Return a vector of obstacles that defines a regular-polygonal billiard with  n  sides, radius  r  and given  center .  Note:  R  denotes the so-called outer radius, not the inner one.  Settings   \"standard\" : Specular reflection occurs during collision.  \"periodic\" : The walls are  PeriodicWall  type, enforcing periodicity at the boundaries. Only available for  n=4  or  n=6 .  \"random\" : The velocity is randomized upon collision.   source  #  DynamicalBilliards.billiard_hexagonal_sinai     Function .  billiard_hexagonal_sinai(r, R, center = [0,0]; setting =  standard )  Create a sinai-like billiard, which is a hexagon of outer radius  R , containing at its center (given by  center ) a disk of radius  r . The  setting  keyword is passed to  billiard_polygon .  source  #  DynamicalBilliards.billiard_raysplitting_showcase     Function .  billiard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -  bd, rayspl  Showcase example billiard for ray-splitting processes. A rectangle  (x,y)  with a SplitterWall at  x/2  and two disks at each side, with respective radii  r1 ,  r2 .  Notice : This function returns a billiard  bd  as well as a  rayspl  dictionary!  source  #  DynamicalBilliards.billiard_logo     Function .  billiard_logo(;h=1.0, \u03b1=0.8, r=0.18, off=0.25) -  bd, ray  Create the billiard used as logo of  DynamicalBilliards  and return it along with the tuple of raysplitters.  source  #  DynamicalBilliards.billiard_iris     Function .  billiard_iris(a=0.2, b=0.4, w=1.0; setting =  standard )  Return a billiard that is a square of side  w  enclosing at its center an ellipse with semi axes  a ,  b .  source", 
            "title": "Standard Billiards Library"
        }, 
        {
            "location": "/basic/high_level/#particle-types", 
            "text": "#  DynamicalBilliards.Particle     Type .  Particle ( ic :: Vector { T })   #where ic = [x0, y0, \u03c60]  Particle ( x0 ,   y0 ,   \u03c60 )  Particle ( pos :: SVector ,   vel :: SVector )   Create a particle with initial conditions  x0, y0, \u03c60 . It propagates as a straight line.  The field  current_cell  shows at which cell of a periodic billiard is the particle currently located.  source  #  DynamicalBilliards.MagneticParticle     Type .  MagneticParticle ( ic :: AbstractVector { T },   \u03c9 :: Real )   # where ic = [x0, y0, \u03c60]  MagneticParticle ( x0 ,   y0 ,   \u03c60 ,   \u03c9 )  MagneticParticle ( pos :: SVector ,   vel :: SVector ,   \u03c9 )  MagneticParticle ( p :: AbstractParticle ,   \u03c9 )   Create a  magnetic  particle with initial conditions  x0, y0, \u03c60  and angular velocity  \u03c9 . It propagates as a circle instead of a line, with radius  1/abs(\u03c9) .  The field  current_cell  shows at which cell of a periodic billiard is the particle currently located.  source", 
            "title": "Particle types"
        }, 
        {
            "location": "/visualizing/", 
            "text": "All plotting functionality of \nDynamicalBilliards\n lies within a few well-defined functions that use the \nPyPlot\n package to plot aspects of the system.\n\n\nAll plotting functions are brought into scope when \nusing PyPlot\n. The functions are:\n\n\n#\n\n\nPyPlot.plot\n \n \nMethod\n.\n\n\nplot\n(\nobst\n::\nObstacle\n;\n \nkwargs\n...)\n\n\n\n\n\n\nPlot given obstacle on the current \nPyPlot\n axes.\n\n\nThe default arguments for each type of obstacle have been chosen for maximum clarity and consistency.\n\n\nThe \nkwargs...\n given by the user are keywords passed directly into PyPlot's constructors. For \nWall\n obstacles, kwargs are passed into \nPyPlot.plot()\n. For \nCircular\n obstacles, kwargs are passed into \nmatplotlib.patches.Circle\n or \nArc\n.\n\n\nsource\n\n\n#\n\n\nPyPlot.plot\n \n \nMethod\n.\n\n\nplot\n(\nbd\n::\nBilliard\n;\n \nax\n \n=\n \n(\nfigure\n();\n \ngca\n()))\n\n\n\n\n\n\nPlot all obstacles in \nbd\n using the default arguments, set \nxlim\n and \nylim\n to be 20% larger than \ncellsize\n and set the axis aspect ratio to equal.\n\n\nplot\n(\nbd\n::\nBilliard\n,\n \nxmin\n,\n \nymin\n,\n \nxmax\n,\n \nymax\n;\n\n     \nhexagonal\n \n=\n \nfalse\n,\n \nax\n \n=\n \n(\nfigure\n();\n \ngca\n()))\n\n\n\n\n\n\nPlot the given \nperiodic\n billiard \nbd\n, repeatedly plotting from \n(xmin, ymin)\n to \n(xmax, ymax)\n. Works for either rectangular periodic billiards, or hexagonal ones. Use keyword \nhexagonal\n to denote which one you want.\n\n\nplot\n(\nbd\n::\nBilliard\n,\n \nxt\n::\nVector\n,\n \nyt\n::\nVector\n;\n \nhexagonal\n \n=\n \nfalse\n,\n\n     \nax\n \n=\n \n(\nfigure\n();\n \ngca\n()),\n \nplot_orbit\n \n=\n \ntrue\n,\n \norbit_color\n \n=\n \nC0\n)\n\n\n\n\n\n\nPlot the given billiard \nbd\n and an acompanying orbit resulting from \ntimeseries!\n using the limits defined by \nxt\n and \nyt\n. Works for both periodic and normal billiards.\n\n\nsource\n\n\n#\n\n\nPyPlot.plot\n \n \nMethod\n.\n\n\nplot\n(\np\n::\nAbstractParticle\n \n[\n,\n \ncyclotron\n=\nfalse\n]\n;\n \nuse_cell\n=\ntrue\n,\n \nkwargs\n...)\n\n\n\n\n\n\nPlot given particle on the current \nPyPlot\n axes. Optionally use \np.current_cell\n for the particle's position. Given \nkwargs...\n are passed onto \nPyPlot.scatter\n.\n\n\nThe particle is represented as a small ball (\nPyPlot.scatter\n) and a small arrow (\nPyPlot.quiver\n). All \nkwargs...\n are given to \nscatter\n but if a keyword argument \ncolor\n is given, it is also passed to \nquiver\n.\n\n\nOptionally you can plot the cyclotron traced by a \nMagneticParticle\n by giving \ntrue\n as second argument.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.animate_evolution\n \n \nFunction\n.\n\n\nanimate_evolution(ps, bd, colnumber [, raysplitters]; kwargs...)\n\n\n\n\n\nAnimate the evolution of a vector of particles \nps\n in billiard \nbd\n for a total time \nt\n (always considered float). Optionally enable ray-splitting.\n\n\nEvolution kwargs\n\n\n\n\ndt = 0.01\n : Time resolution used for production of time series (see \ntimeseries!\n. It is not recommended to significantly increase this value, to preserve the smoothness of the orbits.\n\n\nframeskip = 5\n : The amount of \ndt\n-steps performed each frame. Increasing either \nframeskip\n and \ndt\n makes the animation progress faster.\n\n\ntailtime = 1.0\n : The length of the \"tail\" trailing the particle in time units.\n\n\nresetting = reset_billiard!\n : function called after evolving each individual particle in the billiard (so that ray-splitting doesn't brake).\n\n\n\n\nColors \n plotting kwargs\n\n\n\n\ncolors\n : An array of valid Matplotlib colors for the \"tails\". If \ncolors\n is shorter than \nps\n, colors are reused. Defaults to the standard Matplotlib color sequence.\n\n\nparticle_kwargs::NamedTuple\n : Additional keyword arguments passed to the \nplot\n function for particles.\n\n\ntail_kwargs::NamedTuple\n: Additional keyword arguments passed to the \nplot\n function for \"tails\" (line plot).\n\n\n\n\nExporting and axis kwargs\n\n\n\n\nfigsize = (7.2, 7.2))\n : Size for new figure (if one is created). Must be divisible by 2 if you want to save the animation.\n\n\nax = (figure(figsize = figsize); plot(bd); gca())\n : axis to plot on.\n\n\nsavename = nothing\n : If given the animation is exported to mp4 file (requires ffmpeg). The name can include path.\n\n\ndisable_axis = false\n : Remove the axis splines.\n\n\ndeletefigs = true\n : To create the animation a lot of figures are saved in the save directory and are deleted after the animation is done. You can choose to keep them.\n\n\ndpi = 100\n : dpi of saved figures.\n\n\nframerate = 20\n : Animation framerate.\n\n\n\n\nsource\n\n\n\n\nExamples\n\n\n\n\nPlotting Obstacles with keywords\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\n\nbd\n \n=\n \nbilliard_sinai\n()\n\n\n\nfigure\n()\n\n\nplot\n(\nbd\n[\n2\n]);\n\n\nplot\n(\nbd\n[\n4\n],\n \ncolor\n \n=\n \nblue\n,\n \nlinestyle\n \n=\n \ndotted\n,\n \nlw\n \n=\n \n5.0\n);\n\n\nplot\n(\nbd\n[\n1\n],\n \nfacecolor\n \n=\n \nyellow\n,\n \nedgecolor\n \n=\n \nblack\n);\n\n\n\n\n\n\n\n\n\n\nPlotting a Billiard\n\n\nusing\n \nDynamicalBilliards\n\n\nb\n \n=\n \nbilliard_polygon\n(\n6\n,\n \n1\n)\n\n\na\n \n=\n \nAntidot\n([\n0.0\n,\n0.0\n],\n \n0.5\n)\n\n\nbd\n \n=\n \nBilliard\n(\nb\n.\nobstacles\n...\n,\n \na\n)\n\n\n\n\n\n\nBilliard{Float64} with 7 obstacles:\n  wall 1\n  wall 2\n  wall 3\n  wall 4\n  wall 5\n  wall 6\n  Antidot\n\n\n\n\n\nIf you want to quickly plot the entire billiard with default parameters, simply use the function \nplot(bd)\n:\n\n\nusing\n \nPyPlot\n\n\nplot\n(\nbd\n)\n\n\n\n\n\n\n\n\nplot()\n also sets up the axis to have equal aspect ratio and sets up the axis limits to be just large enough to contain the entire billiard.\n\n\n\n\nPlotting particles\n\n\nFollowing the above example, we create and plot a particle using the function \nplot\n:\n\n\np\n \n=\n \nrandominside\n(\nbd\n)\n\n\nplot\n(\np\n)\n\n\n# Plot one more particle with purple color,\n\n\n# pentagon shape and bigger size (default is s=30):\n\n\np2\n \n=\n \nrandominside\n(\nbd\n)\n\n\nplot\n(\np2\n;\n \ncolor\n=\n(\n0.5\n,\n \n0\n,\n \n0.8\n),\n \nmarker\n=\np\n,\n \ns\n=\n60.0\n)\n\n\np3\n \n=\n \nrandominside\n(\nbd\n,\n \n2.0\n)\n\n\nplot\n(\np3\n,\n \ntrue\n;\n \ncolor\n=\n(\n0\n,\n \n0\n,\n \n0.8\n),\n \nmarker\n=\no\n,\n \ns\n=\n60.0\n)\n\n\n\n\n\n\n\n\n(notice that the particle position and direction are random)\n\n\n\n\nColor conventions\n\n\nThe default plotting settings have been chosen for maximum clarity and consistency. The color conventions followed are:\n\n\n\n\nParticles are black.\n\n\nParticle orbits use matplotlib's color cycle (first one is blue).\n\n\nReflecting obstacles (e.g. \nDisk\n, \nFiniteWall\n etc.) are green.\n\n\nRandomly reflecting obstacles (e.g. \nRandomDisk\n or \nRandomWall\n) are purple.\n\n\nRay-splitting obstacles are red with dashed linestyle.\n\n\nPeriodicity enforcing obstacles are yellow with dotted linestyle (if and when plotted).\n\n\nDoors (\nInfiniteWall\n with \nisdoor=true\n) are plotted with alternating black and cyan dashed lines.\n\n\n\n\n\n\nAnimating the motion of a particle\n\n\nThe function \nanimate_evolution\n is provided to animate the evolution of a particle from collision to collision. Let's animate a particle inside a simple pentagon with magnetic field:\n\n\nbd\n \n=\n \nbilliard_polygon\n(\n5\n,\n \n1\n)\n\n\na\n \n=\n \nDisk\n([\n0.0\n,\n0.0\n],\n \n0.4\n)\n\n\nbd\n \n=\n \nBilliard\n(\nbd\n.\nobstacles\n...\n,\n \na\n)\n\n\np\n \n=\n \nMagneticParticle\n(\n0\n,\n \n-\n0.5\n,\n \n0\n,\n \n1.0\n)\n\n\n\nanimate_evolution\n(\np\n,\n \nbd\n,\n \n10.0\n;\n \nsavename\n \n=\n \npenta\n)\n\n\n\n\n\n\n \n \n\n\n\nThe cool thing about \nanimate_evolution\n is that it can animate multiple particles simultaneously! For example, here is a beautiful demonstration of chaos in non-dispersive billiards:\n\n\nbd\n \n=\n \nbilliard_stadium\n()\n\n\nN\n \n=\n \n20\n\n\ncs\n \n=\n \n[(\ni\n/\nN\n,\n \n0\n,\n \n1\n \n-\n \ni\n/\nN\n,\n \n0.5\n)\n \nfor\n \ni\n \nin\n \n1\n:\nN\n]\n\n\nps\n \n=\n \n[\nParticle\n(\n1\n,\n \n0.6\n \n+\n \n0.0005\n*\ni\n,\n \n0\n)\n \nfor\n \ni\n \nin\n \n1\n:\nN\n]\n\n\n\nanimate_evolution\n(\nps\n,\n \nbd\n,\n \n10.0\n;\n \ncolors\n \n=\n \ncs\n,\n \ntailtime\n \n=\n \n1.5\n,\n \nsavename\n \n=\n \ndisperse\n)\n\n\n\n\n\n\n \n \n\n\n\n\n\nPeriodic Billiards\n\n\nIn order to plot periodic billiards, you have need to call a different method of \nplot\n, since now you also have to specify the limits of plotting. The methods provided are:\n\n\nplot\n(\nbd\n,\n \nxmin\n,\n \nymin\n,\n \nxmax\n,\n \nymax\n)\n\n\nplot\n(\nbd\n,\n \nxt\n::\nVector\n{\nT\n},\n \nyt\n::\nVector\n{\nT\n})\n\n\n\n\n\n\nThe last one conveniently plots the combo of particle-trajectory and periodic-billiard taking care of all the details internally. Give the keyword \nplot_orbit = false\n if you do not want to plot the orbit defined by \n(xt, yt)\n.\n\n\nFor example, the following code\n\n\n```@example 8\nusing DynamicalBilliards, PyPlot\nr = 0.25\nbd = billiard_rectangle(2, 1; setting = \"periodic\")\nd = Disk([0.5, 0.5], r)\nd2 = Ellipse([1.5, 0.5], r, 2r/3)\nbd = Billiard(bd.obstacles..., d, d2)\np = Particle(1.0, 0.5, 0.2)\nxt, yt, vxt, vyt, t = timeseries!(p, bd, 10)\nplot(bd, xt, yt)\nplot(p)\nsavefig(\"rectperiodic.svg\"); nothing # hide\n\n\n![](rectperiodic.svg)\n\n\nAnd, you can also periodically plot billiards with hexagonal periodicity. Only give the keyword argument `hexagonal = true` to [`plot`](visualizing.md#PyPlot.plot-Tuple{Obstacle}). As an example:\n\n\n```@example 8\nbd = billiard_hexagonal_sinai(0.3, 1.50; setting = \nperiodic\n)\nd = Disk([0.7, 0], 0.2)\nd2 = Antidot([0.7/2, 0.65], 0.35)\nbd = Billiard(bd..., d, d2)\n\np = MagneticParticle(-0.5, 0.5, \u03c0/5, 1.0)\n\nxt, yt = timeseries(p, bd, 10)\n\nplot(bd, xt, yt; hexagonal = true)\nsavefig(\nhexperiodic.svg\n); nothing # hide\n\n\n\n\n\n\n\n\n\nBoundary Map plots\n\n\n#\n\n\nDynamicalBilliards.plot_boundarymap\n \n \nFunction\n.\n\n\nplot_boundarymap(bmap, intervals; kwargs...)\n\n\n\n\n\nPlots the boundary map. The input arguments are the return values of \nboundarymap\n (also applies for the parallelized version, where \nbmap\n is a vector of vectors of 2-vectors).\n\n\nKeyword Arguments\n\n\n\n\nax = (figure(); gca())\n : The axis to plot on.\n\n\ncolor = \"C0\"\n : The color to use for the plotted points. Can be either a color for \nPyPlot.plot\n or a vector of colors of length \nlength(bmap)\n, in order to give each initial condition a different color (for parallelized version).\n\n\nms = 1.0\n : Marker size of the points.\n\n\nbordercolor = \"C3\"\n : The color of the vertical lines that denote the obstacle borders.\n\n\nobstacleindices = true\n: show obstacle indices above plot\n\n\nAny other keyword argument is passed to \nPyPlot.plot\n which plots the points of the section.\n\n\n\n\nsource\n\n\nExamples are shown in the \nphase spaces\n section.", 
            "title": "Visualizing"
        }, 
        {
            "location": "/visualizing/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/visualizing/#plotting-obstacles-with-keywords", 
            "text": "using   DynamicalBilliards ,   PyPlot  bd   =   billiard_sinai ()  figure ()  plot ( bd [ 2 ]);  plot ( bd [ 4 ],   color   =   blue ,   linestyle   =   dotted ,   lw   =   5.0 );  plot ( bd [ 1 ],   facecolor   =   yellow ,   edgecolor   =   black );", 
            "title": "Plotting Obstacles with keywords"
        }, 
        {
            "location": "/visualizing/#plotting-a-billiard", 
            "text": "using   DynamicalBilliards  b   =   billiard_polygon ( 6 ,   1 )  a   =   Antidot ([ 0.0 , 0.0 ],   0.5 )  bd   =   Billiard ( b . obstacles ... ,   a )   Billiard{Float64} with 7 obstacles:\n  wall 1\n  wall 2\n  wall 3\n  wall 4\n  wall 5\n  wall 6\n  Antidot  If you want to quickly plot the entire billiard with default parameters, simply use the function  plot(bd) :  using   PyPlot  plot ( bd )    plot()  also sets up the axis to have equal aspect ratio and sets up the axis limits to be just large enough to contain the entire billiard.", 
            "title": "Plotting a Billiard"
        }, 
        {
            "location": "/visualizing/#plotting-particles", 
            "text": "Following the above example, we create and plot a particle using the function  plot :  p   =   randominside ( bd )  plot ( p )  # Plot one more particle with purple color,  # pentagon shape and bigger size (default is s=30):  p2   =   randominside ( bd )  plot ( p2 ;   color = ( 0.5 ,   0 ,   0.8 ),   marker = p ,   s = 60.0 )  p3   =   randominside ( bd ,   2.0 )  plot ( p3 ,   true ;   color = ( 0 ,   0 ,   0.8 ),   marker = o ,   s = 60.0 )    (notice that the particle position and direction are random)", 
            "title": "Plotting particles"
        }, 
        {
            "location": "/visualizing/#color-conventions", 
            "text": "The default plotting settings have been chosen for maximum clarity and consistency. The color conventions followed are:   Particles are black.  Particle orbits use matplotlib's color cycle (first one is blue).  Reflecting obstacles (e.g.  Disk ,  FiniteWall  etc.) are green.  Randomly reflecting obstacles (e.g.  RandomDisk  or  RandomWall ) are purple.  Ray-splitting obstacles are red with dashed linestyle.  Periodicity enforcing obstacles are yellow with dotted linestyle (if and when plotted).  Doors ( InfiniteWall  with  isdoor=true ) are plotted with alternating black and cyan dashed lines.", 
            "title": "Color conventions"
        }, 
        {
            "location": "/visualizing/#animating-the-motion-of-a-particle", 
            "text": "The function  animate_evolution  is provided to animate the evolution of a particle from collision to collision. Let's animate a particle inside a simple pentagon with magnetic field:  bd   =   billiard_polygon ( 5 ,   1 )  a   =   Disk ([ 0.0 , 0.0 ],   0.4 )  bd   =   Billiard ( bd . obstacles ... ,   a )  p   =   MagneticParticle ( 0 ,   - 0.5 ,   0 ,   1.0 )  animate_evolution ( p ,   bd ,   10.0 ;   savename   =   penta )        The cool thing about  animate_evolution  is that it can animate multiple particles simultaneously! For example, here is a beautiful demonstration of chaos in non-dispersive billiards:  bd   =   billiard_stadium ()  N   =   20  cs   =   [( i / N ,   0 ,   1   -   i / N ,   0.5 )   for   i   in   1 : N ]  ps   =   [ Particle ( 1 ,   0.6   +   0.0005 * i ,   0 )   for   i   in   1 : N ]  animate_evolution ( ps ,   bd ,   10.0 ;   colors   =   cs ,   tailtime   =   1.5 ,   savename   =   disperse )", 
            "title": "Animating the motion of a particle"
        }, 
        {
            "location": "/visualizing/#periodic-billiards", 
            "text": "In order to plot periodic billiards, you have need to call a different method of  plot , since now you also have to specify the limits of plotting. The methods provided are:  plot ( bd ,   xmin ,   ymin ,   xmax ,   ymax )  plot ( bd ,   xt :: Vector { T },   yt :: Vector { T })   The last one conveniently plots the combo of particle-trajectory and periodic-billiard taking care of all the details internally. Give the keyword  plot_orbit = false  if you do not want to plot the orbit defined by  (xt, yt) .  For example, the following code  ```@example 8\nusing DynamicalBilliards, PyPlot\nr = 0.25\nbd = billiard_rectangle(2, 1; setting = \"periodic\")\nd = Disk([0.5, 0.5], r)\nd2 = Ellipse([1.5, 0.5], r, 2r/3)\nbd = Billiard(bd.obstacles..., d, d2)\np = Particle(1.0, 0.5, 0.2)\nxt, yt, vxt, vyt, t = timeseries!(p, bd, 10)\nplot(bd, xt, yt)\nplot(p)\nsavefig(\"rectperiodic.svg\"); nothing # hide  ![](rectperiodic.svg)\n\n\nAnd, you can also periodically plot billiards with hexagonal periodicity. Only give the keyword argument `hexagonal = true` to [`plot`](visualizing.md#PyPlot.plot-Tuple{Obstacle}). As an example:\n\n\n```@example 8\nbd = billiard_hexagonal_sinai(0.3, 1.50; setting =  periodic )\nd = Disk([0.7, 0], 0.2)\nd2 = Antidot([0.7/2, 0.65], 0.35)\nbd = Billiard(bd..., d, d2)\n\np = MagneticParticle(-0.5, 0.5, \u03c0/5, 1.0)\n\nxt, yt = timeseries(p, bd, 10)\n\nplot(bd, xt, yt; hexagonal = true)\nsavefig( hexperiodic.svg ); nothing # hide", 
            "title": "Periodic Billiards"
        }, 
        {
            "location": "/visualizing/#boundary-map-plots", 
            "text": "#  DynamicalBilliards.plot_boundarymap     Function .  plot_boundarymap(bmap, intervals; kwargs...)  Plots the boundary map. The input arguments are the return values of  boundarymap  (also applies for the parallelized version, where  bmap  is a vector of vectors of 2-vectors).  Keyword Arguments   ax = (figure(); gca())  : The axis to plot on.  color = \"C0\"  : The color to use for the plotted points. Can be either a color for  PyPlot.plot  or a vector of colors of length  length(bmap) , in order to give each initial condition a different color (for parallelized version).  ms = 1.0  : Marker size of the points.  bordercolor = \"C3\"  : The color of the vertical lines that denote the obstacle borders.  obstacleindices = true : show obstacle indices above plot  Any other keyword argument is passed to  PyPlot.plot  which plots the points of the section.   source  Examples are shown in the  phase spaces  section.", 
            "title": "Boundary Map plots"
        }, 
        {
            "location": "/basic/phasespaces/", 
            "text": "Phase Spaces\n\n\n\n\nCoordinate Systems\n\n\nAny billiard has two coordinate systems:\n\n\n\n\nThe \"real\" coordinates, i.e. the coordinates that specify the full, three-dimensional phase space: \nx, y, \\phi\nx, y, \\phi\n.\n\n\nThe \"boundary\" coordinates, also known as Birkhoff coordinates, which instead reduce the continuous billiard into a map, by only considering the collision points. These coordinates are only two: \n\\xi, \\sin(\\phi_n)\n\\xi, \\sin(\\phi_n)\n, with \n\\xi\n\\xi\n being the parametrization of the arc length and \n\\phi_n\n\\phi_n\n being the angle as measured from the normal vector.\n\n\n\n\nWith \nDynamicalBilliards\n it is very easy to switch between the two coordinate systems, using:\n\n\n#\n\n\nDynamicalBilliards.to_bcoords\n \n \nFunction\n.\n\n\nto_bcoords(pos, vel, o::Obstacle) -\n \u03be, s\u03c6\n\n\n\n\n\nConvert the real coordinates \npos, vel\n to boundary coordinates (also known as Birkhoff coordinates) \n\u03be, s\u03c6\n, assuming that \npos\n is on the obstacle.\n\n\n\u03be\n is the arc-coordinate, i.e. it parameterizes the arclength of the obstacle. \ns\u03c6\n is the sine of the angle between the velocity vector and the vector normal to the obstacle.\n\n\nThe arc-coordinate \n\u03be\n is measured as:\n\n\n\n\nthe distance from start point to end point in \nWall\ns\n\n\nthe arc length measured counterclockwise from the open face in \nSemicircle\ns\n\n\nthe arc length measured counterclockwise from the rightmost point in \nCircular\n/\nEllipse\ns\n\n\n\n\nNotice that this function returns the \nlocal\n arclength. To get the global arclength parameterizing an entire billiard, simply do \n\u03be += arcintervals(bd)[i]\n if the index of obstacle \no\n is \ni\n.\n\n\nSee also \nfrom_bcoords\n, which is the inverse function.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.from_bcoords\n \n \nFunction\n.\n\n\nfrom_bcoords(\u03be, s\u03c6, o::Obstacle) -\n pos, vel\n\n\n\n\n\nConvert the boundary coordinates \n\u03be, s\u03c6\n on the obstacle to real coordinates \npos, vel\n.\n\n\nNote that \nvel\n always points away from the obstacle.\n\n\nThis function is the inverse of \nto_bcoords\n.\n\n\nsource\n\n\nfrom_bcoords(\u03be, s\u03c6, bd::Billiard, intervals = arcintervals(bd))\n\n\n\n\n\nSame as above, but now \n\u03be\n is considered to be the global arclength, parameterizing the entire billiard, instead of a single obstacle.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.arcintervals\n \n \nFunction\n.\n\n\narcintervals(bd::Billiard) -\n s\n\n\n\n\n\nGenerate a vector \ns\n, with entries being the delimiters of the arclengths of the obstacles of the billiard. The arclength from \ns[i]\n to \ns[i+1]\n is the arclength spanned by the \ni\nth obstacle.\n\n\ns\n is used to transform an arc-coordinate \n\u03be\n from local to global and vice-versa. A local \n\u03be\n becomes global by adding \ns[i]\n (where \ni\n is the index of current obstacle). A global \n\u03be\n becomes local by subtracting \ns[i]\n.\n\n\nSee also \nboundarymap\n, \nto_bcoords\n, \nfrom_bcoords\n.\n\n\nsource\n\n\n\n\nBoundary Maps\n\n\nBoundary maps can be obtained with the high level function\n\n\n#\n\n\nDynamicalBilliards.boundarymap\n \n \nFunction\n.\n\n\nboundarymap(p, bd, t [,intervals]) \u2192 bmap, arclengths\n\n\n\n\n\nCompute the boundary map of the particle \np\n in the billiard \nbd\n by evolving the particle for total amount \nt\n (either float for time or integer for collision number).\n\n\nReturn a vector of 2-vectors \nbmap\n and also \narclengths(bd)\n. The first entry of each element of \nbmap\n is the arc-coordinate at collisions \n\\xi\n\\xi\n, while the second  is the sine of incidence angle \n\\sin(\\phi_n)\n\\sin(\\phi_n)\n.\n\n\nThe measurement direction of the arclengths of the individual obstacles is dictated by their order in \nbd\n. The sine of the angle is computed \nafter\n specular reflection has taken place.\n\n\nThe returned values of this function can be used in conjuction with the function \nplot_boundarymap\n (requires \nusing PyPlot\n) to plot the boundary map in an intuitive way.\n\n\nNotice\n - this function only works for normal specular reflection. Random reflections or ray-splitting will give unexpected results.\n\n\nSee also \nto_bcoords\n, \nboundarymap_portion\n. See \nparallelize\n for a parallelized version.\n\n\nsource\n\n\n\n\nFor example, take a look at boundary maps of the mushroom billiard, which is known to have a mixed phase space:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\n\nbd\n \n=\n \nbilliard_mushroom\n()\n\n\n\nn\n \n=\n \n100\n \n# how many particles to create\n\n\nt\n \n=\n \n200\n \n# how long to evolve each one\n\n\n\nbmap\n,\n \narcs\n \n=\n \nparallelize\n(\nboundarymap\n,\n \nbd\n,\n \nt\n,\n \nn\n)\n\n\n\nusing\n \nPyPlot\n \n# enables plot_boundarymap function\n\n\n\ncolors\n \n=\n \n[\nC\n$\n(\nrand\n(\n1\n:\n9\n))\n \nfor\n \ni\n \nin\n \n1\n:\nn\n]\n \n# random colors\n\n\n\nplot_boundarymap\n(\nbmap\n,\n \narcs\n,\n \ncolor\n \n=\n \ncolors\n)\n\n\ntight_layout\n()\n\n\n\n\n\n\n\n\nAnd of course similarly for magnetic fields\n\n\nbmap\n,\n \narcs\n \n=\n \nparallelize\n(\nboundarymap\n,\n \nbd\n,\n \nt\n,\n \nn\n,\n \n1.0\n)\n\n\nplot_boundarymap\n(\nbmap\n,\n \narcs\n,\n \ncolor\n \n=\n \ncolors\n)\n\n\ntight_layout\n()\n\n\n\n\n\n\n\n\n\n\n\n\n\nPhase Space Portions\n\n\nIt is possible to compute the portion of phase space covered by a particle as it is evolved in time. We have two methods, one for the \"boundary\" coordinates (2D space) and one for the \"real\" coordinates (3D space):\n\n\n#\n\n\nDynamicalBilliards.boundarymap_portion\n \n \nFunction\n.\n\n\nboundarymap_portion(bd::Billiard, t, p::AbstractParticle, \u03b4\u03be, \u03b4\u03c6 = \u03b4\u03be)\n\n\n\n\n\nCalculate the portion of the boundary map of the billiard \nbd\n covered by the particle \np\n when it is evolved for time \nt\n (float or integer). Notice that the\n\n\nThe boundary map is partitioned into boxes of size \n(\u03b4\u03be, \u03b4\u03c6)\n and as the particle evolves visited boxes are counted. The returned ratio is this count divided by the total boxes of size \n(\u03b4\u03be, \u03b4\u03c6)\n needed to cover the boundary map.\n\n\nImportant:\n This portion \ndoes not\n equate the portion the particle's orbit covers on the full, three dimensional phase space. Use the function \nphasespace_portion\n for that!\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.phasespace_portion\n \n \nFunction\n.\n\n\nphasespace_portion(bd::Billiard, t, p::AbstractParticle, \u03b4\u03be, \u03b4\u03c6 = \u03b4\u03be)\n\n\n\n\n\nCalculate the portion of the phase space of the billiard \nbd\n covered by the particle \np\n when it is evolved for time \nt\n (float or integer).\n\n\nThis function extends \nboundarymap_portion\n using a novel approach. For each visited box of the boundary map, \nbounce!\n attributes a third dimension (the collision time, equal to collision distance) which expands the two dimensions of the boundary map to the three dimensions of the phase space.\n\n\nThe true phase space portion is then the weighted portion of boxes visited by the particle, divided by the total weighted sum of boxes. The weights of the boxes are the collision times.\n\n\nsource\n\n\n\n\nFor example, for mushroom billiards the ratio of the chaotic-to-total phase space is known \nanalytically\n for both the full 3D [1] space as well as the boundary 2D [2] space:\n\n\n\n\n\n\\begin{aligned}\n  g_\\text{c, 3D} \n= \\frac{2 \\, \\pi r^{2} - 4 \\, r^{2} \\arccos\\left(\\frac{w}{2 \\, r}\\right) + 4 \\, l w + \\sqrt{4 \\, r^{2} - w^{2}} w}{2 \\, {\\left(\\pi r^{2} + 2 \\, l w\\right)}}\\\\\n  g_\\text{c, 2D} \n= \\frac{\\pi w + 2 \\, w \\arccos\\left(\\frac{w}{2 \\, r}\\right) + 4 \\, l + 4 \\, r - 2 \\, \\sqrt{4 \\, r^{2} - w^{2}}}{2 \\, {\\left(\\pi r + 2 \\, l + 2 \\, r\\right)}}\n\\end{aligned}\n\n\n\n\n\\begin{aligned}\n  g_\\text{c, 3D} &= \\frac{2 \\, \\pi r^{2} - 4 \\, r^{2} \\arccos\\left(\\frac{w}{2 \\, r}\\right) + 4 \\, l w + \\sqrt{4 \\, r^{2} - w^{2}} w}{2 \\, {\\left(\\pi r^{2} + 2 \\, l w\\right)}}\\\\\n  g_\\text{c, 2D} &= \\frac{\\pi w + 2 \\, w \\arccos\\left(\\frac{w}{2 \\, r}\\right) + 4 \\, l + 4 \\, r - 2 \\, \\sqrt{4 \\, r^{2} - w^{2}}}{2 \\, {\\left(\\pi r + 2 \\, l + 2 \\, r\\right)}}\n\\end{aligned}\n\n\n\n\n\nWe can easily confirm those formulas:\n\n\nusing\n \nDynamicalBilliards\n\n\n\nt\n \n=\n \n1000000.0\n\n\nl\n \n=\n \n1.0\n;\n \nr\n \n=\n \n1.0\n;\n \nw\n \n=\n \n0.4\n\n\n\nbd\n \n=\n \nbilliard_mushroom\n(\nl\n,\n \nw\n,\n \nr\n)\n\n\n\np\n \n=\n \nMushroomTools\n.\nrandomchaotic\n(\nl\n,\n \nw\n,\n \nr\n)\n\n\n\nratio\n,\n \ndic\n \n=\n \nboundarymap_portion\n(\nbd\n,\n \nt\n,\n \np\n,\n \n0.01\n)\n\n\ntrueratio\n \n=\n \nMushroomTools\n.\ng_c_2D\n(\nl\n,\nw\n,\nr\n)\n\n\nprintln\n(\n2D numeric - theory: \n$\n(\nabs\n(\nratio\n \n-\n \ntrueratio\n))\n)\n\n\n\nratio\n \n=\n \nphasespace_portion\n(\nbd\n,\n \nt\n,\n \np\n,\n \n0.01\n)\n\n\ntrueratio\n \n=\n \nMushroomTools\n.\ng_c_3D\n(\nl\n,\nw\n,\nr\n)\n\n\nprintln\n(\n3D numeric - theory: \n$\n(\nabs\n(\nratio\n \n-\n \ntrueratio\n))\n)\n\n\n\n\n\n\n2D numeric - theory: 1.240333694096929e-5\n3D numeric - theory: 0.0010514688950296613\n\n\n\n\n\nOf course, increasing evolution time and decreasing boxsize will bring higher accuracy.\n\n\n\n\nReferences\n\n\n[1] : A. H. Barnett \n T. Betcke, \nQuantum mushroom billiards\n, \nChaos, 17(4) (20017)\n\n\n[2] : Lukas Hupe, B.Sc. Thesis (2018), \nto be published", 
            "title": "Phase Spaces"
        }, 
        {
            "location": "/basic/phasespaces/#phase-spaces", 
            "text": "", 
            "title": "Phase Spaces"
        }, 
        {
            "location": "/basic/phasespaces/#coordinate-systems", 
            "text": "Any billiard has two coordinate systems:   The \"real\" coordinates, i.e. the coordinates that specify the full, three-dimensional phase space:  x, y, \\phi x, y, \\phi .  The \"boundary\" coordinates, also known as Birkhoff coordinates, which instead reduce the continuous billiard into a map, by only considering the collision points. These coordinates are only two:  \\xi, \\sin(\\phi_n) \\xi, \\sin(\\phi_n) , with  \\xi \\xi  being the parametrization of the arc length and  \\phi_n \\phi_n  being the angle as measured from the normal vector.   With  DynamicalBilliards  it is very easy to switch between the two coordinate systems, using:  #  DynamicalBilliards.to_bcoords     Function .  to_bcoords(pos, vel, o::Obstacle) -  \u03be, s\u03c6  Convert the real coordinates  pos, vel  to boundary coordinates (also known as Birkhoff coordinates)  \u03be, s\u03c6 , assuming that  pos  is on the obstacle.  \u03be  is the arc-coordinate, i.e. it parameterizes the arclength of the obstacle.  s\u03c6  is the sine of the angle between the velocity vector and the vector normal to the obstacle.  The arc-coordinate  \u03be  is measured as:   the distance from start point to end point in  Wall s  the arc length measured counterclockwise from the open face in  Semicircle s  the arc length measured counterclockwise from the rightmost point in  Circular / Ellipse s   Notice that this function returns the  local  arclength. To get the global arclength parameterizing an entire billiard, simply do  \u03be += arcintervals(bd)[i]  if the index of obstacle  o  is  i .  See also  from_bcoords , which is the inverse function.  source  #  DynamicalBilliards.from_bcoords     Function .  from_bcoords(\u03be, s\u03c6, o::Obstacle) -  pos, vel  Convert the boundary coordinates  \u03be, s\u03c6  on the obstacle to real coordinates  pos, vel .  Note that  vel  always points away from the obstacle.  This function is the inverse of  to_bcoords .  source  from_bcoords(\u03be, s\u03c6, bd::Billiard, intervals = arcintervals(bd))  Same as above, but now  \u03be  is considered to be the global arclength, parameterizing the entire billiard, instead of a single obstacle.  source  #  DynamicalBilliards.arcintervals     Function .  arcintervals(bd::Billiard) -  s  Generate a vector  s , with entries being the delimiters of the arclengths of the obstacles of the billiard. The arclength from  s[i]  to  s[i+1]  is the arclength spanned by the  i th obstacle.  s  is used to transform an arc-coordinate  \u03be  from local to global and vice-versa. A local  \u03be  becomes global by adding  s[i]  (where  i  is the index of current obstacle). A global  \u03be  becomes local by subtracting  s[i] .  See also  boundarymap ,  to_bcoords ,  from_bcoords .  source", 
            "title": "Coordinate Systems"
        }, 
        {
            "location": "/basic/phasespaces/#boundary-maps", 
            "text": "Boundary maps can be obtained with the high level function  #  DynamicalBilliards.boundarymap     Function .  boundarymap(p, bd, t [,intervals]) \u2192 bmap, arclengths  Compute the boundary map of the particle  p  in the billiard  bd  by evolving the particle for total amount  t  (either float for time or integer for collision number).  Return a vector of 2-vectors  bmap  and also  arclengths(bd) . The first entry of each element of  bmap  is the arc-coordinate at collisions  \\xi \\xi , while the second  is the sine of incidence angle  \\sin(\\phi_n) \\sin(\\phi_n) .  The measurement direction of the arclengths of the individual obstacles is dictated by their order in  bd . The sine of the angle is computed  after  specular reflection has taken place.  The returned values of this function can be used in conjuction with the function  plot_boundarymap  (requires  using PyPlot ) to plot the boundary map in an intuitive way.  Notice  - this function only works for normal specular reflection. Random reflections or ray-splitting will give unexpected results.  See also  to_bcoords ,  boundarymap_portion . See  parallelize  for a parallelized version.  source   For example, take a look at boundary maps of the mushroom billiard, which is known to have a mixed phase space:  using   DynamicalBilliards ,   PyPlot  bd   =   billiard_mushroom ()  n   =   100   # how many particles to create  t   =   200   # how long to evolve each one  bmap ,   arcs   =   parallelize ( boundarymap ,   bd ,   t ,   n )  using   PyPlot   # enables plot_boundarymap function  colors   =   [ C $ ( rand ( 1 : 9 ))   for   i   in   1 : n ]   # random colors  plot_boundarymap ( bmap ,   arcs ,   color   =   colors )  tight_layout ()    And of course similarly for magnetic fields  bmap ,   arcs   =   parallelize ( boundarymap ,   bd ,   t ,   n ,   1.0 )  plot_boundarymap ( bmap ,   arcs ,   color   =   colors )  tight_layout ()", 
            "title": "Boundary Maps"
        }, 
        {
            "location": "/basic/phasespaces/#phase-space-portions", 
            "text": "It is possible to compute the portion of phase space covered by a particle as it is evolved in time. We have two methods, one for the \"boundary\" coordinates (2D space) and one for the \"real\" coordinates (3D space):  #  DynamicalBilliards.boundarymap_portion     Function .  boundarymap_portion(bd::Billiard, t, p::AbstractParticle, \u03b4\u03be, \u03b4\u03c6 = \u03b4\u03be)  Calculate the portion of the boundary map of the billiard  bd  covered by the particle  p  when it is evolved for time  t  (float or integer). Notice that the  The boundary map is partitioned into boxes of size  (\u03b4\u03be, \u03b4\u03c6)  and as the particle evolves visited boxes are counted. The returned ratio is this count divided by the total boxes of size  (\u03b4\u03be, \u03b4\u03c6)  needed to cover the boundary map.  Important:  This portion  does not  equate the portion the particle's orbit covers on the full, three dimensional phase space. Use the function  phasespace_portion  for that!  source  #  DynamicalBilliards.phasespace_portion     Function .  phasespace_portion(bd::Billiard, t, p::AbstractParticle, \u03b4\u03be, \u03b4\u03c6 = \u03b4\u03be)  Calculate the portion of the phase space of the billiard  bd  covered by the particle  p  when it is evolved for time  t  (float or integer).  This function extends  boundarymap_portion  using a novel approach. For each visited box of the boundary map,  bounce!  attributes a third dimension (the collision time, equal to collision distance) which expands the two dimensions of the boundary map to the three dimensions of the phase space.  The true phase space portion is then the weighted portion of boxes visited by the particle, divided by the total weighted sum of boxes. The weights of the boxes are the collision times.  source   For example, for mushroom billiards the ratio of the chaotic-to-total phase space is known  analytically  for both the full 3D [1] space as well as the boundary 2D [2] space:   \n\\begin{aligned}\n  g_\\text{c, 3D}  = \\frac{2 \\, \\pi r^{2} - 4 \\, r^{2} \\arccos\\left(\\frac{w}{2 \\, r}\\right) + 4 \\, l w + \\sqrt{4 \\, r^{2} - w^{2}} w}{2 \\, {\\left(\\pi r^{2} + 2 \\, l w\\right)}}\\\\\n  g_\\text{c, 2D}  = \\frac{\\pi w + 2 \\, w \\arccos\\left(\\frac{w}{2 \\, r}\\right) + 4 \\, l + 4 \\, r - 2 \\, \\sqrt{4 \\, r^{2} - w^{2}}}{2 \\, {\\left(\\pi r + 2 \\, l + 2 \\, r\\right)}}\n\\end{aligned}  \n\\begin{aligned}\n  g_\\text{c, 3D} &= \\frac{2 \\, \\pi r^{2} - 4 \\, r^{2} \\arccos\\left(\\frac{w}{2 \\, r}\\right) + 4 \\, l w + \\sqrt{4 \\, r^{2} - w^{2}} w}{2 \\, {\\left(\\pi r^{2} + 2 \\, l w\\right)}}\\\\\n  g_\\text{c, 2D} &= \\frac{\\pi w + 2 \\, w \\arccos\\left(\\frac{w}{2 \\, r}\\right) + 4 \\, l + 4 \\, r - 2 \\, \\sqrt{4 \\, r^{2} - w^{2}}}{2 \\, {\\left(\\pi r + 2 \\, l + 2 \\, r\\right)}}\n\\end{aligned}   We can easily confirm those formulas:  using   DynamicalBilliards  t   =   1000000.0  l   =   1.0 ;   r   =   1.0 ;   w   =   0.4  bd   =   billiard_mushroom ( l ,   w ,   r )  p   =   MushroomTools . randomchaotic ( l ,   w ,   r )  ratio ,   dic   =   boundarymap_portion ( bd ,   t ,   p ,   0.01 )  trueratio   =   MushroomTools . g_c_2D ( l , w , r )  println ( 2D numeric - theory:  $ ( abs ( ratio   -   trueratio )) )  ratio   =   phasespace_portion ( bd ,   t ,   p ,   0.01 )  trueratio   =   MushroomTools . g_c_3D ( l , w , r )  println ( 3D numeric - theory:  $ ( abs ( ratio   -   trueratio )) )   2D numeric - theory: 1.240333694096929e-5\n3D numeric - theory: 0.0010514688950296613  Of course, increasing evolution time and decreasing boxsize will bring higher accuracy.", 
            "title": "Phase Space Portions"
        }, 
        {
            "location": "/basic/phasespaces/#references", 
            "text": "[1] : A. H. Barnett   T. Betcke,  Quantum mushroom billiards ,  Chaos, 17(4) (20017)  [2] : Lukas Hupe, B.Sc. Thesis (2018),  to be published", 
            "title": "References"
        }, 
        {
            "location": "/ray-splitting/", 
            "text": "Ray-Splitting\n\n\nRay-splitting is a semi-classical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission \n refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three simple steps. We will introduce them and demonstrate them using a simple example in this documentation page.\n\n\n\n\n1. Ray-Splitting Obstacles\n\n\nThe first step is that an \nObstacle\n that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called \npflag\n (propagation flag). This field notes on which side of the obstacle the particle is currently propagating.\n\n\nThe normal vector as well as the distance from boundary change sign depending on the value of \npflag\n. The obstacles \nAntidot\n and \nSplitterWall\n are the equivalents of disk and wall for ray-splitting.\n\n\nLet's create a billiard with a bunch of ray-splitting obstacles!\n\n\nusing\n \nDynamicalBilliards\n\n\nx\n,\n \ny\n \n=\n \n2.0\n,\n \n1.0\n\n\nbdr\n \n=\n  \nbilliard_rectangle\n(\nx\n,\n \ny\n)\n\n\nsw\n \n=\n \nSplitterWall\n([\nx\n/\n2\n,\n \n0.0\n],\n \n[\nx\n/\n2\n,\ny\n],\n \n[\n-\n1\n,\n0\n],\n \ntrue\n)\n\n\na1\n \n=\n \nAntidot\n([\nx\n/\n4\n,\n \ny\n/\n2\n],\n \n0.25\n,\n \nLeft Antidot\n)\n\n\na2\n \n=\n \nAntidot\n([\n3\nx\n/\n4\n,\n \ny\n/\n2\n],\n \n0.15\n,\n \nRight Antidot\n)\n\n\nbd\n \n=\n \nBilliard\n(\na1\n,\n \na2\n,\n \nsw\n,\n \nbdr\n...\n)\n\n\n\n\n\n\nBilliard{Float64} with 7 obstacles:\n  Left Antidot\n  Right Antidot\n  Splitter wall\n  Bottom wall\n  Right wall\n  Top wall\n  Left wall\n\n\n\n\n\nusing\n \nPyPlot\n\n\nplot\n(\nbd\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. The \nRaySplitter\n structure\n\n\nIn the second step, you have to define 2+1 functions: transmission probability, refraction angle and optionally new angular velocity after transmission. These functions, as well as which obstacles participate in ray-splitting, are bundled into a special structure:\n\n\n#\n\n\nDynamicalBilliards.RaySplitter\n \n \nType\n.\n\n\nRaySplitter(idxs, transmission, refraction [, newangular]; affect)\n\n\n\n\n\nReturn a \nRaySplitter\n instance, used to perform raysplitting. \nidxs\n is a \nVector{Int}\n with the indices of the obstacles that this \nRaySplitter\n corresponds to.\n\n\ntransmission\n, \nrefraction\n and \nnewangular\n are \nfunctions\n. Let \n\u03c6\n be the angle of incidence and \n\u03c9\n be the angular velocity and \npflag\n the propagation flag (before transmission). The functions have the following signatures:\n\n\n\n\ntransmission(\u03c6, pflag, \u03c9) -\n T\n, transmission probability.\n\n\nrefraction(\u03c6, pflag, \u03c9) -\n \u03b8\n, refraction angle. This angle is \nrelative\n to the normal vector.\n\n\nnewangular(\u03c9, pflag) -\n new\u03c9\n, new angular velocity after transmission.\n\n\n\n\nThe above three functions use the \nsame convention\n: the argument \npflag\n is the one the obstacle has \nbefore transmission\n. For example, if a particle is outside an \nAntidot\n (with \npflag = true\n here) and is transmitted inside the \nAntidot\n (\npflag\n becomes \nfalse\n here), then all three functions will be given their second argument (the Boolean one) as \ntrue\n!\n\n\naffect\n is a function, and denotes which obstacles of the billiard are affected when transmission occurs at obstacle \ni\n (for which obstacles should the field \npflag\n be reversed). Defaults to \nidxs = (i) -\n i\n, i.e. only the colliding obstacle is affected. If you want many obstacles to be affected you could write \nidxs = (i) -\n SVector(2,3,5)\n, etc. Keep in mind that the only values of \ni\n that can be passed into this function are the ones that are given in the argument \nidxs\n!\n\n\nsource\n\n\n\n\nIf you want different type of transmission/refraction functions for different obstacles, then you define multiple \nRaySplitter\ns.\n\n\nContinuing from the above billiard, let's also create some \nRaySplitter\n instances for it.\n\n\nFirst define a refraction function\n\n\nrefraction\n(\n\u03c6\n,\n \npflag\n,\n \n\u03c9\n)\n \n=\n \npflag\n \n?\n \n0.5\n\u03c6\n \n:\n \n2.0\n\u03c6\n\n\n\n\n\n\nrefraction (generic function with 1 method)\n\n\n\n\n\nThen, a transmission probability function. In this example, we want to create a function that given some factor \np\n, it returns a probability weighted with \np\n in one direction of ray-splitting and \n1-p\n in another direction.\n\n\ntransmission_p\n(\np\n)\n \n=\n \n(\n\u03c6\n,\n \npflag\n,\n \n\u03c9\n)\n \n-\n \nbegin\n\n    \nif\n \npflag\n\n        \np\n*\nexp\n(\n-\n(\n\u03c6\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n8\n)\n^\n2\n)\n\n    \nelse\n\n        \nabs\n(\n\u03c6\n)\n \n \n\u03c0\n/\n4\n \n?\n \n(\n1\n-\np\n)\n*\nexp\n(\n-\n(\n\u03c6\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n4\n)\n^\n2\n)\n \n:\n \n0.0\n\n    \nend\n\n\nend\n\n\n\n\n\n\ntransmission_p (generic function with 1 method)\n\n\n\n\n\nNotice also how we defined the function in such a way that critical refraction is respected, i.e. if \n\u03b8(\u03c6) \u2265 \u03c0/2\n then \nT(\u03c6) = 0\n. Although this is necessary from a physical perspective, the code does take care of it by clamping the refraction angle (see below).\n\n\nLastly, for this example we will use magnetic propagation. We define functions such that the antidots also reverse the direction and magnitude of the magnetic field.\n\n\nnewoantidot\n(\nx\n,\n \nbool\n)\n \n=\n  \nbool\n \n?\n \n-\n2.0\nx\n \n:\n \n-\n0.5\nx\n\n\nnewowall\n(\nx\n,\n \nbool\n)\n \n=\n \nbool\n \n?\n \n0.5\nx\n \n:\n \n2.0\nx\n\n\n\n\n\n\nnewowall (generic function with 1 method)\n\n\n\n\n\nNow we create the \nRaySplitter\n instances we want\n\n\nraywall\n \n=\n \nRaySplitter\n([\n3\n],\n \ntransmission_p\n(\n0.5\n),\n \nrefraction\n,\n \nnewowall\n)\n\n\nraya\n \n=\n \nRaySplitter\n([\n1\n,\n \n2\n],\n \ntransmission_p\n(\n0.8\n),\n \nrefraction\n,\n \nnewoantidot\n)\n\n\n\n\n\n\nRaySplitter for indices [1, 2]\n transmission: getfield(Main.ex-ray, Symbol(\n##1#2\n)){Float64}(0.8)\n refraction:   Main.ex-ray.refraction\n new angular:  Main.ex-ray.newoantidot\n affect:       default\n\n\n\n\n\nBecause we want to use same functions for both antidots, we gave both indices in \nraya\n, \n[1, 2]\n (which are the indices of the antidots in the billiard \nbd\n).\n\n\n\n\n3. Evolution with Ray-Splitting\n\n\nThe third step is trivial. After you have created your \nRaySplitter\n(s), you simply pass them into \nevolve\n or \nanimate_evolution\n as a fourth argument! If you have many instances of \nRaySplitter\n you pass a tuple of them.\n\n\nFor example,\n\n\np\n \n=\n \nrandominside\n(\nbd\n,\n \n1.0\n)\n\n\nraysplitters\n \n=\n \n(\nraywall\n,\n \nraya\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \ntt\n \n=\n \ntimeseries\n(\np\n,\n \nbd\n,\n \n100\n,\n \nraysplitters\n)\n\n\nplot\n(\nbd\n)\n\n\nplot\n(\nxt\n,\n \nyt\n)\n\n\nscatter\n(\nxt\n[\n1\n],\n \nyt\n[\n1\n],\n \ncolor\n \n=\n \nblack\n)\n\n\n\n\n\n\n\n\nYou can see that at some points the particle crossed the boundaries of the red obstacles, which allow for ray splitting. It is even cooler to animate this motion using \nanimate_evolution\n!\n\n\n \n \n\n\n\n\n\nResetting the billiard\n\n\nNotice that evolving a particle inside a billiard always mutates the billiard if ray-splitting is used. This means that you should always set the fields \npflag\n of some obstacles to the values you desire after \neach\n call to \nevolve\n. If you use the function \nrandominside\n you must definitely do this!\n\n\nThe function \nreset_billiard!(bd)\n turns all \npflag\ns to \ntrue\n.\n\n\n\n\n\n\nAngle of refraction is clamped\n\n\nInternally we clamp the output of the angle of refraction function. Let \nc = DynamicalBilliards.CLAMPING_ANGLE\n (currently \nc = 0.1\n). We clamp \n\u03b8\n to \n-\u03c0/2 + c \u2264 \u03b8 \u2264 \u03c0/2 - c\n. This is so that the relocating algorithm does not fall into an infinite loop.\n\n\n\n\n    You can change the value of `c` but very small values can lead to infinite loops in extreme cases.\n\n\n\n\n\n\n\nThe Ray-Splitting Algorithm\n\n\nIn this section we describe the algorithm we follow to implement the ray-splitting process. Let \nT\nT\n denote the transmission function, \n\\theta\n\\theta\n the refraction function and \n\\omega_{\\text{new}}\n\\omega_{\\text{new}}\n the new angular velocity function. The following describes the process after a particle has reached an obstacle that supports ray-splitting.\n\n\n\n\nFind the angle of incidence \n\\phi' = \\pi - \\arccos(\\vec{v} \\cdot \\vec{n}) = \\arccos(\\vec{v} \\cdot (-\\vec{n}))\n\\phi' = \\pi - \\arccos(\\vec{v} \\cdot \\vec{n}) = \\arccos(\\vec{v} \\cdot (-\\vec{n}))\n with \n\\vec{n}\n\\vec{n}\n the normal vector at collision point. Notice that we use here \n-\\vec{n}\n-\\vec{n}\n because the velocity is opposing the normal vector before the collision happens. Using \n-\\vec{n}\n-\\vec{n}\n gives the angle between 0 and \n\\pi/2\n\\pi/2\n instead of \n\\pi/2\n\\pi/2\n to \n\\pi\n\\pi\n.\n\n\nFind the \ncorrect\n sign of the incidence angle, \n\\phi = \\pm \\phi'\n\\phi = \\pm \\phi'\n. Specifically, use the cross product: if the third entry of \n\\vec{v} \\times \\vec{n}\n\\vec{v} \\times \\vec{n}\n is negative, then have minus sign. The \"correct\" sign debates on whether the velocity vector is to the right or to the left of \n(-\\vec{n})\n(-\\vec{n})\n. This is important for finding the correct transmission angle and/or probability.\n\n\nCheck if \nT(\\phi, \\verb|pflag|, \\omega) \n \\text{random}()\nT(\\phi, \\verb|pflag|, \\omega) > \\text{random}()\n. If not, do standard specular reflection.\n\n\nIf ray-splitting happens, then relocate the particle so that it is on the \nother\n side of the colliding obstacle. This contrasts the main evolution algorithm of this billiard package.\n\n\nRe-compute the \ncorrect\n angle of incidence, as the position of the particle generally changes with relocating.\n\n\nFind refraction angle \n\\theta(\\phi, \\verb|pflag|, \\omega)\n\\theta(\\phi, \\verb|pflag|, \\omega)\n. Notice that this is a relative angle with respect to the normal vector. Also notice that \n\\theta\n\\theta\n may have opposite sign from \n\\phi\n\\phi\n. It depends on the user if they want to add anomalous refraction.\n\n\nSet \nobstacle.pflag = !obstacle.pflag\n for \nall\n obstacles affected by the current \nRaySplitter\n. This reverses \n\\vec{n}\n\\vec{n}\n to \n-\\vec{n}\n-\\vec{n}\n as well! So from now on \n\\vec{n}\n\\vec{n}\n is the opposite than what it was at the beginning of the algorithm!\n\n\nFind the refraction angle in absolute space. First find \na = \\text{atan}(n_y, n_x)\na = \\text{atan}(n_y, n_x)\n and then set \n\\Theta = a + \\theta\n\\Theta = a + \\theta\n.\n\n\nPerform refraction, i.e. set the particle velocity to the direction of \n\\Theta\n\\Theta\n.\n\n\nScale the magnetic field, i.e. set \np.omega\n = \n\\omega_{\\text{new}}(\\omega, \\verb|!pflag|)\n\\omega_{\\text{new}}(\\omega, \\verb|!pflag|)\n. It is important to note that we use \n!pflag\n because we have already changed the \npflag\n field.\n\n\n\n\n\n\nPhysics of the Ray-Splitting Functions\n\n\nIf \nT\n is the transmission probability function, then the condition for transmission is simply: \nT(\u03c6, pflag, \u03c9) \n rand()\n. If it returns \ntrue\n, transmission (i.e. ray-splitting) will happen.\n\n\nThe functions given to \nRaySplitter\n should have some properties in order to have physical meaning. In order to test if the \nRaySplitter\n you have defined has physical meaning, the function \nisphysical\n is provided\n\n\n#\n\n\nDynamicalBilliards.isphysical\n \n \nFunction\n.\n\n\nisphysical(raysplitter(s))\n\n\n\n\n\nReturn \ntrue\n if the given \nraysplitters\n have physically plausible properties.\n\n\nSpecifically, check if (\u03c6 is the incidence angle, \u03b8 the refraction angle):\n\n\n\n\nCritical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then Tr(\u03c6) = 0\n\n\nTransmission probability is even function: Tr(\u03c6) \u2248 Tr(-\u03c6) at \u03c9 = 0\n\n\nRefraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6) at \u03c9 = 0\n\n\nRay reversal is true: \u03b8(\u03b8(\u03c6, pflag, \u03c9), !pflag, \u03c9) \u2248 \u03c6\n\n\nMagnetic conservation is true: (\u03c9\nnew(\u03c9\nnew(\u03c9, pflag), !pflag) \u2248 \u03c9\n\n\n\n\nsource\n\n\n\n\nSnell's Law\n\n\nIn classical geometric optics, the refraction of a ray of light moving from one medium to another is described by Snell's law. For an angle of incidence of \n\\phi\n\\phi\n, the refraction angle \n\\theta\n\\theta\n is determined by the equation\n\n\n\n\n\n\\frac{sin(\\phi)}{\\sin(\\theta)} = \\frac{n'}{n}\n\n\n\n\n\\frac{sin(\\phi)}{\\sin(\\theta)} = \\frac{n'}{n}\n\n\n\n\n\nwhere \nn\nn\n and \nn'\nn'\n are the respective refractive indices of the media.\n\n\nTo easily simulate these relations in \nDynamicalBilliards\n, the function \nlaw_of_refraction\n can be used to set up ray-splitting according to this law.\n\n\n#\n\n\nDynamicalBilliards.law_of_refraction\n \n \nFunction\n.\n\n\nlaw_of_refraction(n1, n2 = 1.0) -\n t, r\n\n\n\n\n\nCreate transmission and refraction functions \nt, r\n that follow Snell's law, i.e. the transmission probability is set to 1.0 except for the case of total internal reflection. \n\n\nn1\n is the index of refraction for the \npflag = false\n side of an obstacle, while \nn2\n is the index of refraction for \npflag = true\n.\n\n\nsource\n\n\nUsing the functions returned by \nlaw_of_refraction\n, we can set up a \nRaySplitter\n for a billiard.\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\n# Create a circular \nlens\n\n\no\n \n=\n \nAntidot\n(\nSVector\n(\n1.0\n,\n \n0.75\n),\n \n0.5\n)\n\n\n# in a rectangular box\n\n\nbd\n \n=\n \nBilliard\n(\nbilliard_rectangle\n(\n2.5\n,\n \n1.5\n)\n...\n,\n \no\n)\n\n\n# create a RaySplitter using law of refraction\n\n\ntrans\n,\n \nrefra\n \n=\n \nlaw_of_refraction\n(\n1.5\n)\n\n\nrs\n \n=\n \n(\nRaySplitter\n([\n5\n],\n \ntrans\n,\n \nrefra\n),)\n\n\n\n\n\n\n(RaySplitter for indices [5],)\n\n\n\n\n\nWe now animate the evolution of an array of particles on parallel trajectories to demonstrate the refractive properties of the spherical lens\n\n\n# create parallel particles\n\n\nps\n \n=\n \n[\nParticle\n(\n0.1\n,\n \ny\n,\n \n0.0\n)\n \nfor\n \ny\n \nin\n \n0.4\n:\n0.05\n:\n1.1\n]\n\n\n\n# animate\n\n\nanimate_evolution\n(\nps\n,\n \nbd\n,\n \n2.0\n,\n \nrs\n,\n \ncolors\n \n=\n \n[\nC0\n \nfor\n \ni\n \n\u2208\n \n1\n:\nlength\n(\nps\n)],\n\n    \ntailtime\n=\n2.5\n,\n \nsavename\n \n=\n \nlens\n)\n\n\n\n\n\n\n \n \n\n\n\n\n\nExample of Affecting Multiple Obstacles\n\n\nHere we will show an application of \ninverse\n billiards, where particles go in and out of a billiard, while taking advantage of the existence of a magnetic field outside to return.\n\n\nAs always, we define the ray-splitting functions:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\ntrans\n(\nargs\n...\n)\n \n=\n \n1.0\n \n# always perfect transmission\n\n\nrefra\n(\n\u03c6\n,\n \npflag\n,\n \n\u03c9\n)\n \n=\n \npflag\n \n?\n \n0.8\n\u03c6\n \n:\n \n1.25\n\u03c6\n \n# refraction angle\n\n\nneww\n(\n\u03c9\n,\n \npflag\n)\n \n=\n \npflag\n \n?\n \n2.0\n \n:\n \n0.4\n\n\n\n\n\n\nneww (generic function with 1 method)\n\n\n\n\n\nNow, when we define the \nRaySplitter\n instance we will choose a different value for \naffect\n:\n\n\nray\n \n=\n \nRaySplitter\n([\n1\n,\n2\n,\n3\n,\n4\n],\n \ntrans\n,\n \nrefra\n,\n \nneww\n,\n \naffect\n \n=\n \n(\ni\n)\n \n-\n \nSVector\n(\n1\n,\n2\n,\n3\n,\n4\n))\n\n\n\n\n\n\nRaySplitter for indices [1, 2, 3, 4]\n transmission: Main.ex-ray.trans\n refraction:   Main.ex-ray.refra\n new angular:  Main.ex-ray.neww\n affect:       getfield(Main.ex-ray, Symbol(\n##3#4\n))()\n\n\n\n\n\nWe initialize a simple rectangular billiard and a particle\n\n\nbd\n \n=\n \nbilliard_rectangle\n(\nsetting\n \n=\n \nray-splitting\n)\n\n\np\n \n=\n \nMagneticParticle\n(\n0.4\n,\n \n0.6\n,\n \n0.0\n,\n \n0.4\n)\n\n\n\n\n\n\nMagneticParticle{Float64}\nposition: [0.4, 0.6]\nvelocity: [1.0, 0.0]\nang. velocity: 0.4\n\n\n\n\n\nand we animate its evolution, by first zooming out of the billiard\n\n\nplot\n(\nbd\n)\n\n\nxlim\n(\n-\n1\n,\n \n2\n);\n \nylim\n(\n-\n1\n,\n \n2\n);\n\n\nanimate_evolution\n(\np\n,\n \nbd\n,\n \n10.0\n,\n \n(\nray\n,);\n \nax\n \n=\n \ngca\n(),\n \nsavename\n \n=\n \ninverse\n,\n \ntailtime\n \n=\n \n3.0\n)", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/ray-splitting/#ray-splitting", 
            "text": "Ray-splitting is a semi-classical approach to the billiard system, giving a wave attribute to the ray traced by the particle. Upon collision a particle may propagate through an obstacle (transmission   refraction) or be reflected. Following the mindset of this package, implementing a ray-splitting billiard requires only three simple steps. We will introduce them and demonstrate them using a simple example in this documentation page.", 
            "title": "Ray-Splitting"
        }, 
        {
            "location": "/ray-splitting/#1-ray-splitting-obstacles", 
            "text": "The first step is that an  Obstacle  that supports ray-splitting is required to be present in your billiard table. The only new feature these obstacles have is an additional Boolean field called  pflag  (propagation flag). This field notes on which side of the obstacle the particle is currently propagating.  The normal vector as well as the distance from boundary change sign depending on the value of  pflag . The obstacles  Antidot  and  SplitterWall  are the equivalents of disk and wall for ray-splitting.  Let's create a billiard with a bunch of ray-splitting obstacles!  using   DynamicalBilliards  x ,   y   =   2.0 ,   1.0  bdr   =    billiard_rectangle ( x ,   y )  sw   =   SplitterWall ([ x / 2 ,   0.0 ],   [ x / 2 , y ],   [ - 1 , 0 ],   true )  a1   =   Antidot ([ x / 4 ,   y / 2 ],   0.25 ,   Left Antidot )  a2   =   Antidot ([ 3 x / 4 ,   y / 2 ],   0.15 ,   Right Antidot )  bd   =   Billiard ( a1 ,   a2 ,   sw ,   bdr ... )   Billiard{Float64} with 7 obstacles:\n  Left Antidot\n  Right Antidot\n  Splitter wall\n  Bottom wall\n  Right wall\n  Top wall\n  Left wall  using   PyPlot  plot ( bd )", 
            "title": "1. Ray-Splitting Obstacles"
        }, 
        {
            "location": "/ray-splitting/#2-the-raysplitter-structure", 
            "text": "In the second step, you have to define 2+1 functions: transmission probability, refraction angle and optionally new angular velocity after transmission. These functions, as well as which obstacles participate in ray-splitting, are bundled into a special structure:  #  DynamicalBilliards.RaySplitter     Type .  RaySplitter(idxs, transmission, refraction [, newangular]; affect)  Return a  RaySplitter  instance, used to perform raysplitting.  idxs  is a  Vector{Int}  with the indices of the obstacles that this  RaySplitter  corresponds to.  transmission ,  refraction  and  newangular  are  functions . Let  \u03c6  be the angle of incidence and  \u03c9  be the angular velocity and  pflag  the propagation flag (before transmission). The functions have the following signatures:   transmission(\u03c6, pflag, \u03c9) -  T , transmission probability.  refraction(\u03c6, pflag, \u03c9) -  \u03b8 , refraction angle. This angle is  relative  to the normal vector.  newangular(\u03c9, pflag) -  new\u03c9 , new angular velocity after transmission.   The above three functions use the  same convention : the argument  pflag  is the one the obstacle has  before transmission . For example, if a particle is outside an  Antidot  (with  pflag = true  here) and is transmitted inside the  Antidot  ( pflag  becomes  false  here), then all three functions will be given their second argument (the Boolean one) as  true !  affect  is a function, and denotes which obstacles of the billiard are affected when transmission occurs at obstacle  i  (for which obstacles should the field  pflag  be reversed). Defaults to  idxs = (i) -  i , i.e. only the colliding obstacle is affected. If you want many obstacles to be affected you could write  idxs = (i) -  SVector(2,3,5) , etc. Keep in mind that the only values of  i  that can be passed into this function are the ones that are given in the argument  idxs !  source   If you want different type of transmission/refraction functions for different obstacles, then you define multiple  RaySplitter s.  Continuing from the above billiard, let's also create some  RaySplitter  instances for it.  First define a refraction function  refraction ( \u03c6 ,   pflag ,   \u03c9 )   =   pflag   ?   0.5 \u03c6   :   2.0 \u03c6   refraction (generic function with 1 method)  Then, a transmission probability function. In this example, we want to create a function that given some factor  p , it returns a probability weighted with  p  in one direction of ray-splitting and  1-p  in another direction.  transmission_p ( p )   =   ( \u03c6 ,   pflag ,   \u03c9 )   -   begin \n     if   pflag \n         p * exp ( - ( \u03c6 ) ^ 2 / 2 ( \u03c0 / 8 ) ^ 2 ) \n     else \n         abs ( \u03c6 )     \u03c0 / 4   ?   ( 1 - p ) * exp ( - ( \u03c6 ) ^ 2 / 2 ( \u03c0 / 4 ) ^ 2 )   :   0.0 \n     end  end   transmission_p (generic function with 1 method)  Notice also how we defined the function in such a way that critical refraction is respected, i.e. if  \u03b8(\u03c6) \u2265 \u03c0/2  then  T(\u03c6) = 0 . Although this is necessary from a physical perspective, the code does take care of it by clamping the refraction angle (see below).  Lastly, for this example we will use magnetic propagation. We define functions such that the antidots also reverse the direction and magnitude of the magnetic field.  newoantidot ( x ,   bool )   =    bool   ?   - 2.0 x   :   - 0.5 x  newowall ( x ,   bool )   =   bool   ?   0.5 x   :   2.0 x   newowall (generic function with 1 method)  Now we create the  RaySplitter  instances we want  raywall   =   RaySplitter ([ 3 ],   transmission_p ( 0.5 ),   refraction ,   newowall )  raya   =   RaySplitter ([ 1 ,   2 ],   transmission_p ( 0.8 ),   refraction ,   newoantidot )   RaySplitter for indices [1, 2]\n transmission: getfield(Main.ex-ray, Symbol( ##1#2 )){Float64}(0.8)\n refraction:   Main.ex-ray.refraction\n new angular:  Main.ex-ray.newoantidot\n affect:       default  Because we want to use same functions for both antidots, we gave both indices in  raya ,  [1, 2]  (which are the indices of the antidots in the billiard  bd ).", 
            "title": "2. The RaySplitter structure"
        }, 
        {
            "location": "/ray-splitting/#3-evolution-with-ray-splitting", 
            "text": "The third step is trivial. After you have created your  RaySplitter (s), you simply pass them into  evolve  or  animate_evolution  as a fourth argument! If you have many instances of  RaySplitter  you pass a tuple of them.  For example,  p   =   randominside ( bd ,   1.0 )  raysplitters   =   ( raywall ,   raya )  xt ,   yt ,   vxt ,   vyt ,   tt   =   timeseries ( p ,   bd ,   100 ,   raysplitters )  plot ( bd )  plot ( xt ,   yt )  scatter ( xt [ 1 ],   yt [ 1 ],   color   =   black )    You can see that at some points the particle crossed the boundaries of the red obstacles, which allow for ray splitting. It is even cooler to animate this motion using  animate_evolution !        Resetting the billiard  Notice that evolving a particle inside a billiard always mutates the billiard if ray-splitting is used. This means that you should always set the fields  pflag  of some obstacles to the values you desire after  each  call to  evolve . If you use the function  randominside  you must definitely do this!  The function  reset_billiard!(bd)  turns all  pflag s to  true .    Angle of refraction is clamped  Internally we clamp the output of the angle of refraction function. Let  c = DynamicalBilliards.CLAMPING_ANGLE  (currently  c = 0.1 ). We clamp  \u03b8  to  -\u03c0/2 + c \u2264 \u03b8 \u2264 \u03c0/2 - c . This is so that the relocating algorithm does not fall into an infinite loop.       You can change the value of `c` but very small values can lead to infinite loops in extreme cases.", 
            "title": "3. Evolution with Ray-Splitting"
        }, 
        {
            "location": "/ray-splitting/#the-ray-splitting-algorithm", 
            "text": "In this section we describe the algorithm we follow to implement the ray-splitting process. Let  T T  denote the transmission function,  \\theta \\theta  the refraction function and  \\omega_{\\text{new}} \\omega_{\\text{new}}  the new angular velocity function. The following describes the process after a particle has reached an obstacle that supports ray-splitting.   Find the angle of incidence  \\phi' = \\pi - \\arccos(\\vec{v} \\cdot \\vec{n}) = \\arccos(\\vec{v} \\cdot (-\\vec{n})) \\phi' = \\pi - \\arccos(\\vec{v} \\cdot \\vec{n}) = \\arccos(\\vec{v} \\cdot (-\\vec{n}))  with  \\vec{n} \\vec{n}  the normal vector at collision point. Notice that we use here  -\\vec{n} -\\vec{n}  because the velocity is opposing the normal vector before the collision happens. Using  -\\vec{n} -\\vec{n}  gives the angle between 0 and  \\pi/2 \\pi/2  instead of  \\pi/2 \\pi/2  to  \\pi \\pi .  Find the  correct  sign of the incidence angle,  \\phi = \\pm \\phi' \\phi = \\pm \\phi' . Specifically, use the cross product: if the third entry of  \\vec{v} \\times \\vec{n} \\vec{v} \\times \\vec{n}  is negative, then have minus sign. The \"correct\" sign debates on whether the velocity vector is to the right or to the left of  (-\\vec{n}) (-\\vec{n}) . This is important for finding the correct transmission angle and/or probability.  Check if  T(\\phi, \\verb|pflag|, \\omega)   \\text{random}() T(\\phi, \\verb|pflag|, \\omega) > \\text{random}() . If not, do standard specular reflection.  If ray-splitting happens, then relocate the particle so that it is on the  other  side of the colliding obstacle. This contrasts the main evolution algorithm of this billiard package.  Re-compute the  correct  angle of incidence, as the position of the particle generally changes with relocating.  Find refraction angle  \\theta(\\phi, \\verb|pflag|, \\omega) \\theta(\\phi, \\verb|pflag|, \\omega) . Notice that this is a relative angle with respect to the normal vector. Also notice that  \\theta \\theta  may have opposite sign from  \\phi \\phi . It depends on the user if they want to add anomalous refraction.  Set  obstacle.pflag = !obstacle.pflag  for  all  obstacles affected by the current  RaySplitter . This reverses  \\vec{n} \\vec{n}  to  -\\vec{n} -\\vec{n}  as well! So from now on  \\vec{n} \\vec{n}  is the opposite than what it was at the beginning of the algorithm!  Find the refraction angle in absolute space. First find  a = \\text{atan}(n_y, n_x) a = \\text{atan}(n_y, n_x)  and then set  \\Theta = a + \\theta \\Theta = a + \\theta .  Perform refraction, i.e. set the particle velocity to the direction of  \\Theta \\Theta .  Scale the magnetic field, i.e. set  p.omega  =  \\omega_{\\text{new}}(\\omega, \\verb|!pflag|) \\omega_{\\text{new}}(\\omega, \\verb|!pflag|) . It is important to note that we use  !pflag  because we have already changed the  pflag  field.", 
            "title": "The Ray-Splitting Algorithm"
        }, 
        {
            "location": "/ray-splitting/#physics-of-the-ray-splitting-functions", 
            "text": "If  T  is the transmission probability function, then the condition for transmission is simply:  T(\u03c6, pflag, \u03c9)   rand() . If it returns  true , transmission (i.e. ray-splitting) will happen.  The functions given to  RaySplitter  should have some properties in order to have physical meaning. In order to test if the  RaySplitter  you have defined has physical meaning, the function  isphysical  is provided  #  DynamicalBilliards.isphysical     Function .  isphysical(raysplitter(s))  Return  true  if the given  raysplitters  have physically plausible properties.  Specifically, check if (\u03c6 is the incidence angle, \u03b8 the refraction angle):   Critical angle means total reflection: If \u03b8(\u03c6) \u2265 \u03c0/2 then Tr(\u03c6) = 0  Transmission probability is even function: Tr(\u03c6) \u2248 Tr(-\u03c6) at \u03c9 = 0  Refraction angle is odd function: \u03b8(\u03c6) \u2248 -\u03b8(-\u03c6) at \u03c9 = 0  Ray reversal is true: \u03b8(\u03b8(\u03c6, pflag, \u03c9), !pflag, \u03c9) \u2248 \u03c6  Magnetic conservation is true: (\u03c9 new(\u03c9 new(\u03c9, pflag), !pflag) \u2248 \u03c9   source", 
            "title": "Physics of the Ray-Splitting Functions"
        }, 
        {
            "location": "/ray-splitting/#snells-law", 
            "text": "In classical geometric optics, the refraction of a ray of light moving from one medium to another is described by Snell's law. For an angle of incidence of  \\phi \\phi , the refraction angle  \\theta \\theta  is determined by the equation   \n\\frac{sin(\\phi)}{\\sin(\\theta)} = \\frac{n'}{n}  \n\\frac{sin(\\phi)}{\\sin(\\theta)} = \\frac{n'}{n}   where  n n  and  n' n'  are the respective refractive indices of the media.  To easily simulate these relations in  DynamicalBilliards , the function  law_of_refraction  can be used to set up ray-splitting according to this law.  #  DynamicalBilliards.law_of_refraction     Function .  law_of_refraction(n1, n2 = 1.0) -  t, r  Create transmission and refraction functions  t, r  that follow Snell's law, i.e. the transmission probability is set to 1.0 except for the case of total internal reflection.   n1  is the index of refraction for the  pflag = false  side of an obstacle, while  n2  is the index of refraction for  pflag = true .  source  Using the functions returned by  law_of_refraction , we can set up a  RaySplitter  for a billiard.  using   DynamicalBilliards ,   PyPlot  # Create a circular  lens  o   =   Antidot ( SVector ( 1.0 ,   0.75 ),   0.5 )  # in a rectangular box  bd   =   Billiard ( billiard_rectangle ( 2.5 ,   1.5 ) ... ,   o )  # create a RaySplitter using law of refraction  trans ,   refra   =   law_of_refraction ( 1.5 )  rs   =   ( RaySplitter ([ 5 ],   trans ,   refra ),)   (RaySplitter for indices [5],)  We now animate the evolution of an array of particles on parallel trajectories to demonstrate the refractive properties of the spherical lens  # create parallel particles  ps   =   [ Particle ( 0.1 ,   y ,   0.0 )   for   y   in   0.4 : 0.05 : 1.1 ]  # animate  animate_evolution ( ps ,   bd ,   2.0 ,   rs ,   colors   =   [ C0   for   i   \u2208   1 : length ( ps )], \n     tailtime = 2.5 ,   savename   =   lens )", 
            "title": "Snell's Law"
        }, 
        {
            "location": "/ray-splitting/#example-of-affecting-multiple-obstacles", 
            "text": "Here we will show an application of  inverse  billiards, where particles go in and out of a billiard, while taking advantage of the existence of a magnetic field outside to return.  As always, we define the ray-splitting functions:  using   DynamicalBilliards ,   PyPlot  trans ( args ... )   =   1.0   # always perfect transmission  refra ( \u03c6 ,   pflag ,   \u03c9 )   =   pflag   ?   0.8 \u03c6   :   1.25 \u03c6   # refraction angle  neww ( \u03c9 ,   pflag )   =   pflag   ?   2.0   :   0.4   neww (generic function with 1 method)  Now, when we define the  RaySplitter  instance we will choose a different value for  affect :  ray   =   RaySplitter ([ 1 , 2 , 3 , 4 ],   trans ,   refra ,   neww ,   affect   =   ( i )   -   SVector ( 1 , 2 , 3 , 4 ))   RaySplitter for indices [1, 2, 3, 4]\n transmission: Main.ex-ray.trans\n refraction:   Main.ex-ray.refra\n new angular:  Main.ex-ray.neww\n affect:       getfield(Main.ex-ray, Symbol( ##3#4 ))()  We initialize a simple rectangular billiard and a particle  bd   =   billiard_rectangle ( setting   =   ray-splitting )  p   =   MagneticParticle ( 0.4 ,   0.6 ,   0.0 ,   0.4 )   MagneticParticle{Float64}\nposition: [0.4, 0.6]\nvelocity: [1.0, 0.0]\nang. velocity: 0.4  and we animate its evolution, by first zooming out of the billiard  plot ( bd )  xlim ( - 1 ,   2 );   ylim ( - 1 ,   2 );  animate_evolution ( p ,   bd ,   10.0 ,   ( ray ,);   ax   =   gca (),   savename   =   inverse ,   tailtime   =   3.0 )", 
            "title": "Example of Affecting Multiple Obstacles"
        }, 
        {
            "location": "/lyapunovs/", 
            "text": "The Finite Time Lyapunov Spectrum (FTLS) for a 2D billiard system consists of a set of 4 numbers \n\\lambda_i \\, , \\{ i = 1, ...,4 \\}\n\\lambda_i \\, , \\{ i = 1, ...,4 \\}\n that characterize how fast the separation of initially close initial conditions grows.\n\n\nIt can be shown theoretically that two of these exponents must be zero (\n\\lambda_2\n\\lambda_2\n =\n\\lambda_3\n\\lambda_3\n = 0) and the other two are paired in such a way that they sum up to zero, i.e. \n\\lambda_1 =  -\\lambda_4\n\\lambda_1 =  -\\lambda_4\n).\n\n\nThe function provided to calculate the FTLS is\n\n\n#\n\n\nDynamicalBilliards.lyapunovspectrum\n \n \nFunction\n.\n\n\nlyapunovspectrum([p::AbstractParticle,] bd::Billiard, t)\n\n\n\n\n\nReturns the finite time lyapunov exponents (averaged over time \nt\n) for a given particle in a billiard table using the method outlined in [1].\n\n\nReturns zeros for pinned particles.\n\n\nIf a particle is not given, a random one is picked through \nrandominside\n. See \nparallelize\n for a parallelized version.\n\n\n[1] : Ch. Dellago \net al\n, \nPhys. Rev. E \n53\n (1996)\n\n\nsource\n\n\nHere its basic use is illustrated\n\n\nusing\n \nDynamicalBilliards\n\n\n\nradius\n \n=\n \n1.0\n\n\nl\n \n=\n \n2.0\n\n\n\nbd\n \n=\n \nBilliard\n(\nbilliard_polygon\n(\n6\n,\n \nl\n;\n \nsetting\n \n=\n \nperiodic\n)\n...\n,\n \nDisk\n([\n0.\n,\n \n0.\n],\n \nradius\n))\n\n\n\npar\n \n=\n \nrandominside\n(\nbd\n)\n\n\nt\n \n=\n \n1000.0\n\n\n\nexps\n \n=\n \nlyapunovspectrum\n(\npar\n,\n \nbd\n,\n \nt\n)\n\n\n\n\n\n\n4-element Array{Float64,1}:\n  0.6251840952731427\n  0.00012744054335113797\n -0.0007455710333733346\n -0.6245659647831203\n\n\n\n\n\nIn the following example we compute the change of \n\\lambda_1\\\n\\lambda_1\\\n versus the distance between the disks in a hexagonal periodic billiard.\n\n\nusing\n \nDynamicalBilliards\n\n\nusing\n \nPyPlot\n\n\n\nt\n \n=\n \n5000.0\n\n\nradius\n \n=\n \n1.0\n\n\n\nspaces\n \n=\n \n2.0\n:\n0.1\n:\n4.4\n \n#Distances between adjacent disks\n\n\nlyap_time\n \n=\n \nzero\n(\nspaces\n)\n \n#Array where the exponents will be stored\n\n\n\nfor\n \n(\ni\n,\n \nspace\n)\n \nin\n \nenumerate\n(\nspaces\n)\n\n    \nbd\n \n=\n \nbilliard_polygon\n(\n6\n,\n \nspace\n/\n(\nsqrt\n(\n3\n));\n \nsetting\n \n=\n \nperiodic\n)\n\n    \ndisc\n \n=\n \nDisk\n([\n0.\n,\n \n0.\n],\n \nradius\n)\n\n    \nbilliard\n \n=\n \nBilliard\n(\nbd\n.\nobstacles\n...\n,\n \ndisc\n)\n\n    \np\n \n=\n \nrandominside\n(\nbilliard\n)\n\n    \nlyap_time\n[\ni\n]\n \n=\n \nlyapunovspectrum\n(\np\n,\n \nbilliard\n,\n \nt\n)[\n1\n]\n\n\nend\n\n\nfigure\n()\n\n\nplot\n(\nspaces\n,\n \nlyap_time\n,\n \n*-\n)\n\n\nxlabel\n(\n\\$\nw\n\\$\n);\n \nylabel\n(\n\\$\\\\\nlambda_1\n\\$\n)\n\n\n\n\n\n\n\n\nThe plot of the maximum exponent can be compared with the results reported by \nGaspard et. al\n (see figure 7), showing that using just \nt = 5000.0\n is already enough of a statistical averaging.\n\n\n\n\nPerturbation Growth\n\n\nTo be able to inspect the dynamics of perturbation growth in more detail, we also provide the following function:\n\n\n#\n\n\nDynamicalBilliards.perturbationgrowth\n \n \nFunction\n.\n\n\nperturbationgrowth([p,] bd, t) -\n ts, Rs, is\n\n\n\n\n\nCalculate the evolution of the perturbation vector \n\u0394\n along the trajectory of \np\n in \nbd\n for total time \nt\n. \n\u0394\n is initialised as \n[1,1,1,1]\n.\n\n\nIf a particle is not given, a random one is picked through \nrandominside\n. Returns empty lists for pinned particles.\n\n\nDescription\n\n\nThis function \nsafely\n computes the time evolution of a perturbation vector using the linearized dynamics of the system, as outlined by [1]. Because the dynamics are linear, we can safely re-normalize the perturbation vector after every collision (otherwise the perturbations grow to infinity).\n\n\nImmediately before \nand after\n every collison, this function computes\n\n\n\n\nthe current time.\n\n\nthe element-wise ratio of \u0394 with its previous value\n\n\nthe obstacle index of the current obstacle\n\n\n\n\nand returns these in three vectors \nts, Rs, is\n.\n\n\nTo obtain the \nactual\n evolution of the perturbation vector you can use the function \nperturbationevolution(Rs)\n which simply does\n\n\n\u0394\n \n=\n \nVector\n{\nSVector\n{\n4\n,\nFloat64\n}}(\nundef\n,\n \nlength\n(\nR\n))\n\n\n\u0394\n[\n1\n]\n \n=\n \nR\n[\n1\n]\n\n\nfor\n \ni\n \nin\n \n2\n:\nlength\n(\nR\n)\n\n    \n\u0394\n[\ni\n]\n \n=\n \nR\n[\ni\n]\n \n.*\n \n\u0394\n[\ni\n-\n1\n]\n\n\nend\n\n\n\n\n\n\n[1] : Ch. Dellago \net al\n, \nPhys. Rev. E \n53\n (1996)\n\n\nsource\n\n\n\n\nFor example, lets plot the evolution of the perturbation growth using different colors for collisions with walls and disks in the Sinai billiard:\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n,\n \nLinearAlgebra\n\n\nbd\n \n=\n \nbilliard_sinai\n()\n\n\n\nts\n,\n \nRs\n,\n \nis\n \n=\n \nperturbationgrowth\n(\nParticle\n(\n0.1\n,\n \n0.1\n,\n \n0.1\n),\n \nbd\n,\n \n10.0\n)\n\n\n\u0394\n \n=\n \nperturbationevolution\n(\nRs\n)\n\n\n\nfigure\n()\n\n\nplot\n(\nts\n,\n \nlog\n.\n(\nnorm\n.\n(\n\u0394\n)),\n \nk-\n,\n \nlw\n \n=\n \n0.5\n)\n\n\nscatter\n(\nts\n,\n \nlog\n.\n(\nnorm\n.\n(\n\u0394\n)),\n \nc\n \n=\n \n[\nj\n \n==\n \n1\n \n?\n \nC0\n \n:\n \nC1\n \nfor\n \nj\n \nin\n \nis\n])\n\n\nxlabel\n(\n\\$\nt\n\\$\n);\n \nylabel\n(\n\\$\\\\\nlog(||\n\\\\\nDelta ||)\n\\$\n)", 
            "title": "Lyapunov Exponents"
        }, 
        {
            "location": "/lyapunovs/#perturbation-growth", 
            "text": "To be able to inspect the dynamics of perturbation growth in more detail, we also provide the following function:  #  DynamicalBilliards.perturbationgrowth     Function .  perturbationgrowth([p,] bd, t) -  ts, Rs, is  Calculate the evolution of the perturbation vector  \u0394  along the trajectory of  p  in  bd  for total time  t .  \u0394  is initialised as  [1,1,1,1] .  If a particle is not given, a random one is picked through  randominside . Returns empty lists for pinned particles.  Description  This function  safely  computes the time evolution of a perturbation vector using the linearized dynamics of the system, as outlined by [1]. Because the dynamics are linear, we can safely re-normalize the perturbation vector after every collision (otherwise the perturbations grow to infinity).  Immediately before  and after  every collison, this function computes   the current time.  the element-wise ratio of \u0394 with its previous value  the obstacle index of the current obstacle   and returns these in three vectors  ts, Rs, is .  To obtain the  actual  evolution of the perturbation vector you can use the function  perturbationevolution(Rs)  which simply does  \u0394   =   Vector { SVector { 4 , Float64 }}( undef ,   length ( R ))  \u0394 [ 1 ]   =   R [ 1 ]  for   i   in   2 : length ( R ) \n     \u0394 [ i ]   =   R [ i ]   .*   \u0394 [ i - 1 ]  end   [1] : Ch. Dellago  et al ,  Phys. Rev. E  53  (1996)  source   For example, lets plot the evolution of the perturbation growth using different colors for collisions with walls and disks in the Sinai billiard:  using   DynamicalBilliards ,   PyPlot ,   LinearAlgebra  bd   =   billiard_sinai ()  ts ,   Rs ,   is   =   perturbationgrowth ( Particle ( 0.1 ,   0.1 ,   0.1 ),   bd ,   10.0 )  \u0394   =   perturbationevolution ( Rs )  figure ()  plot ( ts ,   log . ( norm . ( \u0394 )),   k- ,   lw   =   0.5 )  scatter ( ts ,   log . ( norm . ( \u0394 )),   c   =   [ j   ==   1   ?   C0   :   C1   for   j   in   is ])  xlabel ( \\$ t \\$ );   ylabel ( \\$\\\\ log(|| \\\\ Delta ||) \\$ )", 
            "title": "Perturbation Growth"
        }, 
        {
            "location": "/mushroomtools/", 
            "text": "#\n\n\nDynamicalBilliards.MushroomTools\n \n \nModule\n.\n\n\nMushroomTools\n\n\n\n\n\nModule containing many functions helpful in simulating (perfect) mushroom billiards, see \nbilliard_mushroom\n. Contains stuff like initializing efficiently regular or chaotic particles and functions that return the corresponding chaotic or regular phase-space volumes or portions. The functions \nV_3D_tot\n and \nV_3D_reg\n use equations derived in ref. [1].\n\n\nMade by Lukas Hupe.\n\n\nReferences\n\n\n[1] A. Barnett \n T. Betcke, \nChaos \n17\n, 043125 (2007)\n.\n\n\nsource\n\n\nNotice that the name \nMushroomTools\n is exported by \nDynamicalBilliards\n. The functions within it are not though, so you have to access them like e.g. \nMushroomTools.randomchaotic\n.\n\n\n#\n\n\nDynamicalBilliards.MushroomTools.V_2D_tot\n \n \nMethod\n.\n\n\nV_2D_tot(l,w,r)\n\n\n\n\n\nReturn the total boundary map volume (2D) of a \nbilliard_mushroom\n parameterized by \n(l,w,r)\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MushroomTools.V_3D_tot\n \n \nMethod\n.\n\n\nV_3D_tot(l,w,r)\n\n\n\n\n\nReturn the total phasespace volume (3D) of a \nbilliard_mushroom\n parameterized by \n(l,w,r)\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MushroomTools.g_c_2D\n \n \nMethod\n.\n\n\ng_c_2D(l, w, r)\n\n\n\n\n\nReturn the chaotic phasespace portion of the boundary map (2D) of a \nbilliard_mushroom\n with stem length \nl\n, stem width \nw\n and cap radious \nr\n. This result is known analytically, see \nMushroomTools\n for references.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MushroomTools.g_c_3D\n \n \nMethod\n.\n\n\ng_c_3D(l, w, r)\n\n\n\n\n\nReturn the chaotic phasespace portion of the full (3D) phase-space of a \nbilliard_mushroom\n with stem length \nl\n, stem width \nw\n and cap radious \nr\n. This result is known analytically, see \nMushroomTools\n for references.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MushroomTools.g_r_2D\n \n \nMethod\n.\n\n\ng_r_2D(l, w, r)\n\n\n\n\n\nReturn the regular phasespace portion of the boundary map (2D) of a \nbilliard_mushroom\n with stem length \nl\n, stem width \nw\n and cap radious \nr\n. This result is known analytically, see \nMushroomTools\n for references.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MushroomTools.g_r_3D\n \n \nMethod\n.\n\n\ng_r_3D(l, w, r)\n\n\n\n\n\nReturn the regular phasespace portion of the full (3D) phase-space of a \nbilliard_mushroom\n with stem length \nl\n, stem width \nw\n and cap radious \nr\n. This result is known analytically, see \nMushroomTools\n for references.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MushroomTools.randin_mushroom\n \n \nMethod\n.\n\n\nrandin_mushroom(l, w, r [, \u03c9])\n\n\n\n\n\nGenerate a random particle within the \nbilliard_mushroom\n parameterised by \nl\n, \nw\n and \nr\n. If \n\u03c9\n is given the particle is magnetic instead.\n\n\nThis function is much more efficient than \nrandominside\n.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MushroomTools.randomchaotic\n \n \nMethod\n.\n\n\nrandomchaotic(l, w, r)\n\n\n\n\n\nGenerate a chaotic particle, i.e. not trapped in the cap.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.MushroomTools.randomregular\n \n \nMethod\n.\n\n\nrandomregular(l, w, r)\n\n\n\n\n\nGenerate a regular particle (i.e. trapped in the cap).\n\n\nsource", 
            "title": "MushroomTools"
        }, 
        {
            "location": "/physics/", 
            "text": "This page briefly discusses physical aspects of billiard systems.\n\n\n\n\nPinned Particles\n\n\nIn the case of propagation with magnetic field, a particle may be \"pinned\" (collision-less): There are no possible collisions that take place and the particle will revolve in circles forever. This can happen for specific initial conditions depending on your billiard table and the angular velocity \u03c9. The function \nispinned\n shows you whether a particle meets the conditions.\n\n\n#\n\n\nDynamicalBilliards.ispinned\n \n \nFunction\n.\n\n\nispinned(p::MagneticParticle, bd::Billiard)\n\n\n\n\n\nReturn \ntrue\n if the particle is pinned with respect to the billiard. Pinned particles either have no valid collisions (go in circles forever) or all their valid collisions are with periodic walls, which again means that they go in cirles for ever.\n\n\nsource\n\n\n\n\nIn such event, the convention followed by \nDynamicalBilliards\n is the following: \nevolve!\n returns the expected output, however all returned vectors have only 2 entries. The collision times always have the entries \n0.0, Inf\n. All other returned vectors have the initial conditions, repeated once.\n\n\nevolve!\n can be given an additional \nwarning\n keyword argument in the case of magnetic propagation, e.g. \nwarning = true\n that throws a  message whenever a pinned particle is evolved.\n\n\n\n\n\n\nVelocity measure\n\n\nBoth \nParticle\n and \nMagneticParticle\n are assumed to \nalways\n have a velocity vector of measure 1 during evolution. This simplifies the formulas used internally to a significant amount.\n\n\nHowever, during ray-splitting, the a \nMagneticParticle\n may be in areas with different angular velocities (result of the \n\u03c9_new\n function). Physically, in such a situation, the velocity measure of the particle could also change. This change depends on the forces acting on the particle (e.g. magnetic field) as well as the relation of the momentum with the velocity (functional type of kinetic energy).\n\n\nIn any case, such a change is not accounted for internally by \nDynamicalBilliards\n. However it is very easy to implement this by \"re-normalizing\" the angular velocities you use. Since the \"code\" velocity has measure one, the rotation radius is given by\n\n\n\n\n\nr = \\frac{1}{\\omega_\\text{code}} = \\frac{v_\\text{real}}{\\omega_\\text{real}}\n\n\n\n\nr = \\frac{1}{\\omega_\\text{code}} = \\frac{v_\\text{real}}{\\omega_\\text{real}}\n\n\n\n\n\nthen one simply has to adjust the values of \n\u03c9\n given in the code with\n\n\n\n\n\n\\omega_\\text{code} = \\frac{\\omega_\\text{real}}{v_\\text{real}}\n\n\n\n\n\\omega_\\text{code} = \\frac{\\omega_\\text{real}}{v_\\text{real}}\n\n\n\n\n\nAfter getting the timeseries:\n\n\n# These are the \ncode\n-data. |v| = 1 always\n\n\nct\n,\n \nposs\n,\n \nvels\n,\n \nomegas\n \n=\n \nevolve\n(\np\n,\n \nbd\n,\n \nttotal\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \ntimeseries\n(\np\n,\n \nbd\n,\n \nttotal\n)\n\n\n\n\n\n\nyou only need to make some final adjustment on the \nvxt, vyt\n. The position and time data are completely unaffected.\n\n\nomegas_code\n \n=\n \nomegas\n\n\n# real angular velocities:\n\n\nomegas_real\n \n=\n \nsupplied_by_user\n\n\n# or with some user provided function:\n\n\nf\n \n=\n \no\n \n-\n \n(\no\n \n==\n \n0.5\n \n?\n \n2\no\n \n:\n \no\n*\u221a\n2\n)\n\n\nomegas_real\n \n=\n \nf\n.\n(\nomegas_code\n)\n\n\n# real velocity measure:\n\n\nvels_real\n \n=\n \nabs\n.\n(\nomegas_real\n \n./\n \nomegas_code\n)\n\n\n\ncontt\n \n=\n \ncumsum\n(\nct\n)\n\n\nomega_t\n \n=\n \nzeros\n(\nt\n)\n\n\nvxtreal\n \n=\n \ncopy\n(\nvxt\n)\n\n\nvytreal\n \n=\n \ncopy\n(\nvyt\n)\n\n\nj\n \n=\n \n1\n\n\nfor\n \ni\n \nin\n \neachindex\n(\nt\n)\n\n  \nvxtreal\n[\ni\n]\n \n*=\n \nvels_real\n[\nj\n]\n\n  \nvytreal\n[\ni\n]\n \n*=\n \nvels_real\n[\nj\n]\n\n  \nomega_t\n[\ni\n]\n \n=\n \nomegas_real\n[\nj\n]\n\n\n  \nif\n \nt\n[\ni\n]\n \n=\n  \ncontt\n[\nj\n]\n\n    \nj\n \n+=\n \n1\n\n  \nend\n\n\nend\n\n\n\n\n\n\nNow you can be sure that the particle at time \nt[i]\n had real velocity \n[vxtreal[i], vytreal[i]]\n and was propagating with real angular velocity \nomega_t[i]\n.", 
            "title": "Physics"
        }, 
        {
            "location": "/physics/#pinned-particles", 
            "text": "In the case of propagation with magnetic field, a particle may be \"pinned\" (collision-less): There are no possible collisions that take place and the particle will revolve in circles forever. This can happen for specific initial conditions depending on your billiard table and the angular velocity \u03c9. The function  ispinned  shows you whether a particle meets the conditions.  #  DynamicalBilliards.ispinned     Function .  ispinned(p::MagneticParticle, bd::Billiard)  Return  true  if the particle is pinned with respect to the billiard. Pinned particles either have no valid collisions (go in circles forever) or all their valid collisions are with periodic walls, which again means that they go in cirles for ever.  source   In such event, the convention followed by  DynamicalBilliards  is the following:  evolve!  returns the expected output, however all returned vectors have only 2 entries. The collision times always have the entries  0.0, Inf . All other returned vectors have the initial conditions, repeated once.  evolve!  can be given an additional  warning  keyword argument in the case of magnetic propagation, e.g.  warning = true  that throws a  message whenever a pinned particle is evolved.", 
            "title": "Pinned Particles"
        }, 
        {
            "location": "/physics/#velocity-measure", 
            "text": "Both  Particle  and  MagneticParticle  are assumed to  always  have a velocity vector of measure 1 during evolution. This simplifies the formulas used internally to a significant amount.  However, during ray-splitting, the a  MagneticParticle  may be in areas with different angular velocities (result of the  \u03c9_new  function). Physically, in such a situation, the velocity measure of the particle could also change. This change depends on the forces acting on the particle (e.g. magnetic field) as well as the relation of the momentum with the velocity (functional type of kinetic energy).  In any case, such a change is not accounted for internally by  DynamicalBilliards . However it is very easy to implement this by \"re-normalizing\" the angular velocities you use. Since the \"code\" velocity has measure one, the rotation radius is given by   \nr = \\frac{1}{\\omega_\\text{code}} = \\frac{v_\\text{real}}{\\omega_\\text{real}}  \nr = \\frac{1}{\\omega_\\text{code}} = \\frac{v_\\text{real}}{\\omega_\\text{real}}   then one simply has to adjust the values of  \u03c9  given in the code with   \n\\omega_\\text{code} = \\frac{\\omega_\\text{real}}{v_\\text{real}}  \n\\omega_\\text{code} = \\frac{\\omega_\\text{real}}{v_\\text{real}}   After getting the timeseries:  # These are the  code -data. |v| = 1 always  ct ,   poss ,   vels ,   omegas   =   evolve ( p ,   bd ,   ttotal )  xt ,   yt ,   vxt ,   vyt ,   t   =   timeseries ( p ,   bd ,   ttotal )   you only need to make some final adjustment on the  vxt, vyt . The position and time data are completely unaffected.  omegas_code   =   omegas  # real angular velocities:  omegas_real   =   supplied_by_user  # or with some user provided function:  f   =   o   -   ( o   ==   0.5   ?   2 o   :   o *\u221a 2 )  omegas_real   =   f . ( omegas_code )  # real velocity measure:  vels_real   =   abs . ( omegas_real   ./   omegas_code )  contt   =   cumsum ( ct )  omega_t   =   zeros ( t )  vxtreal   =   copy ( vxt )  vytreal   =   copy ( vyt )  j   =   1  for   i   in   eachindex ( t ) \n   vxtreal [ i ]   *=   vels_real [ j ] \n   vytreal [ i ]   *=   vels_real [ j ] \n   omega_t [ i ]   =   omegas_real [ j ] \n\n   if   t [ i ]   =    contt [ j ] \n     j   +=   1 \n   end  end   Now you can be sure that the particle at time  t[i]  had real velocity  [vxtreal[i], vytreal[i]]  and was propagating with real angular velocity  omega_t[i] .", 
            "title": "Velocity measure"
        }, 
        {
            "location": "/basic/low_level/", 
            "text": "Internals\n\n\nThis page is \nnot\n part of the public API defined by \nDynamicalBilliards\n. Consider it something like a \ndeveloper's guide\n.\n\n\n\n\nImplementation\n\n\nBefore talking about the low level methods that enable everything to work nicely together, let's talk about how this package works.\n\n\nFirstly one defines a \nBilliard\n and optionally some \nRaySplitter\n instances. Then one creates a particle inside the defined billiard. The algorithm for the propagation of a particle is the following:\n\n\n\n\nCalculate the \ncollision\n of the particle with \nall\n obstacles in the billiard.\n\n\nFind the collision that happens first (in time), and the obstacle corresponding to that.\n\n\nDynamicalBilliards.relocate!\n the particle, and ensure that it is \ninside\n the billiard. This means that \nDynamicalBilliards.distance\n between particle and obstacle is either positive or close to machine precision.\n\n\n\n\n(Optionally) check if there is transmission for ray-splitting: \nT(\u03c6) \n rand()\n\n\n\n\n\n\nIf yes, perform the ray-splitting algorithm (see the \nray-splitting\n page).\n\n\n\n\n\n\nIf not, then \nDynamicalBilliards.resolvecollision!\n of the particle with the obstacle (specular or periodic conditions).\n\n\n\n\n\n\nContinue this loop for a given amount of time.\n\n\n\n\n\n\nNotice that the \nDynamicalBilliards.relocate!\n step is \nvery\n important because it takes care that all particles remain inside the billiard.\n\n\nThe exposed \nbounce!\n function bundles steps 1-4 together.\n\n\n\n\nWhere is \"inside\"?\n\n\nIf for some reason (finite numeric precision) a particle goes outside a billiard, then it will escape to infinity. But what \nis\n inside?\n\n\n\"Inside\" is defined on obstacle level by the function \ndistance\n:\n\n\n#\n\n\nDynamicalBilliards.distance\n \n \nFunction\n.\n\n\ndistance(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nReturn the \nsigned\n distance between particle \np\n and obstacle \no\n, based on \np.pos\n. Positive distance corresponds to the particle being on the \nallowed\n region of the \nObstacle\n. E.g. for a \nDisk\n, the distance is positive when the particle is outside of the disk, negative otherwise.\n\n\ndistance(p::AbstractParticle, bd::Billiard)\n\n\n\n\n\nReturn minimum \ndistance(p, obst)\n for all \nobst\n in \nbd\n. If the \ndistance(p, bd)\n is negative this means that the particle is outside the billiard.\n\n\nAll \ndistance\n functions can also be given a position (vector) instead of a particle.\n\n\nsource\n\n\nNotice that for very small negative values of distance, \ncollision\n takes care of finite precision issues and does not return wrong collisions.\n\n\n\n\nNumerical Precision\n\n\nAll core types of \nDynamicalBilliards\n are parametrically constructed, with parameter \nT \n: AbstractFloat\n. This means that the fields of all particles and obstacles contain numbers strictly of type \nT\n. You will understand why this choice happened as you continue reading this paragraph.\n\n\nThe main concerns during evolution in a billiard table are:\n\n\n\n\nThe particle must never leak out of the billiard table. This is simply translated to the \ndistance\n function being positive after any collision \nand\n that \ncollision\n takes care of extreme cases with very small (but negative) distance.\n\n\nThe collision time is never infinite, besides the cases of \npinned particles\n in a magnetic billiard.\n\n\n\n\nThese are solved with two ways:\n\n\n\n\nAfter the next collision is computed, \nrelocate!\n brings the particle to that point and calculates the \ndistance\n with the colliding obstacle. If it is negative, it translates the particle's position by this distance, \nalong the normal vector\n.\n\n\ncollision\n takes care of cases where the distance between particle and obstacle is less than \naccuracy(::T)\n. (This is necessary only for magnetic propagation, as for straight propagation checking the velocity direction with respect to the normal is always enough).\n\n\n\n\nAdjusting the global precision of \nDynamicalBilliards\n is easy and can be done by choosing the floating precision you would like. This is done by initializing your billiard table with parametric type \nT\n, e.g. \nbd = billiard_sinai(Float16(0.3))\n. This choice will propagate to the entire \nbd\n, all particles resulting from \nrandominside\n, \nas well as the entire evolution process\n.\n\n\n\n\nBigFloats\n\n\nEvolution with \nBigFloat\n in \nDynamicalBilliards\n is on average 3 to 4 orders of magnitude slower than with \nFloat64\n.\n\n\n\n\n\n\n\n\nCollision Times\n\n\n#\n\n\nDynamicalBilliards.collision\n \n \nFunction\n.\n\n\ncollision(p::AbstractParticle, o::Obstacle) \u2192 t, cp\n\n\n\n\n\nFind the collision (if any) between given particle and obstacle. Return the time until collision and the estimated collision point \ncp\n.\n\n\nReturns \nInf, SV(0, 0)\n if the collision is not possible \nor\n if the collision happens backwards in time.\n\n\nIt is the duty of \ncollision\n to avoid incorrect collisions when the particle is on top of the obstacle (or very close).\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.next_collision\n \n \nFunction\n.\n\n\nnext_collision(p::AbstractParticle, bd::Billiard) -\n i, tmin, cp\n\n\n\n\n\nCompute the \ncollision\n across all obstacles in \nbd\n and find the minimum one. Return the index of colliding obstacle, the time and the collision point.\n\n\nsource\n\n\n\n\nNon-Exported Internals\n\n\n\n\nObstacle related\n\n\n#\n\n\nDynamicalBilliards.normalvec\n \n \nFunction\n.\n\n\nnormalvec(obst::Obstacle, position)\n\n\n\n\n\nReturn the vector normal to the obstacle's boundary at the given position (which is assumed to be very close to the obstacle's boundary).\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.cellsize\n \n \nFunction\n.\n\n\ncellsize(bd)\n\n\n\n\n\nReturn the delimiters \nxmin, ymin, xmax, ymax\n of the given obstacle/billiard.\n\n\nUsed in \nrandominside()\n, error checking and plotting.\n\n\nsource\n\n\n\n\nPropagation\n\n\n#\n\n\nDynamicalBilliards.propagate!\n \n \nFunction\n.\n\n\npropagate!(p::AbstractParticle, t)\n\n\n\n\n\nPropagate the particle \np\n for given time \nt\n, changing appropriately the the \np.pos\n and \np.vel\n fields.\n\n\npropagate!(p, position, t)\n\n\n\n\n\nDo the same, but take advantage of the already calculated \nposition\n that the particle should end up at.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.resolvecollision!\n \n \nFunction\n.\n\n\nresolvecollision!(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nResolve the collision between particle \np\n and obstacle \no\n, depending on the type of \no\n (do \nspecular!\n or \nperiodicity!\n).\n\n\nresolvecollision!(p, o, T::Function, \u03b8::Function, new_\u03c9::Function)\n\n\n\n\n\nThis is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to \nevolve!()\n. For a calculated incidence angle \u03c6, if T(\u03c6) \n rand(), ray-splitting occurs.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.relocate!\n \n \nFunction\n.\n\n\nrelocate!(p::AbstractParticle, o::Obstacle, t, cp)\n\n\n\n\n\nPropagate the particle to \ncp\n and propagate velocities for time \nt\n. Check if it is on the correct side of the obstacle. If not, change the particle position by \ndistance\n along the \nnormalvec\n of the obstacle.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.specular!\n \n \nFunction\n.\n\n\nspecular!(p::AbstractParticle, o::Obstacle)\n\n\n\n\n\nPerform specular reflection based on the normal vector of the Obstacle.\n\n\nIn the case where the given obstacle is a \nRandomObstacle\n, the specular reflection randomizes the velocity instead (within -\u03c0/2+\u03b5 to \u03c0/2-\u03b5 of the normal vector).\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.periodicity!\n \n \nFunction\n.\n\n\nperiodicity!(p::AbstractParticle, w::PeriodicWall)\n\n\n\n\n\nPerform periodicity conditions of \nw\n on \np\n.\n\n\nsource\n\n\n\n\nCyclotron center is a field of \nMagneticParticle\n\n\nFor almost all operations involving a \nMagneticParticle\n, the center of the cyclotron is required. In order to compute this center only when it physically changes, we have made it a field of the \nstruct\n.\n\n\nThis means that after changing the position or velocity of the particle, this center must be changed by doing \nmp.center = DynamicalBilliards.find_cyclotron(mp)\n. The \nbounce!\n function takes care of that in the most opportune moment, but if you want to write your own specific low level function, do not forget this point!", 
            "title": "Internals"
        }, 
        {
            "location": "/basic/low_level/#internals", 
            "text": "This page is  not  part of the public API defined by  DynamicalBilliards . Consider it something like a  developer's guide .", 
            "title": "Internals"
        }, 
        {
            "location": "/basic/low_level/#implementation", 
            "text": "Before talking about the low level methods that enable everything to work nicely together, let's talk about how this package works.  Firstly one defines a  Billiard  and optionally some  RaySplitter  instances. Then one creates a particle inside the defined billiard. The algorithm for the propagation of a particle is the following:   Calculate the  collision  of the particle with  all  obstacles in the billiard.  Find the collision that happens first (in time), and the obstacle corresponding to that.  DynamicalBilliards.relocate!  the particle, and ensure that it is  inside  the billiard. This means that  DynamicalBilliards.distance  between particle and obstacle is either positive or close to machine precision.   (Optionally) check if there is transmission for ray-splitting:  T(\u03c6)   rand()    If yes, perform the ray-splitting algorithm (see the  ray-splitting  page).    If not, then  DynamicalBilliards.resolvecollision!  of the particle with the obstacle (specular or periodic conditions).    Continue this loop for a given amount of time.    Notice that the  DynamicalBilliards.relocate!  step is  very  important because it takes care that all particles remain inside the billiard.  The exposed  bounce!  function bundles steps 1-4 together.", 
            "title": "Implementation"
        }, 
        {
            "location": "/basic/low_level/#where-is-inside", 
            "text": "If for some reason (finite numeric precision) a particle goes outside a billiard, then it will escape to infinity. But what  is  inside?  \"Inside\" is defined on obstacle level by the function  distance :  #  DynamicalBilliards.distance     Function .  distance(p::AbstractParticle, o::Obstacle)  Return the  signed  distance between particle  p  and obstacle  o , based on  p.pos . Positive distance corresponds to the particle being on the  allowed  region of the  Obstacle . E.g. for a  Disk , the distance is positive when the particle is outside of the disk, negative otherwise.  distance(p::AbstractParticle, bd::Billiard)  Return minimum  distance(p, obst)  for all  obst  in  bd . If the  distance(p, bd)  is negative this means that the particle is outside the billiard.  All  distance  functions can also be given a position (vector) instead of a particle.  source  Notice that for very small negative values of distance,  collision  takes care of finite precision issues and does not return wrong collisions.", 
            "title": "Where is \"inside\"?"
        }, 
        {
            "location": "/basic/low_level/#numerical-precision", 
            "text": "All core types of  DynamicalBilliards  are parametrically constructed, with parameter  T  : AbstractFloat . This means that the fields of all particles and obstacles contain numbers strictly of type  T . You will understand why this choice happened as you continue reading this paragraph.  The main concerns during evolution in a billiard table are:   The particle must never leak out of the billiard table. This is simply translated to the  distance  function being positive after any collision  and  that  collision  takes care of extreme cases with very small (but negative) distance.  The collision time is never infinite, besides the cases of  pinned particles  in a magnetic billiard.   These are solved with two ways:   After the next collision is computed,  relocate!  brings the particle to that point and calculates the  distance  with the colliding obstacle. If it is negative, it translates the particle's position by this distance,  along the normal vector .  collision  takes care of cases where the distance between particle and obstacle is less than  accuracy(::T) . (This is necessary only for magnetic propagation, as for straight propagation checking the velocity direction with respect to the normal is always enough).   Adjusting the global precision of  DynamicalBilliards  is easy and can be done by choosing the floating precision you would like. This is done by initializing your billiard table with parametric type  T , e.g.  bd = billiard_sinai(Float16(0.3)) . This choice will propagate to the entire  bd , all particles resulting from  randominside ,  as well as the entire evolution process .   BigFloats  Evolution with  BigFloat  in  DynamicalBilliards  is on average 3 to 4 orders of magnitude slower than with  Float64 .", 
            "title": "Numerical Precision"
        }, 
        {
            "location": "/basic/low_level/#collision-times", 
            "text": "#  DynamicalBilliards.collision     Function .  collision(p::AbstractParticle, o::Obstacle) \u2192 t, cp  Find the collision (if any) between given particle and obstacle. Return the time until collision and the estimated collision point  cp .  Returns  Inf, SV(0, 0)  if the collision is not possible  or  if the collision happens backwards in time.  It is the duty of  collision  to avoid incorrect collisions when the particle is on top of the obstacle (or very close).  source  #  DynamicalBilliards.next_collision     Function .  next_collision(p::AbstractParticle, bd::Billiard) -  i, tmin, cp  Compute the  collision  across all obstacles in  bd  and find the minimum one. Return the index of colliding obstacle, the time and the collision point.  source", 
            "title": "Collision Times"
        }, 
        {
            "location": "/basic/low_level/#non-exported-internals", 
            "text": "", 
            "title": "Non-Exported Internals"
        }, 
        {
            "location": "/basic/low_level/#obstacle-related", 
            "text": "#  DynamicalBilliards.normalvec     Function .  normalvec(obst::Obstacle, position)  Return the vector normal to the obstacle's boundary at the given position (which is assumed to be very close to the obstacle's boundary).  source  #  DynamicalBilliards.cellsize     Function .  cellsize(bd)  Return the delimiters  xmin, ymin, xmax, ymax  of the given obstacle/billiard.  Used in  randominside() , error checking and plotting.  source", 
            "title": "Obstacle related"
        }, 
        {
            "location": "/basic/low_level/#propagation", 
            "text": "#  DynamicalBilliards.propagate!     Function .  propagate!(p::AbstractParticle, t)  Propagate the particle  p  for given time  t , changing appropriately the the  p.pos  and  p.vel  fields.  propagate!(p, position, t)  Do the same, but take advantage of the already calculated  position  that the particle should end up at.  source  #  DynamicalBilliards.resolvecollision!     Function .  resolvecollision!(p::AbstractParticle, o::Obstacle)  Resolve the collision between particle  p  and obstacle  o , depending on the type of  o  (do  specular!  or  periodicity! ).  resolvecollision!(p, o, T::Function, \u03b8::Function, new_\u03c9::Function)  This is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to  evolve!() . For a calculated incidence angle \u03c6, if T(\u03c6)   rand(), ray-splitting occurs.  source  #  DynamicalBilliards.relocate!     Function .  relocate!(p::AbstractParticle, o::Obstacle, t, cp)  Propagate the particle to  cp  and propagate velocities for time  t . Check if it is on the correct side of the obstacle. If not, change the particle position by  distance  along the  normalvec  of the obstacle.  source  #  DynamicalBilliards.specular!     Function .  specular!(p::AbstractParticle, o::Obstacle)  Perform specular reflection based on the normal vector of the Obstacle.  In the case where the given obstacle is a  RandomObstacle , the specular reflection randomizes the velocity instead (within -\u03c0/2+\u03b5 to \u03c0/2-\u03b5 of the normal vector).  source  #  DynamicalBilliards.periodicity!     Function .  periodicity!(p::AbstractParticle, w::PeriodicWall)  Perform periodicity conditions of  w  on  p .  source   Cyclotron center is a field of  MagneticParticle  For almost all operations involving a  MagneticParticle , the center of the cyclotron is required. In order to compute this center only when it physically changes, we have made it a field of the  struct .  This means that after changing the position or velocity of the particle, this center must be changed by doing  mp.center = DynamicalBilliards.find_cyclotron(mp) . The  bounce!  function takes care of that in the most opportune moment, but if you want to write your own specific low level function, do not forget this point!", 
            "title": "Propagation"
        }, 
        {
            "location": "/tutorials/billiard_table/", 
            "text": "Creating your own Billiard\n\n\n\n\nThe \nBilliard\n type\n\n\n#\n\n\nDynamicalBilliards.Billiard\n \n \nType\n.\n\n\nBilliard(obstacles...)\n\n\n\n\n\nConstruct a \nBilliard\n from given \nobstacles\n (tuple, vector, varargs).\n\n\nFor functions like \nboundarymap\n, it is expected (if possible) that the obstacles of the billiard are sorted, such that the arc-coordinate \n\u03be\n around the billiard is increasing counter-clockwise.\n\n\n\u03be\n is measured as:\n\n\n\n\nthe distance from start point to end point in \nWall\ns\n\n\nthe arc length measured counterclockwise from the open face in \nSemicircle\ns\n\n\nthe arc length measured counterclockwise from the rightmost point in \nCircular\ns\n\n\n\n\nsource\n\n\n\n\nA \nBilliard\n is a wrapper of a \nTuple\n of \nObstacle\ns. The abstract Type \nObstacle{T}\n is the supertype of all objects that a particle may collide with, with global billiard precision of type \nT\n.\n\n\nThere are many premade functions that construct well-known billiards, like the periodic Sinai billiard. You can find all of them at the \nStandard Billiards Library\n.\n\n\nTo create a custom billiard from scratch, it is often convenient to start with an empty \nVector{Obstacle{T}}\n:\n\n\nusing\n \nDynamicalBilliards\n\n\nbd\n \n=\n \nObstacle\n{\nFloat64\n}[]\n  \n# T\n: AbstractFloat\n\n\n\n\n\n\n0-element Array{Obstacle{Float64},1}\n\n\n\n\n\nand then you create your obstacles one by one and add them to it. All obstacles that are already defined in the package can be found at the \nObstacles library\n below.\n\n\nFor the example of this page, we will create a hexagonal billiard with a disk in the middle step-by-step (the function \nbilliard_polygon\n creates a polygonal billiard table already).\n\n\nThe first step is to define the six walls of the billiard table. An \nInfiniteWall\n object needs to be supplemented with a start point, an end point, a normal vector and, optionally, a name.\n\n\nThe vertex points of a regular hexagon of radius \nr\nr\n are given by the formula:\n\n\n\n\n\n(x,y) = \\left( r\\cos\\left(\\frac{2\\pi i}{6}\\right), r\\cos\\left(\\frac{2\\pi i}{6}\\right) \\right)\\,, \\quad \\text{for i $\\in$ \\{1,...,6\\}}\n\n\n\n\n(x,y) = \\left( r\\cos\\left(\\frac{2\\pi i}{6}\\right), r\\cos\\left(\\frac{2\\pi i}{6}\\right) \\right)\\,, \\quad \\text{for i $\\in$ \\{1,...,6\\}}\n\n\n\n\n\nTo create each wall object, we will implement the following loop:\n\n\nhexagon_vertex\n \n=\n \n(\nr\n)\n \n-\n \n[\n \n[\nr\n*\ncos\n(\n2\n\u03c0\n*\ni\n/\n6\n),\n \nr\n*\nsin\n(\n2\n\u03c0\n*\ni\n/\n6\n)]\n \nfor\n \ni\n \nin\n \n1\n:\n6\n]\n\n\nhexver\n \n=\n \nhexagon_vertex\n(\n2.0\n)\n\n\n\nfor\n \ni\n \nin\n \neachindex\n(\nhexver\n)\n\n  \nstarting\n \n=\n \nhexver\n[\ni\n]\n\n  \nending\n \n=\n \nhexver\n[\nmod1\n(\ni\n+\n1\n,\n \nlength\n(\nhexver\n))]\n\n  \nw\n \n=\n \nending\n \n-\n \nstarting\n\n  \nnormal\n \n=\n \n[\n-\nw\n[\n2\n],\n \nw\n[\n1\n]]\n\n  \nwall\n \n=\n \nInfiniteWall\n(\nstarting\n,\n \nending\n,\n \nnormal\n,\n \nwall \n$i\n)\n\n  \npush!\n(\nbd\n,\n \nwall\n)\n\n\nend\n\n\n\nsummary\n(\nbd\n)\n\n\n\n\n\n\n6-element Array{Obstacle{Float64},1}\n\n\n\n\n\n\n\n\nKeep the size around 1.\n\n\nBecause the precision in \nDynamicalBilliards\n is measured using \neps(T)\n with \nT\n the number type, it is advised to keep the size of the billiard in the order of magnitude of 1. Having overly large billiards with sizes of 100 or more can lead to accuracy loss!\n\n\n\n\nThe \nnormal\n vector of a \nWall\n obstacle is necessary to be supplemented by the user because it must point towards where the particle is expected to come from. If \nw\n is the vector (wall) pointing from start- to end-point then the vector \n[-w[2], w[1]]\n is pointing to the left of \nw\n and the vector \n[w[2], -[w1]]\n is pointing to the right. Both are normal to \nw\n, but you have to know which one to pick. In this case this is very easy, since the normal has to simply point towards the origin.\n\n\n\n\nThere is no glue.\n\n\nIn \nDynamicalBilliards\n there is no \"glue\" that combines obstacles or \"sticks\" them together, ensuring that the billiard is closed. You only have to take care that their ends meet geometrically. Even obstacle overlapping is allowed, if you want to be on the safe side!\n\n\n\n\nWe add a disk by specifying a center and radius (and optionally a name):\n\n\nd\n \n=\n \nDisk\n([\n0\n,\n0\n],\n \n0.8\n)\n\n\npush!\n(\nbd\n,\n \nd\n)\n\n\n# Make the structure required:\n\n\nbilliard\n \n=\n \nBilliard\n(\nbd\n)\n\n\n\n\n\n\nBilliard{Float64} with 7 obstacles:\n  wall 1\n  wall 2\n  wall 3\n  wall 4\n  wall 5\n  wall 6\n  Disk\n\n\n\n\n\nTo make sure the billiard looks as you would expect, use the function \nplot(bd)\n. Create a particle inside that billiard and evolve it:\n\n\nusing\n \nPyPlot\n\n\nplot\n(\nbilliard\n)\n\n\n\u03c9\n \n=\n \n0.5\n\n\np\n \n=\n \nrandominside\n(\nbilliard\n,\n \n\u03c9\n)\n\n\nxt\n,\n \nyt\n,\n \nvxt\n,\n \nvyt\n,\n \nt\n \n=\n \ntimeseries!\n(\np\n,\n \nbilliard\n,\n \n100\n)\n\n\nplot\n(\nxt\n,\n \nyt\n)\n\n\nplot\n(\np\n)\n\n\n\n\n\n\n\n\nThe billiard table now works for straight or magnetic propagation. To expand this to ray-splitting you have to use ray-splitting \nObstacle\ns (\nsee the tutorial on Ray-Splitting\n). Additional information on how to define your own \nObstacle\n sub-type is given in the tutorial on \nDefining your own Obstacles\n.\n\n\nIf you make \nany\n billiard system that you think is cool and missing from this package, you are more than welcome to submit a PR extending the Standard Billiards Library with your contribution!\n\n\n\n\nObstacle order\n\n\n\n\nObstacle order.\n\n\nThe order that the obstacles are given to the constructor is important for the function \nboundarymap\n. For any other functionality it is irrelevant.\n\n\n\n\n\n\nConvex Billiards\n\n\nThese 2 types of walls used by \nDynamicalBilliards\n that behave differently during evolution:\n\n\n\n\nInfiniteWall\n : This wall is not actually infinite. It has a starting and ending position. However, when the collision time is calculated, this wall is assumed to be a line (i.e. \ninfinite\n). This is absolutely fine, as long as the billiards used are \nconvex\n polygons\n. \nSplitterWall\n, \nPeriodicWall\n and \nRandomWall\n behave like \nInfiniteWall\n during evolution.\n\n\nFiniteWall\n : This wall is indeed finite in every sense of the word. This means that during collision time estimation, if the collision point that was calculated lies \noutside\n of the boundaries of the \nFiniteWall\n, then the returned collision time is \nInf\n (no collision). \nFiniteWall\n is slower than \nInfiniteWall\n for that reason.\n\n\n\n\nIf you wish to create a billiard table that you know will be convex, you should then use \nInfiniteWall\ns for faster evolution. Notice that using \nescapetime\n requires at least one \nFiniteWall\n with field \nisdoor=true\n.\n\n\n\n\nObstacle Library\n\n\nThis is the list of \nObstacle\ns you can use when creating your own billiard.\n\n\n#\n\n\nDynamicalBilliards.Obstacle\n \n \nType\n.\n\n\nObstacle{\n:AbstractFloat}\n\n\n\n\n\nObstacle supertype.\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Disk\n \n \nType\n.\n\n\nDisk{T\n:AbstractFloat}  \n: Circular{T}\n\n\n\n\n\nDisk-like obstacle with propagation allowed outside of the circle (immutable type).\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\nname::String\n : Some name given for user convenience. Defaults to \"Disk\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.RandomDisk\n \n \nType\n.\n\n\nRandomDisk{T\n:AbstractFloat} \n: Circular{T}\n\n\n\n\n\nDisk-like obstacle that randomly (and uniformly) reflects colliding particles. The propagation is allowed outside of the circle.\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\nname::String\n : Some name given for user convenience. Defaults to \"Random disk\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Antidot\n \n \nType\n.\n\n\nAntidot{T\n:AbstractFloat} \n: Circular{T}\n\n\n\n\n\nDisk-like obstacle that allows propagation both inside and outside of the disk (mutable type). Used in ray-splitting billiards.\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\npflag::Bool\n : Flag that keeps track of where the particle is currently propagating (\npflag\n = propagation-flag). \ntrue\n stands for \noutside\n the disk, \nfalse\n for \ninside\n the disk. Defaults to \ntrue\n.\n\n\nname::String\n : Name of the obstacle given for user convenience. Defaults to \"Antidot\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Semicircle\n \n \nType\n.\n\n\nSemicircle{T\n:AbstractFloat} \n: Circular{T}\n\n\n\n\n\nObstacle that represents half a circle. Propagation is allowed only inside the semicircle.\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\nr::T\n : Radius.\n\n\nfacedir::SVector{2,T}\n : Direction where the open face of the Semicircle is facing.\n\n\nname::String\n : Name of the obstacle given for user convenience. Defaults to \"Semicircle\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.InfiniteWall\n \n \nType\n.\n\n\nInfiniteWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing specular reflection during collision (immutable type). Faster than \nFiniteWall\n, meant to be used for convex billiards.\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from before a collision\n (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.RandomWall\n \n \nType\n.\n\n\nRandomWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing (uniformly) random reflection during collision (immutable type).\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nis expected to come from\n (pointing towards the inside of the billiard).\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Random wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.PeriodicWall\n \n \nType\n.\n\n\nPeriodicWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle that imposes periodic boundary conditions upon collision (immutable type).\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from\n (to the inside the billiard). The size of the vector is \nimportant\n! This vector is added to a particle's \npos\n during collision. Therefore the size of the normal vector must be correctly associated with the size of the periodic cell.\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Periodic wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.SplitterWall\n \n \nType\n.\n\n\nSplitterWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing allowing for ray-splitting (mutable type).\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from before a collision\n. The size of the vector is irrelevant.\n\n\npflag::Bool\n : Flag that keeps track of where the particle is currently propagating (\npflag\n = propagation flag). \ntrue\n is associated with the \nnormal\n vector the wall is instantiated with. Defaults to \ntrue\n.\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Splitter wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.FiniteWall\n \n \nType\n.\n\n\nFiniteWall{T\n:AbstractFloat} \n: Wall{T}\n\n\n\n\n\nWall obstacle imposing specular reflection during collision (immutable type). Slower than \nInfiniteWall\n, meant to be used for non-convex billiards.\n\n\nGiving a \ntrue\n value to the field \nisdoor\n designates this obstacle to be a \nDoor\n. This is used in \nescapetime\n function. A \nDoor\n is a obstacle of the billiard that the particle can escape from, thus enabling calculations of escape times.\n\n\nFields:\n\n\n\n\nsp::SVector{2,T}\n : Starting point of the Wall.\n\n\nep::SVector{2,T}\n : Ending point of the Wall.\n\n\nnormal::SVector{2,T}\n : Normal vector to the wall, pointing to where the particle \nwill come from before a collision\n (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.\n\n\nisdoor::Bool\n : Flag of whether this \nFiniteWall\n instance is a \"Door\".\n\n\nname::String\n : Name of the obstacle, given for user convenience. Defaults to \"Finite Wall\".\n\n\n\n\nsource\n\n\n#\n\n\nDynamicalBilliards.Ellipse\n \n \nType\n.\n\n\nEllipse{T\n:AbstractFloat}  \n: Obstacle{T}\n\n\n\n\n\nEllipse obstacle that also allows ray-splitting. The ellipse is always oriented on the x and y axis (although you can make whichever you want the major one).\n\n\nFields:\n\n\n\n\nc::SVector{2,T}\n : Center.\n\n\na::T\n : x semi-axis.\n\n\nb::T\n : y semi-axis.\n\n\npflag::Bool\n : Flag that keeps track of where the particle is currently propagating. \ntrue\n (default) is associated with being outside the ellipse.\n\n\nname::String\n : Some name given for user convenience. Defaults to \n\"Ellipse\"\n.\n\n\n\n\nThe ellipse equation is given by\n\n\n\n\n\n\\left(\\frac{x - c[1]}{a} \\right)^2+ \\left(\\frac{y - c[2]}{b}\\right)^2 = 1\n\n\n\n\n\\left(\\frac{x - c[1]}{a} \\right)^2+ \\left(\\frac{y - c[2]}{b}\\right)^2 = 1\n\n\n\n\n\nsource\n\n\n\n\nIn addition, \ntranslate\n is a helpful function:\n\n\n#\n\n\nDynamicalBilliards.translate\n \n \nFunction\n.\n\n\ntranslate(obst::Obstacle, vector)\n\n\n\n\n\nCreate a copy of the given obstacle with its position translated by \nvector\n.\n\n\nsource", 
            "title": "Defining a Billiard"
        }, 
        {
            "location": "/tutorials/billiard_table/#creating-your-own-billiard", 
            "text": "", 
            "title": "Creating your own Billiard"
        }, 
        {
            "location": "/tutorials/billiard_table/#the-billiard-type", 
            "text": "#  DynamicalBilliards.Billiard     Type .  Billiard(obstacles...)  Construct a  Billiard  from given  obstacles  (tuple, vector, varargs).  For functions like  boundarymap , it is expected (if possible) that the obstacles of the billiard are sorted, such that the arc-coordinate  \u03be  around the billiard is increasing counter-clockwise.  \u03be  is measured as:   the distance from start point to end point in  Wall s  the arc length measured counterclockwise from the open face in  Semicircle s  the arc length measured counterclockwise from the rightmost point in  Circular s   source   A  Billiard  is a wrapper of a  Tuple  of  Obstacle s. The abstract Type  Obstacle{T}  is the supertype of all objects that a particle may collide with, with global billiard precision of type  T .  There are many premade functions that construct well-known billiards, like the periodic Sinai billiard. You can find all of them at the  Standard Billiards Library .  To create a custom billiard from scratch, it is often convenient to start with an empty  Vector{Obstacle{T}} :  using   DynamicalBilliards  bd   =   Obstacle { Float64 }[]    # T : AbstractFloat   0-element Array{Obstacle{Float64},1}  and then you create your obstacles one by one and add them to it. All obstacles that are already defined in the package can be found at the  Obstacles library  below.  For the example of this page, we will create a hexagonal billiard with a disk in the middle step-by-step (the function  billiard_polygon  creates a polygonal billiard table already).  The first step is to define the six walls of the billiard table. An  InfiniteWall  object needs to be supplemented with a start point, an end point, a normal vector and, optionally, a name.  The vertex points of a regular hexagon of radius  r r  are given by the formula:   \n(x,y) = \\left( r\\cos\\left(\\frac{2\\pi i}{6}\\right), r\\cos\\left(\\frac{2\\pi i}{6}\\right) \\right)\\,, \\quad \\text{for i $\\in$ \\{1,...,6\\}}  \n(x,y) = \\left( r\\cos\\left(\\frac{2\\pi i}{6}\\right), r\\cos\\left(\\frac{2\\pi i}{6}\\right) \\right)\\,, \\quad \\text{for i $\\in$ \\{1,...,6\\}}   To create each wall object, we will implement the following loop:  hexagon_vertex   =   ( r )   -   [   [ r * cos ( 2 \u03c0 * i / 6 ),   r * sin ( 2 \u03c0 * i / 6 )]   for   i   in   1 : 6 ]  hexver   =   hexagon_vertex ( 2.0 )  for   i   in   eachindex ( hexver ) \n   starting   =   hexver [ i ] \n   ending   =   hexver [ mod1 ( i + 1 ,   length ( hexver ))] \n   w   =   ending   -   starting \n   normal   =   [ - w [ 2 ],   w [ 1 ]] \n   wall   =   InfiniteWall ( starting ,   ending ,   normal ,   wall  $i ) \n   push! ( bd ,   wall )  end  summary ( bd )   6-element Array{Obstacle{Float64},1}    Keep the size around 1.  Because the precision in  DynamicalBilliards  is measured using  eps(T)  with  T  the number type, it is advised to keep the size of the billiard in the order of magnitude of 1. Having overly large billiards with sizes of 100 or more can lead to accuracy loss!   The  normal  vector of a  Wall  obstacle is necessary to be supplemented by the user because it must point towards where the particle is expected to come from. If  w  is the vector (wall) pointing from start- to end-point then the vector  [-w[2], w[1]]  is pointing to the left of  w  and the vector  [w[2], -[w1]]  is pointing to the right. Both are normal to  w , but you have to know which one to pick. In this case this is very easy, since the normal has to simply point towards the origin.   There is no glue.  In  DynamicalBilliards  there is no \"glue\" that combines obstacles or \"sticks\" them together, ensuring that the billiard is closed. You only have to take care that their ends meet geometrically. Even obstacle overlapping is allowed, if you want to be on the safe side!   We add a disk by specifying a center and radius (and optionally a name):  d   =   Disk ([ 0 , 0 ],   0.8 )  push! ( bd ,   d )  # Make the structure required:  billiard   =   Billiard ( bd )   Billiard{Float64} with 7 obstacles:\n  wall 1\n  wall 2\n  wall 3\n  wall 4\n  wall 5\n  wall 6\n  Disk  To make sure the billiard looks as you would expect, use the function  plot(bd) . Create a particle inside that billiard and evolve it:  using   PyPlot  plot ( billiard )  \u03c9   =   0.5  p   =   randominside ( billiard ,   \u03c9 )  xt ,   yt ,   vxt ,   vyt ,   t   =   timeseries! ( p ,   billiard ,   100 )  plot ( xt ,   yt )  plot ( p )    The billiard table now works for straight or magnetic propagation. To expand this to ray-splitting you have to use ray-splitting  Obstacle s ( see the tutorial on Ray-Splitting ). Additional information on how to define your own  Obstacle  sub-type is given in the tutorial on  Defining your own Obstacles .  If you make  any  billiard system that you think is cool and missing from this package, you are more than welcome to submit a PR extending the Standard Billiards Library with your contribution!", 
            "title": "The Billiard type"
        }, 
        {
            "location": "/tutorials/billiard_table/#obstacle-order", 
            "text": "Obstacle order.  The order that the obstacles are given to the constructor is important for the function  boundarymap . For any other functionality it is irrelevant.", 
            "title": "Obstacle order"
        }, 
        {
            "location": "/tutorials/billiard_table/#convex-billiards", 
            "text": "These 2 types of walls used by  DynamicalBilliards  that behave differently during evolution:   InfiniteWall  : This wall is not actually infinite. It has a starting and ending position. However, when the collision time is calculated, this wall is assumed to be a line (i.e.  infinite ). This is absolutely fine, as long as the billiards used are  convex  polygons .  SplitterWall ,  PeriodicWall  and  RandomWall  behave like  InfiniteWall  during evolution.  FiniteWall  : This wall is indeed finite in every sense of the word. This means that during collision time estimation, if the collision point that was calculated lies  outside  of the boundaries of the  FiniteWall , then the returned collision time is  Inf  (no collision).  FiniteWall  is slower than  InfiniteWall  for that reason.   If you wish to create a billiard table that you know will be convex, you should then use  InfiniteWall s for faster evolution. Notice that using  escapetime  requires at least one  FiniteWall  with field  isdoor=true .", 
            "title": "Convex Billiards"
        }, 
        {
            "location": "/tutorials/billiard_table/#obstacle-library", 
            "text": "This is the list of  Obstacle s you can use when creating your own billiard.  #  DynamicalBilliards.Obstacle     Type .  Obstacle{ :AbstractFloat}  Obstacle supertype.  source  #  DynamicalBilliards.Disk     Type .  Disk{T :AbstractFloat}   : Circular{T}  Disk-like obstacle with propagation allowed outside of the circle (immutable type).  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  name::String  : Some name given for user convenience. Defaults to \"Disk\".   source  #  DynamicalBilliards.RandomDisk     Type .  RandomDisk{T :AbstractFloat}  : Circular{T}  Disk-like obstacle that randomly (and uniformly) reflects colliding particles. The propagation is allowed outside of the circle.  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  name::String  : Some name given for user convenience. Defaults to \"Random disk\".   source  #  DynamicalBilliards.Antidot     Type .  Antidot{T :AbstractFloat}  : Circular{T}  Disk-like obstacle that allows propagation both inside and outside of the disk (mutable type). Used in ray-splitting billiards.  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  pflag::Bool  : Flag that keeps track of where the particle is currently propagating ( pflag  = propagation-flag).  true  stands for  outside  the disk,  false  for  inside  the disk. Defaults to  true .  name::String  : Name of the obstacle given for user convenience. Defaults to \"Antidot\".   source  #  DynamicalBilliards.Semicircle     Type .  Semicircle{T :AbstractFloat}  : Circular{T}  Obstacle that represents half a circle. Propagation is allowed only inside the semicircle.  Fields:   c::SVector{2,T}  : Center.  r::T  : Radius.  facedir::SVector{2,T}  : Direction where the open face of the Semicircle is facing.  name::String  : Name of the obstacle given for user convenience. Defaults to \"Semicircle\".   source  #  DynamicalBilliards.InfiniteWall     Type .  InfiniteWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing specular reflection during collision (immutable type). Faster than  FiniteWall , meant to be used for convex billiards.  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from before a collision  (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Wall\".   source  #  DynamicalBilliards.RandomWall     Type .  RandomWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing (uniformly) random reflection during collision (immutable type).  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  is expected to come from  (pointing towards the inside of the billiard).  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Random wall\".   source  #  DynamicalBilliards.PeriodicWall     Type .  PeriodicWall{T :AbstractFloat}  : Wall{T}  Wall obstacle that imposes periodic boundary conditions upon collision (immutable type).  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from  (to the inside the billiard). The size of the vector is  important ! This vector is added to a particle's  pos  during collision. Therefore the size of the normal vector must be correctly associated with the size of the periodic cell.  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Periodic wall\".   source  #  DynamicalBilliards.SplitterWall     Type .  SplitterWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing allowing for ray-splitting (mutable type).  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from before a collision . The size of the vector is irrelevant.  pflag::Bool  : Flag that keeps track of where the particle is currently propagating ( pflag  = propagation flag).  true  is associated with the  normal  vector the wall is instantiated with. Defaults to  true .  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Splitter wall\".   source  #  DynamicalBilliards.FiniteWall     Type .  FiniteWall{T :AbstractFloat}  : Wall{T}  Wall obstacle imposing specular reflection during collision (immutable type). Slower than  InfiniteWall , meant to be used for non-convex billiards.  Giving a  true  value to the field  isdoor  designates this obstacle to be a  Door . This is used in  escapetime  function. A  Door  is a obstacle of the billiard that the particle can escape from, thus enabling calculations of escape times.  Fields:   sp::SVector{2,T}  : Starting point of the Wall.  ep::SVector{2,T}  : Ending point of the Wall.  normal::SVector{2,T}  : Normal vector to the wall, pointing to where the particle  will come from before a collision  (pointing towards the inside of the billiard). The size of the vector is irrelevant since it is internally normalized.  isdoor::Bool  : Flag of whether this  FiniteWall  instance is a \"Door\".  name::String  : Name of the obstacle, given for user convenience. Defaults to \"Finite Wall\".   source  #  DynamicalBilliards.Ellipse     Type .  Ellipse{T :AbstractFloat}   : Obstacle{T}  Ellipse obstacle that also allows ray-splitting. The ellipse is always oriented on the x and y axis (although you can make whichever you want the major one).  Fields:   c::SVector{2,T}  : Center.  a::T  : x semi-axis.  b::T  : y semi-axis.  pflag::Bool  : Flag that keeps track of where the particle is currently propagating.  true  (default) is associated with being outside the ellipse.  name::String  : Some name given for user convenience. Defaults to  \"Ellipse\" .   The ellipse equation is given by   \n\\left(\\frac{x - c[1]}{a} \\right)^2+ \\left(\\frac{y - c[2]}{b}\\right)^2 = 1  \n\\left(\\frac{x - c[1]}{a} \\right)^2+ \\left(\\frac{y - c[2]}{b}\\right)^2 = 1   source   In addition,  translate  is a helpful function:  #  DynamicalBilliards.translate     Function .  translate(obst::Obstacle, vector)  Create a copy of the given obstacle with its position translated by  vector .  source", 
            "title": "Obstacle Library"
        }, 
        {
            "location": "/tutorials/own_obstacle/", 
            "text": "Creating your own \nObstacle\n Type\n\n\nIn this tutorial we will go through the processes of creating a new obstacle type, a \nSemicircle\n. This type is already used in the \nbilliard_bunimovich\n and \nbilliard_mushroom\n functions.\n\n\n\n\nEverything uses \nSVector{2}\n\n\nFields of \nParticle\ns and \nObstacle\ns contain all their information in 2-dimensional static vectors from module \nStaticArrays\n. This is important to keep in mind when extending new methods.\n\n\n\n\n\n\nExtends internal APIs\n\n\nNotice that implementing your own obstacle requires you to extend methods that \ndo not\n belong to the public API.\n\n\n\n\n\n\nSee also the \nEllipse\n PR\n\n\nPull Request \n#159\n implements the \nEllipse\n obstacle, step by step, by following the tutorial of this page. All commits are commented and it can be a second helpful guide on how to implement an obstacle.\n\n\n\n\n\n\nType Definition\n\n\nThe first thing you have to do is make your new type a sub-type of \nObstacle{T}\n (or any other abstract sub-type of it). We will do:\n\n\nstruct\n \nSemicircle\n{\nT\n:\nAbstractFloat\n}\n \n:\n \nCircular\n{\nT\n}\n \n# \n: Obstacle{T}\n\n    \nc\n::\nSVector\n{\n2\n,\nT\n}\n \n# this MUST be a static vector\n\n    \nr\n::\nT\n\n    \nfacedir\n::\nSVector\n{\n2\n,\nT\n}\n \n# this MUST be a static vector\n\n    \nname\n::\nString\n \n# this is an OPTIONAL field\n\n\nend\n\n\n\n\n\n\nc\n is the center and \nr\n is the radius of the full circle. \nfacedir\n is the direction which the semicircle is facing, which is also the direction of its \"open\" face.\n\n\nname\n is an optional field, that allows one to easily identify which obstacle is which. It is also used when printing a \nBilliard\n. If not used, then \nstring(typeof(obstacle))\n is used instead.\n\n\nNotice that the \nstruct\n \nmust be\n parameterized by \nT\n:AbstractFloat\n (see the \nnumerical precision\n page for more).\n\n\nFor convenience, we will also define:\n\n\nfunction\n \nSemicircle\n(\n\n    \nc\n::\nAbstractVector\n{\nT\n},\n \nr\n::\nReal\n,\n \nfacedir\n,\n \nname\n \n=\n \nSemicircle\n)\n \nwhere\n \n{\nT\n:\nReal\n}\n\n    \nS\n \n=\n \nT\n \n:\n \nInteger\n \n?\n \nFloat64\n \n:\n \nT\n\n    \nreturn\n \nSemicircle\n{\nS\n}(\nSVector\n{\n2\n,\nS\n}(\nc\n),\n \nconvert\n(\nS\n,\n \nabs\n(\nr\n)),\n \nname\n)\n\n\nend\n\n\n\n\n\n\nso that constructing a \nSemicircle\n is possible from arbitrary vectors.\n\n\n\n\nNecessary Methods\n\n\nThe following functions must obtain methods for \nSemicircle\n (or any other custom \nObstacle\n) in order for it to work with \nDynamicalBilliards\n:\n\n\n\n\nDynamicalBilliards.normalvec\n\n\nDynamicalBilliards.distance\n (with arguments \n(position, obstacle)\n)\n\n\nDynamicalBilliards.collision\n with \nParticle\n\n\n\n\nAssuming that upon collision a specular reflection happens, then you don't need to define a method for \nDynamicalBilliards.specular!\n. You can however define custom methods for \nDynamicalBilliards.specular!\n, which is what we have done e.g. for \nRandomDisk\n.\n\n\n\n\nUse \nimport\n!\n\n\nNotice that you have to properly \nimport\n the methods to extend them. For example, do \nimport DynamicalBilliards: normalvec, distance, collision\n time.\n\n\n\n\nThe first method is very simple, just do:\n\n\nimport\n \nDynamicalBilliards\n:\n \nnormalvec\n,\n \ndistance\n,\n \ncollision\n\n\nnormalvec\n(\nd\n::\nSemicircle\n,\n \npos\n)\n \n=\n \nnormalize\n(\nd\n.\nc\n \n-\n \npos\n)\n\n\n\n\n\n\nSince the function is only used during \ndistance\n and \nDynamicalBilliards.resolvecollision!\n and since we will be writing explicit methods for the first, we don't have to care about what happens when the particle is far away from the boundary.\n\n\nThe \ndistance\n method is a bit tricky. Since the type already subtypes \nCircular\n, the following definition from \nDynamicalBilliards\n applies:\n\n\ndistance\n(\npos\n::\nAbstractVector\n,\n \nd\n::\nCircular\n)\n \n=\n \nnorm\n(\npos\n \n-\n \nd\n.\nc\n)\n \n-\n \nd\n.\nr\n\n\n\n\n\n\nHowever, the method must be expanded. That is because when the particle is on the \"open\" half of the disk, the distance is not correct. We write:\n\n\nSV\n \n=\n \nSVector\n{\n2\n}\n \n#convenience\n\n\nfunction\n \ndistance\n(\npos\n::\nAbstractVector\n{\nT\n},\n \ns\n::\nSemicircle\n{\nT\n})\n \nwhere\n \n{\nT\n}\n\n    \n# Check on which half of circle is the particle\n\n    \nv1\n \n=\n \npos\n \n.-\n \ns\n.\nc\n\n    \nnn\n \n=\n \ndot\n(\nv1\n,\n \ns\n.\nfacedir\n)\n\n    \nif\n \nnn\n \n\u2264\n \n0\n \n# I am \ninside semicircle\n\n        \nreturn\n \ns\n.\nr\n \n-\n \nnorm\n(\npos\n \n-\n \ns\n.\nc\n)\n\n    \nelse\n \n# I am on the \nother side\n\n        \nend1\n \n=\n \nSV\n(\ns\n.\nc\n[\n1\n]\n \n+\n \ns\n.\nr\n*\ns\n.\nfacedir\n[\n2\n],\n \ns\n.\nc\n[\n2\n]\n \n-\n \ns\n.\nr\n*\ns\n.\nfacedir\n[\n1\n])\n\n        \nend2\n \n=\n \nSV\n(\ns\n.\nc\n[\n1\n]\n \n-\n \ns\n.\nr\n*\ns\n.\nfacedir\n[\n2\n],\n \ns\n.\nc\n[\n2\n]\n \n+\n \ns\n.\nr\n*\ns\n.\nfacedir\n[\n1\n])\n\n        \nreturn\n \nmin\n(\nnorm\n(\npos\n \n-\n \nend1\n),\n \nnorm\n(\npos\n \n-\n \nend2\n))\n\n    \nend\n\n\nend\n\n\n\n\n\n\nNotice that this definition always returns positive distance when the particle is on the \"other side\".\n\n\nFinally, the method for \ncollision\n is by far the most \ntrickiest\n. But, with pen, paper and a significant amount of patience, one can find a way:\n\n\nfunction\n \ncollision\n(\np\n::\nParticle\n{\nT\n},\n \nd\n::\nSemicircle\n{\nT\n})\n::\nT\n \nwhere\n \n{\nT\n}\n\n\n    \ndc\n \n=\n \np\n.\npos\n \n-\n \nd\n.\nc\n\n    \nB\n \n=\n \ndot\n(\np\n.\nvel\n,\n \ndc\n)\n         \n#velocity towards circle center: B \n 0\n\n    \nC\n \n=\n \ndot\n(\ndc\n,\n \ndc\n)\n \n-\n \nd\n.\nr\n*\nd\n.\nr\n    \n#being outside of circle: C \n 0\n\n    \n\u0394\n \n=\n \nB\n^\n2\n \n-\n \nC\n\n\n    \n\u0394\n \n\u2264\n \n0\n \n \nreturn\n \nnocollision\n(\nT\n)\n\n    \nsqrtD\n \n=\n \nsqrt\n(\n\u0394\n)\n\n\n    \nnn\n \n=\n \ndot\n(\ndc\n,\n \nd\n.\nfacedir\n)\n\n    \nif\n \nnn\n \n\u2265\n \n0\n \n# I am NOT inside semicircle\n\n        \n# Return most positive time\n\n        \nt\n \n=\n \n-\nB\n \n+\n \nsqrtD\n\n    \nelse\n \n# I am inside semicircle:\n\n        \nt\n \n=\n \n-\nB\n \n-\n \nsqrtD\n\n        \n# these lines make sure that the code works for ANY starting position:\n\n        \nif\n \nt\n \n\u2264\n \n0\n \n||\n \ndistance\n(\np\n,\n \nd\n)\n \n\u2264\n \naccuracy\n(\nT\n)\n\n            \nt\n \n=\n \n-\nB\n \n+\n \nsqrtD\n\n        \nend\n\n    \nend\n\n    \n# This check is necessary to not collide with the non-existing side\n\n    \nnewpos\n \n=\n \np\n.\npos\n \n+\n \np\n.\nvel\n \n*\n \nt\n\n    \nif\n \ndot\n(\nnewpos\n \n-\n \nd\n.\nc\n,\n \nd\n.\nfacedir\n)\n \n\u2265\n \n0\n \n# collision point on BAD HALF;\n\n        \nreturn\n \nnocollision\n(\nT\n)\n\n    \nend\n\n    \n# If collision time is negative, return Inf:\n\n    \nt\n \n\u2264\n \n0.0\n \n?\n \nnocollision\n(\nT\n)\n \n:\n \n(\nt\n,\n \np\n.\npos\n \n+\n \nt\n*\np\n.\nvel\n)\n\n\nend\n\n\n\n\n\n\nAnd that is all. The obstacle now works perfectly fine for straight propagation.\n\n\n\n\nRay-Splitting support\n\n\nSupporting ray-splitting for your custom obstacle is very easy. The first step is to give it a field called \npflag\n, which is a \nBool\n. The second step is to ensure that \ncollisiontime\n works properly for particles coming from both directions of the obstacle! Both inside or outside! This is implemented for \nEllipse\n in Pull Request \n#159\n.\n\n\n\n\n\n\nOptional Methods\n\n\n\n\nDynamicalBilliards.cellsize\n : Enables \nrandominside\n with this obstacle.\n\n\ncollision\n with \nMagneticParticle\n : enables magnetic propagation\n\n\nplot\n with \nobstacle\n : enables plotting\n\n\nDynamicalBilliards.specular!\n with \noffset\n : Allows \nlyapunovspectrum\n to be computed.\n\n\nto_bcoords\n : Allows the \nboundarymap\n and \nboundarymap_portion\n to be computed.\n\n\nfrom_bcoords\n : Allows \nphasespace_portion\n to be computed.\n\n\n\n\nThe \nDynamicalBilliards.cellsize\n method is kinda trivial:\n\n\nimport\n \nDynamicalBilliards\n:\n \ncellsize\n,\n \nplot\n,\n \nto_bcoords\n,\n \nfrom_bcoords\n\n\n\nfunction\n \ncellsize\n(\na\n::\nSemicircle\n{\nT\n})\n \nwhere\n \n{\nT\n}\n\n    \nxmin\n,\n \nymin\n \n=\n \na\n.\nc\n \n-\n \na\n.\nr\n\n    \nxmax\n,\n \nymax\n \n=\n \na\n.\nc\n \n+\n \na\n.\nr\n\n    \nreturn\n \nxmin\n,\n \nymin\n,\n \nxmax\n,\n \nymax\n\n\nend\n\n\n\n\n\n\nThe \ncollision\n method for \nMagneticParticle\n is also tricky, however it is almost identical with the method for the general \nCircular\n obstacle:\n\n\nfunction\n \ncollision\n(\np\n::\nMagneticParticle\n{\nT\n},\n \no\n::\nSemicircle\n{\nT\n})\n::\nT\n \nwhere\n \n{\nT\n}\n\n    \n\u03c9\n \n=\n \np\n.\nomega\n\n    \npc\n,\n \nrc\n \n=\n \ncyclotron\n(\np\n)\n\n    \np1\n \n=\n \no\n.\nc\n\n    \nr1\n \n=\n \no\n.\nr\n\n    \nd\n \n=\n \nnorm\n(\np1\n-\npc\n)\n\n    \nif\n \n(\nd\n \n=\n \nrc\n \n+\n \nr1\n)\n \n||\n \n(\nd\n \n=\n \nabs\n(\nrc\n-\nr1\n))\n\n        \nreturn\n \nnocollision\n(\nT\n)\n\n    \nend\n\n    \n# Solve quadratic:\n\n    \na\n \n=\n \n(\nrc\n^\n2\n \n-\n \nr1\n^\n2\n \n+\n \nd\n^\n2\n)\n/\n2\nd\n\n    \nh\n \n=\n \nsqrt\n(\nrc\n^\n2\n \n-\n \na\n^\n2\n)\n\n    \n# Collision points (always 2):\n\n    \nI1\n \n=\n \nSVector\n{\n2\n,\n \nT\n}(\n\n        \npc\n[\n1\n]\n \n+\n \na\n*\n(\np1\n[\n1\n]\n \n-\n \npc\n[\n1\n])\n/\nd\n \n+\n \nh\n*\n(\np1\n[\n2\n]\n \n-\n \npc\n[\n2\n])\n/\nd\n,\n\n        \npc\n[\n2\n]\n \n+\n \na\n*\n(\np1\n[\n2\n]\n \n-\n \npc\n[\n2\n])\n/\nd\n \n-\n \nh\n*\n(\np1\n[\n1\n]\n \n-\n \npc\n[\n1\n])\n/\nd\n\n    \n)\n\n    \nI2\n \n=\n \nSVector\n{\n2\n,\n \nT\n}(\n\n        \npc\n[\n1\n]\n \n+\n \na\n*\n(\np1\n[\n1\n]\n \n-\n \npc\n[\n1\n])\n/\nd\n \n-\n \nh\n*\n(\np1\n[\n2\n]\n \n-\n \npc\n[\n2\n])\n/\nd\n,\n\n        \npc\n[\n2\n]\n \n+\n \na\n*\n(\np1\n[\n2\n]\n \n-\n \npc\n[\n2\n])\n/\nd\n \n+\n \nh\n*\n(\np1\n[\n1\n]\n \n-\n \npc\n[\n1\n])\n/\nd\n\n    \n)\n\n    \n# Only consider intersections on the \ncorrect\n side of Semicircle:\n\n    \ncond1\n \n=\n \ndot\n(\nI1\n-\no\n.\nc\n,\n \no\n.\nfacedir\n)\n \n \n0\n\n    \ncond2\n \n=\n \ndot\n(\nI2\n-\no\n.\nc\n,\n \no\n.\nfacedir\n)\n \n \n0\n\n    \n# Collision time, equiv. to arc-length until collision point:\n\n    \n\u03b8\n,\n \nI\n \n=\n \nnocollision\n(\nT\n)\n\n    \nif\n \ncond1\n \n||\n \ncond2\n\n        \nfor\n \n(\nY\n,\n \ncond\n)\n \nin\n \n((\nI1\n,\n \ncond1\n),\n \n(\nI2\n,\n \ncond2\n))\n\n            \nif\n \ncond\n\n                \n\u03c6\n \n=\n \nrealangle\n(\np\n,\n \no\n,\n \nY\n)\n\n                \n\u03c6\n \n \n\u03b8\n \n \n(\n\u03b8\n \n=\n \n\u03c6\n;\n \nI\n \n=\n \nY\n)\n\n            \nend\n\n        \nend\n\n    \nend\n\n    \n# Collision time = arc-length until collision point\n\n    \nreturn\n \n\u03b8\n*\nrc\n,\n \nI\n\n\nend\n\n\n\n\n\n\nThen, we add swag by writing a method for \nplot\n:\n\n\nusing\n \nPyPlot\n\n\n\nfunction\n \nplot\n(\nd\n::\nSemicircle\n;\n \nkwargs\n...\n)\n\n    \ntheta1\n \n=\n \natan\n(\nd\n.\nfacedir\n[\n2\n],\n \nd\n.\nfacedir\n[\n1\n])\n*\n180\n/\n\u03c0\n \n+\n \n90\n\n    \ntheta2\n \n=\n \ntheta1\n \n+\n \n180\n\n    \nedgecolor\n \n=\n \nDynamicalBilliards\n.\nobcolor\n(\nd\n)\n\n    \ns1\n \n=\n \nPyPlot\n.\nmatplotlib\n[\n:\npatches\n][\n:\nArc\n](\n\n        \nd\n.\nc\n,\n \n2\nd\n.\nr\n,\n \n2\nd\n.\nr\n,\n \ntheta1\n \n=\n \ntheta1\n,\n \ntheta2\n \n=\n \ntheta2\n,\n \nedgecolor\n \n=\n \nedgecolor\n,\n\n        \nlw\n \n=\n \n2.0\n,\n \nkwargs\n...\n)\n\n    \nPyPlot\n.\ngca\n()[\n:\nadd_artist\n](\ns1\n)\n\n    \nPyPlot\n.\nshow\n()\n\n\nend\n\n\n\n\n\n\nTo enable computation of Lyapunov exponents in billiards with your obstacle, you have to write another method for \nspecular!\n that also handles the evolution of perturbation vectors in tangent space. For this, the method has to accept an argument of type \nVector{SVector{4, T}}\n, which contains the four perturbation vectors corresponding to the four Lyapunov exponents.\n\n\nFinding a formula for the evolution of the perturbations requires some tricky calculations. Fortunately for us, the results for general circular obstacles were already determined by Dellago, Posch and Hoover [1] \u2013 we just have to implement them.\n\n\nfunction\n \nspecular!\n(\np\n::\nParticle\n{\nT\n},\n \no\n::\nCircular\n{\nT\n},\n\n    \noffset\n::\nVector\n{\nSVector\n{\n4\n,\n \nT\n}})\n \nwhere\n \n{\nT\n:\nAbstractFloat\n}\n\n\n    \nn\n \n=\n \nnormalvec\n(\no\n,\n \np\n.\npos\n)\n\n    \nti\n \n=\n \nSV\n{\nT\n}(\n-\np\n.\nvel\n[\n2\n],\np\n.\nvel\n[\n1\n])\n\n\n    \ncosa\n \n=\n \n-\ndot\n(\nn\n,\n \np\n.\nvel\n)\n\n    \np\n.\nvel\n \n=\n \np\n.\nvel\n \n+\n \n2\n*\ncosa\n*\nn\n\n\n    \ntf\n \n=\n \nSV\n{\nT\n}(\n-\np\n.\nvel\n[\n2\n],\n \np\n.\nvel\n[\n1\n])\n\n\n    \nfor\n \nk\n \nin\n \n1\n:\n4\n\n        \n\u03b4qprev\n \n=\n \noffset\n[\nk\n][\n\u03b4qind\n]\n\n        \n\u03b4pprev\n \n=\n \noffset\n[\nk\n][\n\u03b4pind\n]\n\n        \n# Formulas from Dellago, Posch and Hoover, PRE 53, 2, 1996: 1485-1501 (eq. 27)\n\n        \n# with norm(p) = 1\n\n        \n\u03b4q\n  \n=\n \n\u03b4qprev\n \n-\n \n2\n*\ndot\n(\n\u03b4qprev\n,\nn\n)\n*\nn\n\n        \n\u03b4p\n  \n=\n \n\u03b4pprev\n \n-\n \n2\n*\ndot\n(\n\u03b4pprev\n,\nn\n)\n*\nn\n \n-\n \ncurvature\n(\no\n)\n*\n2\n/\no\n.\nr\n*\ndot\n(\n\u03b4qprev\n,\nti\n)\n/\ncosa\n*\ntf\n\n        \n###\n\n        \noffset\n[\nk\n]\n \n=\n \nvcat\n(\n\u03b4q\n,\n \n\u03b4p\n)\n\n    \nend\n\n\nend\n\n\n\n@inline\n \ncurvature\n(\n::\nSemicircle\n)\n \n=\n \n-\n1\n\n\n@inline\n \ncurvature\n(\n::\nDisk\n)\n \n=\n \n+\n1\n\n\n\n\n\n\nNote that calculating Lyapunov exponents for magnetic particles requires a separate method, as the formulas are different for magnetic propagation.\n\n\nFinally, we also add a methods for \nto_bcoords\n and \nfrom_bcoords\n. For them, see the relevant source file (use \n@which\n).\n\n\nReferences\n\n\n[1] : Ch. Dellago et al., Phys. Rev. E 53, 1485 (1996).", 
            "title": "Creating your own Obstacle"
        }, 
        {
            "location": "/tutorials/own_obstacle/#creating-your-own-obstacle-type", 
            "text": "In this tutorial we will go through the processes of creating a new obstacle type, a  Semicircle . This type is already used in the  billiard_bunimovich  and  billiard_mushroom  functions.   Everything uses  SVector{2}  Fields of  Particle s and  Obstacle s contain all their information in 2-dimensional static vectors from module  StaticArrays . This is important to keep in mind when extending new methods.    Extends internal APIs  Notice that implementing your own obstacle requires you to extend methods that  do not  belong to the public API.    See also the  Ellipse  PR  Pull Request  #159  implements the  Ellipse  obstacle, step by step, by following the tutorial of this page. All commits are commented and it can be a second helpful guide on how to implement an obstacle.", 
            "title": "Creating your own Obstacle Type"
        }, 
        {
            "location": "/tutorials/own_obstacle/#type-definition", 
            "text": "The first thing you have to do is make your new type a sub-type of  Obstacle{T}  (or any other abstract sub-type of it). We will do:  struct   Semicircle { T : AbstractFloat }   :   Circular { T }   #  : Obstacle{T} \n     c :: SVector { 2 , T }   # this MUST be a static vector \n     r :: T \n     facedir :: SVector { 2 , T }   # this MUST be a static vector \n     name :: String   # this is an OPTIONAL field  end   c  is the center and  r  is the radius of the full circle.  facedir  is the direction which the semicircle is facing, which is also the direction of its \"open\" face.  name  is an optional field, that allows one to easily identify which obstacle is which. It is also used when printing a  Billiard . If not used, then  string(typeof(obstacle))  is used instead.  Notice that the  struct   must be  parameterized by  T :AbstractFloat  (see the  numerical precision  page for more).  For convenience, we will also define:  function   Semicircle ( \n     c :: AbstractVector { T },   r :: Real ,   facedir ,   name   =   Semicircle )   where   { T : Real } \n     S   =   T   :   Integer   ?   Float64   :   T \n     return   Semicircle { S }( SVector { 2 , S }( c ),   convert ( S ,   abs ( r )),   name )  end   so that constructing a  Semicircle  is possible from arbitrary vectors.", 
            "title": "Type Definition"
        }, 
        {
            "location": "/tutorials/own_obstacle/#necessary-methods", 
            "text": "The following functions must obtain methods for  Semicircle  (or any other custom  Obstacle ) in order for it to work with  DynamicalBilliards :   DynamicalBilliards.normalvec  DynamicalBilliards.distance  (with arguments  (position, obstacle) )  DynamicalBilliards.collision  with  Particle   Assuming that upon collision a specular reflection happens, then you don't need to define a method for  DynamicalBilliards.specular! . You can however define custom methods for  DynamicalBilliards.specular! , which is what we have done e.g. for  RandomDisk .   Use  import !  Notice that you have to properly  import  the methods to extend them. For example, do  import DynamicalBilliards: normalvec, distance, collision  time.   The first method is very simple, just do:  import   DynamicalBilliards :   normalvec ,   distance ,   collision  normalvec ( d :: Semicircle ,   pos )   =   normalize ( d . c   -   pos )   Since the function is only used during  distance  and  DynamicalBilliards.resolvecollision!  and since we will be writing explicit methods for the first, we don't have to care about what happens when the particle is far away from the boundary.  The  distance  method is a bit tricky. Since the type already subtypes  Circular , the following definition from  DynamicalBilliards  applies:  distance ( pos :: AbstractVector ,   d :: Circular )   =   norm ( pos   -   d . c )   -   d . r   However, the method must be expanded. That is because when the particle is on the \"open\" half of the disk, the distance is not correct. We write:  SV   =   SVector { 2 }   #convenience  function   distance ( pos :: AbstractVector { T },   s :: Semicircle { T })   where   { T } \n     # Check on which half of circle is the particle \n     v1   =   pos   .-   s . c \n     nn   =   dot ( v1 ,   s . facedir ) \n     if   nn   \u2264   0   # I am  inside semicircle \n         return   s . r   -   norm ( pos   -   s . c ) \n     else   # I am on the  other side \n         end1   =   SV ( s . c [ 1 ]   +   s . r * s . facedir [ 2 ],   s . c [ 2 ]   -   s . r * s . facedir [ 1 ]) \n         end2   =   SV ( s . c [ 1 ]   -   s . r * s . facedir [ 2 ],   s . c [ 2 ]   +   s . r * s . facedir [ 1 ]) \n         return   min ( norm ( pos   -   end1 ),   norm ( pos   -   end2 )) \n     end  end   Notice that this definition always returns positive distance when the particle is on the \"other side\".  Finally, the method for  collision  is by far the most  trickiest . But, with pen, paper and a significant amount of patience, one can find a way:  function   collision ( p :: Particle { T },   d :: Semicircle { T }) :: T   where   { T } \n\n     dc   =   p . pos   -   d . c \n     B   =   dot ( p . vel ,   dc )           #velocity towards circle center: B   0 \n     C   =   dot ( dc ,   dc )   -   d . r * d . r      #being outside of circle: C   0 \n     \u0394   =   B ^ 2   -   C \n\n     \u0394   \u2264   0     return   nocollision ( T ) \n     sqrtD   =   sqrt ( \u0394 ) \n\n     nn   =   dot ( dc ,   d . facedir ) \n     if   nn   \u2265   0   # I am NOT inside semicircle \n         # Return most positive time \n         t   =   - B   +   sqrtD \n     else   # I am inside semicircle: \n         t   =   - B   -   sqrtD \n         # these lines make sure that the code works for ANY starting position: \n         if   t   \u2264   0   ||   distance ( p ,   d )   \u2264   accuracy ( T ) \n             t   =   - B   +   sqrtD \n         end \n     end \n     # This check is necessary to not collide with the non-existing side \n     newpos   =   p . pos   +   p . vel   *   t \n     if   dot ( newpos   -   d . c ,   d . facedir )   \u2265   0   # collision point on BAD HALF; \n         return   nocollision ( T ) \n     end \n     # If collision time is negative, return Inf: \n     t   \u2264   0.0   ?   nocollision ( T )   :   ( t ,   p . pos   +   t * p . vel )  end   And that is all. The obstacle now works perfectly fine for straight propagation.   Ray-Splitting support  Supporting ray-splitting for your custom obstacle is very easy. The first step is to give it a field called  pflag , which is a  Bool . The second step is to ensure that  collisiontime  works properly for particles coming from both directions of the obstacle! Both inside or outside! This is implemented for  Ellipse  in Pull Request  #159 .", 
            "title": "Necessary Methods"
        }, 
        {
            "location": "/tutorials/own_obstacle/#optional-methods", 
            "text": "DynamicalBilliards.cellsize  : Enables  randominside  with this obstacle.  collision  with  MagneticParticle  : enables magnetic propagation  plot  with  obstacle  : enables plotting  DynamicalBilliards.specular!  with  offset  : Allows  lyapunovspectrum  to be computed.  to_bcoords  : Allows the  boundarymap  and  boundarymap_portion  to be computed.  from_bcoords  : Allows  phasespace_portion  to be computed.   The  DynamicalBilliards.cellsize  method is kinda trivial:  import   DynamicalBilliards :   cellsize ,   plot ,   to_bcoords ,   from_bcoords  function   cellsize ( a :: Semicircle { T })   where   { T } \n     xmin ,   ymin   =   a . c   -   a . r \n     xmax ,   ymax   =   a . c   +   a . r \n     return   xmin ,   ymin ,   xmax ,   ymax  end   The  collision  method for  MagneticParticle  is also tricky, however it is almost identical with the method for the general  Circular  obstacle:  function   collision ( p :: MagneticParticle { T },   o :: Semicircle { T }) :: T   where   { T } \n     \u03c9   =   p . omega \n     pc ,   rc   =   cyclotron ( p ) \n     p1   =   o . c \n     r1   =   o . r \n     d   =   norm ( p1 - pc ) \n     if   ( d   =   rc   +   r1 )   ||   ( d   =   abs ( rc - r1 )) \n         return   nocollision ( T ) \n     end \n     # Solve quadratic: \n     a   =   ( rc ^ 2   -   r1 ^ 2   +   d ^ 2 ) / 2 d \n     h   =   sqrt ( rc ^ 2   -   a ^ 2 ) \n     # Collision points (always 2): \n     I1   =   SVector { 2 ,   T }( \n         pc [ 1 ]   +   a * ( p1 [ 1 ]   -   pc [ 1 ]) / d   +   h * ( p1 [ 2 ]   -   pc [ 2 ]) / d , \n         pc [ 2 ]   +   a * ( p1 [ 2 ]   -   pc [ 2 ]) / d   -   h * ( p1 [ 1 ]   -   pc [ 1 ]) / d \n     ) \n     I2   =   SVector { 2 ,   T }( \n         pc [ 1 ]   +   a * ( p1 [ 1 ]   -   pc [ 1 ]) / d   -   h * ( p1 [ 2 ]   -   pc [ 2 ]) / d , \n         pc [ 2 ]   +   a * ( p1 [ 2 ]   -   pc [ 2 ]) / d   +   h * ( p1 [ 1 ]   -   pc [ 1 ]) / d \n     ) \n     # Only consider intersections on the  correct  side of Semicircle: \n     cond1   =   dot ( I1 - o . c ,   o . facedir )     0 \n     cond2   =   dot ( I2 - o . c ,   o . facedir )     0 \n     # Collision time, equiv. to arc-length until collision point: \n     \u03b8 ,   I   =   nocollision ( T ) \n     if   cond1   ||   cond2 \n         for   ( Y ,   cond )   in   (( I1 ,   cond1 ),   ( I2 ,   cond2 )) \n             if   cond \n                 \u03c6   =   realangle ( p ,   o ,   Y ) \n                 \u03c6     \u03b8     ( \u03b8   =   \u03c6 ;   I   =   Y ) \n             end \n         end \n     end \n     # Collision time = arc-length until collision point \n     return   \u03b8 * rc ,   I  end   Then, we add swag by writing a method for  plot :  using   PyPlot  function   plot ( d :: Semicircle ;   kwargs ... ) \n     theta1   =   atan ( d . facedir [ 2 ],   d . facedir [ 1 ]) * 180 / \u03c0   +   90 \n     theta2   =   theta1   +   180 \n     edgecolor   =   DynamicalBilliards . obcolor ( d ) \n     s1   =   PyPlot . matplotlib [ : patches ][ : Arc ]( \n         d . c ,   2 d . r ,   2 d . r ,   theta1   =   theta1 ,   theta2   =   theta2 ,   edgecolor   =   edgecolor , \n         lw   =   2.0 ,   kwargs ... ) \n     PyPlot . gca ()[ : add_artist ]( s1 ) \n     PyPlot . show ()  end   To enable computation of Lyapunov exponents in billiards with your obstacle, you have to write another method for  specular!  that also handles the evolution of perturbation vectors in tangent space. For this, the method has to accept an argument of type  Vector{SVector{4, T}} , which contains the four perturbation vectors corresponding to the four Lyapunov exponents.  Finding a formula for the evolution of the perturbations requires some tricky calculations. Fortunately for us, the results for general circular obstacles were already determined by Dellago, Posch and Hoover [1] \u2013 we just have to implement them.  function   specular! ( p :: Particle { T },   o :: Circular { T }, \n     offset :: Vector { SVector { 4 ,   T }})   where   { T : AbstractFloat } \n\n     n   =   normalvec ( o ,   p . pos ) \n     ti   =   SV { T }( - p . vel [ 2 ], p . vel [ 1 ]) \n\n     cosa   =   - dot ( n ,   p . vel ) \n     p . vel   =   p . vel   +   2 * cosa * n \n\n     tf   =   SV { T }( - p . vel [ 2 ],   p . vel [ 1 ]) \n\n     for   k   in   1 : 4 \n         \u03b4qprev   =   offset [ k ][ \u03b4qind ] \n         \u03b4pprev   =   offset [ k ][ \u03b4pind ] \n         # Formulas from Dellago, Posch and Hoover, PRE 53, 2, 1996: 1485-1501 (eq. 27) \n         # with norm(p) = 1 \n         \u03b4q    =   \u03b4qprev   -   2 * dot ( \u03b4qprev , n ) * n \n         \u03b4p    =   \u03b4pprev   -   2 * dot ( \u03b4pprev , n ) * n   -   curvature ( o ) * 2 / o . r * dot ( \u03b4qprev , ti ) / cosa * tf \n         ### \n         offset [ k ]   =   vcat ( \u03b4q ,   \u03b4p ) \n     end  end  @inline   curvature ( :: Semicircle )   =   - 1  @inline   curvature ( :: Disk )   =   + 1   Note that calculating Lyapunov exponents for magnetic particles requires a separate method, as the formulas are different for magnetic propagation.  Finally, we also add a methods for  to_bcoords  and  from_bcoords . For them, see the relevant source file (use  @which ).  References  [1] : Ch. Dellago et al., Phys. Rev. E 53, 1485 (1996).", 
            "title": "Optional Methods"
        }, 
        {
            "location": "/tutorials/examples/", 
            "text": "This section has some examples of usage of \nDynamicalBilliards\n, with some brief comments.\n\n\n\n\nJulia-logo Billiard\n\n\nThe \"Julia-logo-billiard\" animation that is the logo of our package was made with the following code. The function \nbilliard_logo\n also exports the same result.\n\n\nusing\n \nDynamicalBilliards\n,\n \nPyPlot\n\n\n\n# %%\n\n\nh\n \n=\n \n1.0\n;\n \n\u03b1\n \n=\n \n0.8\n;\n \nr\n \n=\n \n0.18\n;\n \noff\n \n=\n \n0.25\n\n\n\ncos6\n \n=\n \ncos\n(\n\u03c0\n/\n6\n)\n\n\n\u03b2\n \n=\n \n(\nh\n \n-\n \ncos6\n*\n\u03b1\n)\n/\ncos6\n\n\nt\n \n=\n \n\u03b1\n \n+\n \n2\n\u03b2\n\n\ncenter_of_mass\n \n=\n \n[\n0.0\n,\n \n\u221a\n3\n*\nt\n/\n6\n]\n\n\nstartloc\n \n=\n \n[\n-\n\u03b1\n/\n2\n,\n \n0.0\n]\n\n\n\n# create directions of the hexagonal 6:\n\n\nhexvert\n \n=\n \n[(\ncos\n(\n2\n\u03c0\n*\ni\n/\n6\n),\n \nsin\n(\n2\n\u03c0\n*\ni\n/\n6\n))\n \nfor\n \ni\n \nin\n \n1\n:\n6\n]\n\n\ndirs\n \n=\n \n[\nSVector\n{\n2\n}(\nhexvert\n[\ni\n]\n \n.-\n \nhexvert\n[\nmod1\n(\ni\n+\n1\n,\n \n6\n)])\n \nfor\n \ni\n \nin\n \n1\n:\n6\n]\n\n\n\nframe\n \n=\n \nObstacle\n{\nFloat64\n}[]\n\n\nsp\n \n=\n \nstartloc\n\n\nep\n \n=\n \nstartloc\n \n+\n \n\u03b1\n*\ndirs\n[\n1\n]\n\n\nnormal\n \n=\n \n(\nw\n \n=\n \nep\n \n.-\n \nsp\n;\n \n[\n-\nw\n[\n2\n],\n \nw\n[\n1\n]])\n\n\npush!\n(\nframe\n,\n \nInfiniteWall\n(\nsp\n,\n \nep\n,\n \nnormal\n,\n \nframe 1\n))\n\n\n\nfor\n \ni\n \nin\n \n2\n:\n6\n\n    \ns\n \n=\n \niseven\n(\ni\n)\n \n?\n \n\u03b2\n \n:\n \n\u03b1\n\n    \nT\n \n=\n \nInfiniteWall\n \n#iseven(i) ? RandomWall : InfiniteWall\n\n    \nsp\n \n=\n \nframe\n[\ni\n-\n1\n]\n.\nep\n\n    \nep\n \n=\n \nsp\n \n+\n \ns\n*\ndirs\n[\ni\n]\n\n    \nnormal\n \n=\n \n(\nw\n \n=\n \nep\n \n.-\n \nsp\n;\n \n[\n-\nw\n[\n2\n],\n \nw\n[\n1\n]])\n\n    \npush!\n(\nframe\n,\n \nT\n(\nsp\n,\n \nep\n,\n \nnormal\n,\n \nframe \n$\n(\ni\n)\n))\n\n\nend\n\n\n\n# Radii of circles that compose the Julia logo\n\n\noffset\n \n=\n \n[\n0.0\n,\n \noff\n]\n\n\nR\n \n=\n \n[\ncos\n(\n2\n\u03c0\n/\n3\n)\n \n-\nsin\n(\n2\n\u03c0\n/\n3\n);\n\n     \nsin\n(\n2\n\u03c0\n/\n3\n)\n  \ncos\n(\n2\n\u03c0\n/\n3\n)]\n\n\n\ngreen\n \n=\n \nDisk\n(\ncenter_of_mass\n \n.+\n \noffset\n,\n \nr\n,\n \ngreen\n)\n\n\nred\n \n=\n \nAntidot\n(\ncenter_of_mass\n \n.+\n \nR\n*\noffset\n,\n \nr\n,\n \nred\n)\n\n\npurple\n \n=\n \nRandomDisk\n(\ncenter_of_mass\n \n.+\n \nR\n*\nR\n*\noffset\n,\n \nr\n,\n \npurple\n)\n\n\n\nbd\n \n=\n \nBilliard\n(\ngreen\n,\n \nred\n,\n \npurple\n,\n \nframe\n...\n)\n\n\n\n# Raysplitting functions for the red circle:\n\n\nrefraction\n \n=\n \n(\n\u03c6\n,\n \npflag\n,\n \n\u03c9\n)\n \n-\n \npflag\n \n?\n \n0.5\n\u03c6\n \n:\n \n2.0\n\u03c6\n\n\ntransmission_p\n \n=\n \n(\np\n)\n \n-\n \n(\n\u03c6\n,\n \npflag\n,\n \n\u03c9\n)\n \n-\n \nbegin\n\n    \nif\n \npflag\n\n        \np\n*\nexp\n(\n-\n(\n\u03c6\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n8\n)\n^\n2\n)\n\n    \nelse\n\n        \nabs\n(\n\u03c6\n)\n \n \n\u03c0\n/\n4\n \n?\n \n(\n1\n-\np\n)\n*\nexp\n(\n-\n(\n\u03c6\n)\n^\n2\n/\n2\n(\n\u03c0\n/\n4\n)\n^\n2\n)\n \n:\n \n0.0\n\n    \nend\n\n\nend\n\n\nnewoantidot\n \n=\n \n((\nx\n,\n \nbool\n)\n \n-\n \nbool\n \n?\n \n-\n2.0\nx\n \n:\n \n-\n0.5\nx\n)\n\n\nraya\n \n=\n \nRaySplitter\n([\n2\n],\n \ntransmission_p\n(\n0.5\n),\n \nrefraction\n,\n \nnewoantidot\n)\n\n\n\n# Create and animate particles\n\n\nN\n \n=\n \n5\n\n\nparticles\n \n=\n \n[\nMagneticParticle\n(\n-\n0.3\n,\n \n0.7\n \n+\n \n0.0005\n*\ni\n,\n \n0.0\n,\n \n-\n2.0\n)\n \nfor\n \ni\n \nin\n \n1\n:\nN\n]\n\n\ncs\n \n=\n \n[(\n0\n,\n \n0\n,\n \ni\n/\nN\n,\n \n0.75\n)\n \nfor\n \ni\n \nin\n \n1\n:\nN\n]\n\n\n\nanimate_evolution\n(\nparticles\n,\n \nbd\n,\n \n10.0\n,\n \n(\nraya\n,);\n\n\ncolors\n \n=\n \ncs\n,\n \ndisable_axis\n \n=\n \ntrue\n)\n\n\n\n\n\n\n \n \n\n\n\n\n\nMean Free Path of the Lorentz Gas\n\n\nusing\n \nDynamicalBilliards\n\n\nbd\n \n=\n \nbilliard_lorentz\n(\n0.2\n)\n \n#alias for billiard_sinai(setting = \nperiodic\n)\n\n\nmfp\n \n=\n \nmeancollisiontime\n(\nrandominside\n(\nbd\n),\n \nbd\n,\n \n1000000.0\n)\n\n\n\n\n\n\n2.18229306442844\n\n\n\n\n\nThe result is very close to the analytic result:\n\n\n\\text{m.f.p.} =  \\frac{1-\\pi r^2 }{2r} \\stackrel{r=0.2}{=} 2.18584\n\\text{m.f.p.} =  \\frac{1-\\pi r^2 }{2r} \\stackrel{r=0.2}{=} 2.18584\n\n\nwhich you can find for example \nhere\n.\n\n\n\n\nSemi-Periodic Billiard\n\n\nDynamicalBilliards\n allows for your system to be periodic in only some specific directions. For example, the following code produces a billiard that is periodic in only the x-direction:\n\n\n```@example tut3\nusing DynamicalBilliards, PyPlot\no = 0.0; x = 2.0; y=1.0\n\n\nsp = [o,o]; ep = [o, y]; n = [x,o]\nleftw = PeriodicWall(sp, ep, n, \"Left periodic boundary\")\nsp = [x,o]; ep = [x, y]; n = [-x,o]\nrightw = PeriodicWall(sp, ep, n, \"Right periodic boundary\")\n\n\nsp = [o,y]; ep = [x, y]; n = [o,-y]\ntopw2 = InfiniteWall(sp, ep, n, \"Top wall\")\nsp = [o,o]; ep = [x, o]; n = [o,y]\nbotw2 = InfiniteWall(sp, ep, n, \"Bottom wall\")\n\n\nr = 0.25\nd = Disk([0.5, 0.5], r)\nd2 = Disk([1.5, 0.5], r/2)\n\n\nbd = Billiard(leftw, rightw, topw2, botw2, d, d2)\n\n\np = randominside(bd)\np.pos = [0.311901, 0.740439]\np.vel = [0.548772, 0.835972]\nxt, yt, t = timeseries(p, bd, 25)\nplot(bd, xt, yt)\nscatter(xt[end], yt[end], color = \"black\")\nylim(0,y)\nxlim(floor(minimum(xt)), ceil(maximum(xt)))\nsavefig(\"xperiodic.svg\"); nothing # hide\n```", 
            "title": "Examples"
        }, 
        {
            "location": "/tutorials/examples/#julia-logo-billiard", 
            "text": "The \"Julia-logo-billiard\" animation that is the logo of our package was made with the following code. The function  billiard_logo  also exports the same result.  using   DynamicalBilliards ,   PyPlot  # %%  h   =   1.0 ;   \u03b1   =   0.8 ;   r   =   0.18 ;   off   =   0.25  cos6   =   cos ( \u03c0 / 6 )  \u03b2   =   ( h   -   cos6 * \u03b1 ) / cos6  t   =   \u03b1   +   2 \u03b2  center_of_mass   =   [ 0.0 ,   \u221a 3 * t / 6 ]  startloc   =   [ - \u03b1 / 2 ,   0.0 ]  # create directions of the hexagonal 6:  hexvert   =   [( cos ( 2 \u03c0 * i / 6 ),   sin ( 2 \u03c0 * i / 6 ))   for   i   in   1 : 6 ]  dirs   =   [ SVector { 2 }( hexvert [ i ]   .-   hexvert [ mod1 ( i + 1 ,   6 )])   for   i   in   1 : 6 ]  frame   =   Obstacle { Float64 }[]  sp   =   startloc  ep   =   startloc   +   \u03b1 * dirs [ 1 ]  normal   =   ( w   =   ep   .-   sp ;   [ - w [ 2 ],   w [ 1 ]])  push! ( frame ,   InfiniteWall ( sp ,   ep ,   normal ,   frame 1 ))  for   i   in   2 : 6 \n     s   =   iseven ( i )   ?   \u03b2   :   \u03b1 \n     T   =   InfiniteWall   #iseven(i) ? RandomWall : InfiniteWall \n     sp   =   frame [ i - 1 ] . ep \n     ep   =   sp   +   s * dirs [ i ] \n     normal   =   ( w   =   ep   .-   sp ;   [ - w [ 2 ],   w [ 1 ]]) \n     push! ( frame ,   T ( sp ,   ep ,   normal ,   frame  $ ( i ) ))  end  # Radii of circles that compose the Julia logo  offset   =   [ 0.0 ,   off ]  R   =   [ cos ( 2 \u03c0 / 3 )   - sin ( 2 \u03c0 / 3 ); \n      sin ( 2 \u03c0 / 3 )    cos ( 2 \u03c0 / 3 )]  green   =   Disk ( center_of_mass   .+   offset ,   r ,   green )  red   =   Antidot ( center_of_mass   .+   R * offset ,   r ,   red )  purple   =   RandomDisk ( center_of_mass   .+   R * R * offset ,   r ,   purple )  bd   =   Billiard ( green ,   red ,   purple ,   frame ... )  # Raysplitting functions for the red circle:  refraction   =   ( \u03c6 ,   pflag ,   \u03c9 )   -   pflag   ?   0.5 \u03c6   :   2.0 \u03c6  transmission_p   =   ( p )   -   ( \u03c6 ,   pflag ,   \u03c9 )   -   begin \n     if   pflag \n         p * exp ( - ( \u03c6 ) ^ 2 / 2 ( \u03c0 / 8 ) ^ 2 ) \n     else \n         abs ( \u03c6 )     \u03c0 / 4   ?   ( 1 - p ) * exp ( - ( \u03c6 ) ^ 2 / 2 ( \u03c0 / 4 ) ^ 2 )   :   0.0 \n     end  end  newoantidot   =   (( x ,   bool )   -   bool   ?   - 2.0 x   :   - 0.5 x )  raya   =   RaySplitter ([ 2 ],   transmission_p ( 0.5 ),   refraction ,   newoantidot )  # Create and animate particles  N   =   5  particles   =   [ MagneticParticle ( - 0.3 ,   0.7   +   0.0005 * i ,   0.0 ,   - 2.0 )   for   i   in   1 : N ]  cs   =   [( 0 ,   0 ,   i / N ,   0.75 )   for   i   in   1 : N ]  animate_evolution ( particles ,   bd ,   10.0 ,   ( raya ,);  colors   =   cs ,   disable_axis   =   true )", 
            "title": "Julia-logo Billiard"
        }, 
        {
            "location": "/tutorials/examples/#mean-free-path-of-the-lorentz-gas", 
            "text": "using   DynamicalBilliards  bd   =   billiard_lorentz ( 0.2 )   #alias for billiard_sinai(setting =  periodic )  mfp   =   meancollisiontime ( randominside ( bd ),   bd ,   1000000.0 )   2.18229306442844  The result is very close to the analytic result:  \\text{m.f.p.} =  \\frac{1-\\pi r^2 }{2r} \\stackrel{r=0.2}{=} 2.18584 \\text{m.f.p.} =  \\frac{1-\\pi r^2 }{2r} \\stackrel{r=0.2}{=} 2.18584  which you can find for example  here .", 
            "title": "Mean Free Path of the Lorentz Gas"
        }, 
        {
            "location": "/tutorials/examples/#semi-periodic-billiard", 
            "text": "DynamicalBilliards  allows for your system to be periodic in only some specific directions. For example, the following code produces a billiard that is periodic in only the x-direction:  ```@example tut3\nusing DynamicalBilliards, PyPlot\no = 0.0; x = 2.0; y=1.0  sp = [o,o]; ep = [o, y]; n = [x,o]\nleftw = PeriodicWall(sp, ep, n, \"Left periodic boundary\")\nsp = [x,o]; ep = [x, y]; n = [-x,o]\nrightw = PeriodicWall(sp, ep, n, \"Right periodic boundary\")  sp = [o,y]; ep = [x, y]; n = [o,-y]\ntopw2 = InfiniteWall(sp, ep, n, \"Top wall\")\nsp = [o,o]; ep = [x, o]; n = [o,y]\nbotw2 = InfiniteWall(sp, ep, n, \"Bottom wall\")  r = 0.25\nd = Disk([0.5, 0.5], r)\nd2 = Disk([1.5, 0.5], r/2)  bd = Billiard(leftw, rightw, topw2, botw2, d, d2)  p = randominside(bd)\np.pos = [0.311901, 0.740439]\np.vel = [0.548772, 0.835972]\nxt, yt, t = timeseries(p, bd, 25)\nplot(bd, xt, yt)\nscatter(xt[end], yt[end], color = \"black\")\nylim(0,y)\nxlim(floor(minimum(xt)), ceil(maximum(xt)))\nsavefig(\"xperiodic.svg\"); nothing # hide\n```", 
            "title": "Semi-Periodic Billiard"
        }
    ]
}