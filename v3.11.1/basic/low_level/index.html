<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · DynamicalBilliards.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalBilliards.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalBilliards.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../high_level/">High Level API</a></li><li><a class="tocitem" href="../../visualizing/">Visualizing &amp; Animating</a></li><li><a class="tocitem" href="../phasespaces/">Phase Spaces</a></li><li><a class="tocitem" href="../../ray-splitting/">Ray-Splitting</a></li><li><a class="tocitem" href="../../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../mushroomtools/">MushroomTools</a></li><li><a class="tocitem" href="../../physics/">Physics</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Implementation-1"><span>Implementation</span></a></li><li><a class="tocitem" href="#Numerical-Precision-1"><span>Numerical Precision</span></a></li><li><a class="tocitem" href="#Collision-Times-1"><span>Collision Times</span></a></li><li><a class="tocitem" href="#Non-Exported-Internals-1"><span>Non-Exported Internals</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/billiard_table/">Defining a Billiard</a></li><li><a class="tocitem" href="../../tutorials/own_obstacle/">Defining your own Obstacles</a></li><li><a class="tocitem" href="../../tutorials/examples/">Examples</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/master/docs/src/basic/low_level.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals-1"><a class="docs-heading-anchor" href="#Internals-1">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-1" title="Permalink"></a></h1><p>This page is <strong>not</strong> part of the public API defined by <code>DynamicalBilliards</code>. Consider it something like a <em>developer&#39;s guide</em>.</p><h2 id="Implementation-1"><a class="docs-heading-anchor" href="#Implementation-1">Implementation</a><a class="docs-heading-anchor-permalink" href="#Implementation-1" title="Permalink"></a></h2><p>Before talking about the low level methods that enable everything to work nicely together, let&#39;s talk about how this package works.</p><p>Firstly one defines a <a href="../../tutorials/billiard_table/#DynamicalBilliards.Billiard"><code>Billiard</code></a> and optionally some <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Then one creates a particle inside the defined billiard. The algorithm for the propagation of a particle is the following:</p><ol><li>Calculate the <a href="#DynamicalBilliards.collision"><code>collision</code></a> of the particle with <strong>all</strong> obstacles in the billiard.</li><li>Find the collision that happens first (in time), and the obstacle corresponding to that.</li><li><a href="#DynamicalBilliards.relocate!"><code>DynamicalBilliards.relocate!</code></a> the particle, and ensure that it is <strong>inside</strong> the billiard. This means that <a href="#DynamicalBilliards.distance"><code>DynamicalBilliards.distance</code></a> between particle and obstacle is either positive or close to machine precision.</li><li>(Optionally) check if there is transmission for ray-splitting: <code>T(φ) &gt; rand()</code></li></ol><ul><li>If yes, perform the ray-splitting algorithm (see the <a href="../../ray-splitting/#Ray-Splitting-1">Ray-Splitting</a> page).</li><li>If not, then <a href="#DynamicalBilliards.resolvecollision!"><code>DynamicalBilliards.resolvecollision!</code></a> of the particle with the obstacle (specular or periodic conditions).</li></ul><ol><li>Continue this loop for a given amount of time.</li></ol><p>Notice that the <a href="#DynamicalBilliards.relocate!"><code>DynamicalBilliards.relocate!</code></a> step is <em>very</em> important because it takes care that all particles remain inside the billiard.</p><p>The exposed <a href="../high_level/#DynamicalBilliards.bounce!"><code>bounce!</code></a> function bundles steps 1-4 together.</p><h3 id="Where-is-&quot;inside&quot;?-1"><a class="docs-heading-anchor" href="#Where-is-&quot;inside&quot;?-1">Where is &quot;inside&quot;?</a><a class="docs-heading-anchor-permalink" href="#Where-is-&quot;inside&quot;?-1" title="Permalink"></a></h3><p>If for some reason (finite numeric precision) a particle goes outside a billiard, then it will escape to infinity. But what <em>is</em> inside?</p><p>&quot;Inside&quot; is defined on obstacle level by the function <code>distance</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.distance" href="#DynamicalBilliards.distance"><code>DynamicalBilliards.distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distance(p::AbstractParticle, o::Obstacle)</code></pre><p>Return the <strong>signed</strong> distance between particle <code>p</code> and obstacle <code>o</code>, based on <code>p.pos</code>. Positive distance corresponds to the particle being on the <em>allowed</em> region of the <code>Obstacle</code>. E.g. for a <code>Disk</code>, the distance is positive when the particle is outside of the disk, negative otherwise.</p><pre><code class="language-none">distance(p::AbstractParticle, bd::Billiard)</code></pre><p>Return minimum <code>distance(p, obst)</code> for all <code>obst</code> in <code>bd</code>. If the <code>distance(p, bd)</code> is negative and <code>bd</code> is convex, this means that the particle is outside the billiard.</p><p><strong>WARNING</strong> : <code>distance(p, bd)</code> may give negative values for non-convex billiards, or billiards that are composed of several connected sub-billiards.</p><p>All <code>distance</code> functions can also be given a position (vector) instead of a particle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/billiards/obstacles.jl#L439-L455">source</a></section></article><p>Notice that for very small negative values of distance, <a href="#DynamicalBilliards.collision"><code>collision</code></a> takes care of finite precision issues and does not return wrong collisions.</p><h2 id="Numerical-Precision-1"><a class="docs-heading-anchor" href="#Numerical-Precision-1">Numerical Precision</a><a class="docs-heading-anchor-permalink" href="#Numerical-Precision-1" title="Permalink"></a></h2><p>All core types of <code>DynamicalBilliards</code> are parametrically constructed, with parameter <code>T &lt;: AbstractFloat</code>. This means that the fields of all particles and obstacles contain numbers strictly of type <code>T</code>. You will understand why this choice happened as you continue reading this paragraph.</p><p>The main concerns during evolution in a billiard table are:</p><ol><li>The particle must never leak out of the billiard table. This is simply translated to the <code>distance</code> function being positive after any collision <em>and</em> that <code>collision</code> takes care of extreme cases with very small (but negative) distance.</li><li>The collision time is never infinite, besides the cases of <a href="../../physics/#Pinned-Particles-1">Pinned Particles</a> in a magnetic billiard.</li></ol><p>These are solved with two ways:</p><ol><li>After the next collision is computed, <code>relocate!</code> brings the particle to that point and calculates the <code>distance</code> with the colliding obstacle. If it is negative, it translates the particle&#39;s position by this distance, <em>along the normal vector</em>.</li><li><code>collision</code> takes care of cases where the distance between particle and obstacle is less than <code>accuracy(::T)</code>. (This is necessary only for magnetic propagation, as for straight propagation checking the velocity direction with respect to the normal is always enough).</li></ol><p>Adjusting the global precision of <code>DynamicalBilliards</code> is easy and can be done by choosing the floating precision you would like. This is done by initializing your billiard table with parametric type <code>T</code>, e.g. <code>bd = billiard_sinai(Float16(0.3))</code>. This choice will propagate to the entire <code>bd</code>, all particles resulting from <a href="../high_level/#DynamicalBilliards.randominside"><code>randominside</code></a>, <strong>as well as the entire evolution process</strong>.</p><div class="admonition is-danger"><header class="admonition-header">BigFloats</header><div class="admonition-body"><p>Evolution with <code>BigFloat</code> in <code>DynamicalBilliards</code> is on average 3 to 4 orders of magnitude slower than with <code>Float64</code>.</p></div></div><hr/><h2 id="Collision-Times-1"><a class="docs-heading-anchor" href="#Collision-Times-1">Collision Times</a><a class="docs-heading-anchor-permalink" href="#Collision-Times-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.collision" href="#DynamicalBilliards.collision"><code>DynamicalBilliards.collision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collision(p::AbstractParticle, o::Obstacle) → t, cp</code></pre><p>Find the collision (if any) between given particle and obstacle. Return the time until collision and the estimated collision point <code>cp</code>.</p><p>Return <code>Inf, SV(0, 0)</code> if the collision is not possible <em>or</em> if the collision happens backwards in time.</p><p><strong>It is the duty of <code>collision</code> to avoid incorrect collisions when the particle is on top of the obstacle (or very close).</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/timeevolution/collisions.jl#L21-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.next_collision" href="#DynamicalBilliards.next_collision"><code>DynamicalBilliards.next_collision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">next_collision(p::AbstractParticle, bd::Billiard) -&gt; i, tmin, cp</code></pre><p>Compute the <a href="#DynamicalBilliards.collision"><code>collision</code></a> across all obstacles in <code>bd</code> and find the minimum one. Return the index of colliding obstacle, the time and the collision point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/timeevolution/collisions.jl#L327-L331">source</a></section></article><h2 id="Non-Exported-Internals-1"><a class="docs-heading-anchor" href="#Non-Exported-Internals-1">Non-Exported Internals</a><a class="docs-heading-anchor-permalink" href="#Non-Exported-Internals-1" title="Permalink"></a></h2><h3 id="Obstacle-related-1"><a class="docs-heading-anchor" href="#Obstacle-related-1">Obstacle related</a><a class="docs-heading-anchor-permalink" href="#Obstacle-related-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.normalvec" href="#DynamicalBilliards.normalvec"><code>DynamicalBilliards.normalvec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalvec(obst::Obstacle, position)</code></pre><p>Return the vector normal to the obstacle&#39;s boundary at the given position (which is assumed to be very close to the obstacle&#39;s boundary).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/billiards/obstacles.jl#L405-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.cellsize" href="#DynamicalBilliards.cellsize"><code>DynamicalBilliards.cellsize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cellsize(bd)</code></pre><p>Return the delimiters <code>xmin, ymin, xmax, ymax</code> of the given obstacle/billiard.</p><p>Used in <code>randominside()</code>, error checking and plotting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/billiards/obstacles.jl#L521-L526">source</a></section></article><h3 id="Propagation-1"><a class="docs-heading-anchor" href="#Propagation-1">Propagation</a><a class="docs-heading-anchor-permalink" href="#Propagation-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.propagate!" href="#DynamicalBilliards.propagate!"><code>DynamicalBilliards.propagate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propagate!(p::AbstractParticle, t)</code></pre><p>Propagate the particle <code>p</code> for given time <code>t</code>, changing appropriately the the <code>p.pos</code> and <code>p.vel</code> fields.</p><pre><code class="language-none">propagate!(p, position, t)</code></pre><p>Do the same, but take advantage of the already calculated <code>position</code> that the particle should end up at.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/timeevolution/propagation.jl#L68-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.resolvecollision!" href="#DynamicalBilliards.resolvecollision!"><code>DynamicalBilliards.resolvecollision!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resolvecollision!(p::AbstractParticle, o::Obstacle)</code></pre><p>Resolve the collision between particle <code>p</code> and obstacle <code>o</code>, depending on the type of <code>o</code> (do <code>specular!</code> or <code>periodicity!</code>).</p><pre><code class="language-none">resolvecollision!(p, o, T::Function, θ::Function, new_ω::Function)</code></pre><p>This is the ray-splitting implementation. The three functions given are drawn from the ray-splitting dictionary that is passed directly to <code>evolve!()</code>. For a calculated incidence angle φ, if T(φ) &gt; rand(), ray-splitting occurs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/timeevolution/propagation.jl#L145-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.relocate!" href="#DynamicalBilliards.relocate!"><code>DynamicalBilliards.relocate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">relocate!(p::AbstractParticle, o::Obstacle, t, cp)</code></pre><p>Propagate the particle to <code>cp</code> and propagate velocities for time <code>t</code>. Check if it is on the correct side of the obstacle. If not, change the particle position by <a href="#DynamicalBilliards.distance"><code>distance</code></a> along the <a href="#DynamicalBilliards.normalvec"><code>normalvec</code></a> of the obstacle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/timeevolution/propagation.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.specular!" href="#DynamicalBilliards.specular!"><code>DynamicalBilliards.specular!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">specular!(p::AbstractParticle, o::Obstacle)</code></pre><p>Perform specular reflection based on the normal vector of the Obstacle.</p><p>In the case where the given obstacle is a <code>RandomObstacle</code>, the specular reflection randomizes the velocity instead (within -π/2+ε to π/2-ε of the normal vector).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/timeevolution/propagation.jl#L102-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.periodicity!" href="#DynamicalBilliards.periodicity!"><code>DynamicalBilliards.periodicity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">periodicity!(p::AbstractParticle, w::PeriodicWall)</code></pre><p>Perform periodicity conditions of <code>w</code> on <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/timeevolution/propagation.jl#L129-L132">source</a></section></article><h3 id="Timeseries-1"><a class="docs-heading-anchor" href="#Timeseries-1">Timeseries</a><a class="docs-heading-anchor-permalink" href="#Timeseries-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.extrapolate" href="#DynamicalBilliards.extrapolate"><code>DynamicalBilliards.extrapolate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">extrapolate(particle, prevpos, prevvel, ct, dt[, ω]) → x, y, vx, vy, t</code></pre><p>Create the timeseries that connect a <code>particle</code>&#39;s previous position and velocity <code>prevpos, prevvel</code> with the <code>particle</code>&#39;s current position and velocity, provided that the collision time between previous and current state is <code>ct</code>.</p><p><code>dt</code> is the sampling time and if the <code>particle</code> is <code>MagneticParticle</code> then you should provide <code>ω</code>, the angular velocity that governed the free flight.</p><p>Here is how this function is used (for example)</p><pre><code class="language-julia">prevpos, prevvel = p.pos + p.current_cell, p.vel
for _ in 1:5
    i, ct, pos, vel = bounce!(p, bd)
    x, y, x, vy, t = extrapolate(p, prevpos, prevvel, ct, 0.1)
    # append x, y, ... to other vectors or do whatever with them
    prevpos, prevvel = p.pos + p.current_cell, p.vel
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/96a7713845734dc4cde992790ce269c7c14fd685/src/timeevolution/timeseries.jl#L200-L220">source</a></section></article><hr/><div class="admonition is-warning"><header class="admonition-header">Cyclotron center is a field of `MagneticParticle`</header><div class="admonition-body"><p>For almost all operations involving a <code>MagneticParticle</code>, the center of the cyclotron is required. In order to compute this center only when it physically changes, we have made it a field of the <code>struct</code>.</p><p>This means that after changing the position or velocity of the particle, this center must be changed by doing <code>mp.center = DynamicalBilliards.find_cyclotron(mp)</code>. The <a href="../high_level/#DynamicalBilliards.bounce!"><code>bounce!</code></a> function takes care of that in the most opportune moment, but if you want to write your own specific low level function, do not forget this point!</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../physics/">« Physics</a><a class="docs-footer-nextpage" href="../../tutorials/billiard_table/">Defining a Billiard »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 22 April 2020 21:14">Wednesday 22 April 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
