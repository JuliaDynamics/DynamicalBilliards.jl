<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>High Level API · DynamicalBilliards.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DynamicalBilliards.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li class="is-active"><a class="tocitem" href>High Level API</a><ul class="internal"><li><a class="tocitem" href="#Billiard-1"><span>Billiard</span></a></li><li><a class="tocitem" href="#Particles-1"><span>Particles</span></a></li><li><a class="tocitem" href="#Random-initial-conditions-1"><span>Random initial conditions</span></a></li><li><a class="tocitem" href="#evolve-and-timeseries-1"><span><code>evolve</code> &amp; <code>timeseries</code></span></a></li><li><a class="tocitem" href="#Poincaré-Sections-1"><span>Poincaré Sections</span></a></li><li><a class="tocitem" href="#Escape-Times-1"><span>Escape Times</span></a></li><li><a class="tocitem" href="#Mean-Collision-Times-1"><span>Mean Collision Times</span></a></li><li><a class="tocitem" href="#Parallelization-1"><span>Parallelization</span></a></li><li><a class="tocitem" href="#It&#39;s-all-about-bounce!-1"><span>It&#39;s all about bounce!</span></a></li><li><a class="tocitem" href="#Standard-Billiards-Library-1"><span>Standard Billiards Library</span></a></li><li><a class="tocitem" href="#Particle-types-1"><span>Particle types</span></a></li></ul></li><li><a class="tocitem" href="../../visualizing/">Visualizing &amp; Animating</a></li><li><a class="tocitem" href="../phasespaces/">Phase Spaces</a></li><li><a class="tocitem" href="../../ray-splitting/">Ray-Splitting</a></li><li><a class="tocitem" href="../../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../mushroomtools/">MushroomTools</a></li><li><a class="tocitem" href="../../physics/">Physics</a></li><li><a class="tocitem" href="../low_level/">Internals</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/billiard_table/">Defining a Billiard</a></li><li><a class="tocitem" href="../../tutorials/own_obstacle/">Defining your own Obstacles</a></li><li><a class="tocitem" href="../../tutorials/examples/">Examples</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>High Level API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>High Level API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/master/docs/src/basic/high_level.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="High-Level-API-1"><a class="docs-heading-anchor" href="#High-Level-API-1">High Level API</a><a class="docs-heading-anchor-permalink" href="#High-Level-API-1" title="Permalink"></a></h1><p><code>DynamicalBilliards</code> was created with ease-of-use as its main cornerstone. With 3 simple steps, the user can get the output of the propagation of a particle in a billiard.</p><p>In general, the workflow of <code>DynamicalBilliards</code> follows these simple steps:</p><ol><li>Create a billiard.</li><li>Create particles inside that billiard.</li><li>Get the output you want by using one of the high level functions.</li></ol><p>Adding more complexity in your billiard does not add complexity in your code. For example, to implement a ray-splitting billiard you only need to define one additional variable, a <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> and pass it to the high level functions.</p><p>After reading through this page, you will be able to use almost all aspects of <code>DynamicalBilliards</code> with minimal effort.</p><div class="admonition is-success"><header class="admonition-header">Visualizations</header><div class="admonition-body"><p>Visualizing the billiards, particles, and their motion is one of the most important parts of the <code>DynamicalBilliards</code>. It is not discussed in this page however, but rather in the <a href="../../visualizing/#Visualizing-and-Animating-1">Visualizing &amp; Animating</a> page.</p></div></div><h2 id="Billiard-1"><a class="docs-heading-anchor" href="#Billiard-1">Billiard</a><a class="docs-heading-anchor-permalink" href="#Billiard-1" title="Permalink"></a></h2><p>A <a href="../../tutorials/billiard_table/#DynamicalBilliards.Billiard"><code>Billiard</code></a> is simply a collection of <a href="../../tutorials/billiard_table/#DynamicalBilliards.Obstacle"><code>Obstacle</code></a> subtypes. Particles are propagating inside a <code>Billiard</code>, bouncing from obstacle to obstacle while having constant velocity in-between.</p><p>There is a tutorial on how to create your own billiard. In addition, there are many pre-defined billiards that can be found in the <a href="#Standard-Billiards-Library-1">Standard Billiards Library</a> section. That is why knowing how to construct a <a href="../../tutorials/billiard_table/#DynamicalBilliards.Billiard"><code>Billiard</code></a> is not important at this point.</p><p>In this page we will be using the Bunimovich billiard as an example:</p><pre><code class="language-julia">using DynamicalBilliards
bd = billiard_bunimovich()</code></pre><pre><code class="language-none">Billiard{Float64} with 4 obstacles:
  Bottom wall
  Right semicircle
  Top wall
  Left semicircle</code></pre><h2 id="Particles-1"><a class="docs-heading-anchor" href="#Particles-1">Particles</a><a class="docs-heading-anchor-permalink" href="#Particles-1" title="Permalink"></a></h2><p>A &quot;particle&quot; is that thingy that moves around in the billiard. It always moves with velocity of measure 1, by convention.</p><p>Currently there are two types of particles:</p><ul><li><a href="#DynamicalBilliards.Particle"><code>Particle</code></a>, which propagates as a straight line.</li><li><a href="#DynamicalBilliards.MagneticParticle"><code>MagneticParticle</code></a>, which propagates as a circle instead of a line (similar to electrons in a perpendicular magnetic field).</li></ul><p>There are two ways to create a particle. The first one is to provide the constructor with some initial conditions:</p><pre><code class="language-julia">x0 = rand(); y0 = rand();
φ0 = 2π*rand()
p = Particle(x0, y0, φ0)</code></pre><pre><code class="language-none">Particle{Float64}
position: [0.585689010292795, 0.4498304689673709]
velocity: [-0.9445634915199392, -0.328328814586326]</code></pre><p>To create a <code>MagneticParticle</code> simply provide the constructor with one more number, the angular velocity:</p><pre><code class="language-julia">ω = 0.5
mp = MagneticParticle(x0, y0, φ0, ω)</code></pre><pre><code class="language-none">MagneticParticle{Float64}
position: [0.585689010292795, 0.4498304689673709]
velocity: [-0.9445634915199392, -0.328328814586326]
ang. velocity: 0.5</code></pre><p>When creating a billiard or a particle, the object is printed with <code>{Float64}</code> at the end. This shows what type of numbers are used for <em>all</em> numerical operations. If you are curious you can learn more about it in the <a href="../low_level/#Numerical-Precision-1">Numerical Precision</a>.</p><div class="admonition is-danger"><header class="admonition-header">Particles must be inside the Billiard!</header><div class="admonition-body"><p>Keep in mind that the particle must be initialized <strong>inside a billiard</strong> for any functionality to work properly and make sense. If you are not sure what we mean by that, then you should check out the <a href="../low_level/#Internals-1">Internals</a> page.</p></div></div><h2 id="Random-initial-conditions-1"><a class="docs-heading-anchor" href="#Random-initial-conditions-1">Random initial conditions</a><a class="docs-heading-anchor-permalink" href="#Random-initial-conditions-1" title="Permalink"></a></h2><p>If you have a <code>Billiard</code> which is not a rectangle, creating many random initial conditions inside it can be a pain. Fortunately, the second way to create a particle is to use the following function:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.randominside" href="#DynamicalBilliards.randominside"><code>DynamicalBilliards.randominside</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randominside(bd::Billiard [, ω])</code></pre><p>Return a particle with random allowed initial conditions inside the given billiard. If supplied with a second argument the type of the returned particle is <code>MagneticParticle</code>, with angular velocity <code>ω</code>.</p><p><strong>WARNING</strong> : <code>randominside</code> works for any <strong>convex</strong> billiard but it does not work for non-convex billiards. (this is because it uses <code>distance</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/billiardtable.jl#L124-L132">source</a></section></article><hr/><p>For example:</p><pre><code class="language-julia">p = randominside(bd)</code></pre><pre><code class="language-none">Particle{Float64}
position: [-0.34668166190363703, 0.8062674940295456]
velocity: [0.06992948037672611, -0.9975519373818293]</code></pre><p>and</p><pre><code class="language-julia">mp = randominside(bd, ω)</code></pre><pre><code class="language-none">MagneticParticle{Float64}
position: [0.20586649912784827, 0.2831504437717969]
velocity: [0.9084126159122253, -0.4180747771051349]
ang. velocity: 0.5</code></pre><p><code>randominside</code> always creates particles with same number type as the billiard.</p><h2 id="evolve-and-timeseries-1"><a class="docs-heading-anchor" href="#evolve-and-timeseries-1"><code>evolve</code> &amp; <code>timeseries</code></a><a class="docs-heading-anchor-permalink" href="#evolve-and-timeseries-1" title="Permalink"></a></h2><p>Now that we have created a billiard and a particle inside, we want to evolve it! There is a simple function for that, called <code>evolve!</code> (or <code>evolve</code> if you don&#39;t want to mutate the particle), which returns the time, position and velocities at the collision points:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.evolve!" href="#DynamicalBilliards.evolve!"><code>DynamicalBilliards.evolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evolve!([p::AbstractParticle,] bd::Billiard, t)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code>. If <code>t</code> is of type <code>AbstractFloat</code>, evolve for as much time as <code>t</code>. If however <code>t</code> is of type <code>Int</code>, evolve for as many collisions as <code>t</code>. Return the states of the particle between collisions.</p><p>This function mutates the particle, use <code>evolve</code> otherwise. If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</p><p><strong>Return</strong></p><ul><li><code>ct::Vector{T}</code> : Collision times.</li><li><code>poss::Vector{SVector{2,T}}</code> : Positions at the collisions.</li><li><code>vels::Vector{SVector{2,T}})</code> : Velocities exactly after the collisions.</li><li><code>ω</code>, either <code>T</code> or <code>Vector{T}</code> : Angular velocity/ies (returned only for magnetic particles).</li></ul><p>The time <code>ct[i+1]</code> is the time necessary to reach state <code>poss[i+1], vels[i+1]</code> starting from the state <code>poss[i], vels[i]</code>. That is why <code>ct[1]</code> is always 0 since <code>poss[1], vels[1]</code> are the initial conditions. The angular velocity <code>ω[i]</code> is the one the particle has while propagating from state <code>poss[i], vels[i]</code> to <code>i+1</code>.</p><p>Notice that at any point, the velocity vector <code>vels[i]</code> is the one obdained <em>after</em> the specular reflection of the <code>i-1</code>th collision.</p><p><strong>Ray-splitting billiards</strong></p><pre><code class="language-none">evolve!(p, bd, t, raysplitters)</code></pre><p>To implement ray-splitting, the <code>evolve!</code> function is supplemented with a fourth argument, <code>raysplitters</code> which is a tuple of <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Notice that <code>evolve</code> <strong>always mutates the billiard</strong> if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/timeevolution/timeseries.jl#L5-L39">source</a></section></article><hr/><p>Forget the ray-splitting part for now (see <a href="../../ray-splitting/#Ray-Splitting-1">Ray-Splitting</a>).</p><p>Let&#39;s see an example:</p><pre><code class="language-julia">ct, poss, vels = evolve(p, bd, 100)
for i in 1:5
  println(round(ct[i], digits=3), &quot;  &quot;, poss[i], &quot;  &quot;, vels[i])
end</code></pre><pre><code class="language-none">0.0  [-0.34668166190363703, 0.8062674940295456]  [0.06992948037672611, -0.9975519373818293]
0.71  [-0.29701585794003504, 0.09777918983207132]  [0.973964925208277, 0.2266987526741957]
1.845  [1.4997442344101735, 0.5159906276859157]  [-0.9864653852912905, 0.16396964237964257]
1.903  [-0.37737658251425293, 0.8280044435215219]  [0.29979011252716103, -0.9540051826017268]
0.852  [-0.12192440404269271, 0.015093370122830475]  [0.7153589164346712, 0.6987571972276321]</code></pre><p>Similarly, for magnetic propagation</p><pre><code class="language-julia">ct, poss, vels, ω = evolve(mp, bd, 100)
for i in 1:10
  println(round(ct[i], digits=3), &quot;  &quot;, poss[i], &quot;  &quot;, vels[i])
end</code></pre><pre><code class="language-none">0.0  [0.20586649912784827, 0.2831504437717969]  [0.9084126159122251, -0.4180747771051348]
1.147  [1.325089776279321, 0.12010970352131788]  [0.2928140777716174, 0.9561693970519856]
0.673  [1.411201368671934, 0.7844528685078208]  [-0.92113315601035, 0.3892476190015973]
1.992  [-0.49050085164003665, 0.5969995594855902]  [0.5513651109949436, -0.8342640555468837]
0.863  [0.12402599286752469, 0.0]  [0.8498648907377385, 0.5270006332931031]
1.317  [0.9436250659792704, 1.0]  [0.34986489073773863, -0.936800169848976]
0.901  [1.4352797138010245, 0.2539683541629288]  [-0.9648084156334765, 0.26295383838769326]
1.646  [-0.14754983357096468, 0.022266762080363753]  [-0.4030892788741094, 0.9151606598061076]
0.644  [-0.49642236292625896, 0.5597062608669281]  [0.8282876502343062, 0.5603031041046729]
0.644  [-0.030063621298275, 0.9990953603014497]  [0.699439810539201, -0.7146915078779704]</code></pre><p>The above return types are helpful in some applications. In other applications however one prefers to have the time series of the individual variables. For this, the <code>timeseries</code> function is used:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.timeseries!" href="#DynamicalBilliards.timeseries!"><code>DynamicalBilliards.timeseries!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timeseries!([p::AbstractParticle,] bd::Billiard, t; dt, warning)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code> for the condition <code>t</code> and return the x, y, vx, vy timeseries and the time vector. If <code>t</code> is of type <code>AbstractFloat</code>, then evolve for as much time as <code>t</code>. If however <code>t</code> is of type <code>Int</code>, evolve for as many collisions as <code>t</code>. Otherwise, <code>t</code> can be any function, that takes as an input <code>t(n, τ, i, p)</code> and returns <code>true</code> when the evolution should terminate. Here <code>n</code> is the amount of obstacles collided with so far, <code>τ</code> the amount time evolved so far, <code>i</code> the obstacle just collided with and <code>p</code> the particle (so you can access e.g. <code>p.pos</code>).</p><p>This function mutates the particle, use <code>timeseries</code> otherwise. If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</p><p>The keyword argument <code>dt</code> is the time step used for interpolating the time series in between collisions. <code>dt</code> is capped by the collision time, as the interpolation <em>always</em> stops at collisions. For straight propagation <code>dt = Inf</code>, while for magnetic <code>dt = 0.01</code>.</p><p>For pinned magnetic particles, <code>timeseries!</code> issues a warning and returns the trajectory of the particle. If <code>t</code> is integer, the trajectory is evolved for one full circle only.</p><p>Internally uses <a href="../low_level/#DynamicalBilliards.extrapolate"><code>DynamicalBilliards.extrapolate</code></a>.</p><p><strong>Ray-splitting billiards</strong></p><pre><code class="language-none">timeseries!(p, bd, t, raysplitters; ...)</code></pre><p>To implement ray-splitting, the <code>timeseries!</code> function is supplemented with a fourth argument, <code>raysplitters</code> which is a tuple of <a href="../../ray-splitting/#DynamicalBilliards.RaySplitter"><code>RaySplitter</code></a> instances. Notice that <code>timeseries</code> <strong>always mutates the billiard</strong> if ray-splitting is used! For more information and instructions on using ray-splitting please visit the official documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/timeevolution/timeseries.jl#L107-L141">source</a></section></article><hr/><p>For example:</p><pre><code class="language-julia">xt, yt, vxt, vyt, t = timeseries(p, bd, 100)

# print as a matrix:
hcat(xt, yt, vxt, vyt, t)[1:5, :]</code></pre><pre><code class="language-none">5×5 Array{Float64,2}:
 -0.346682  0.806267    0.0699295  -0.997552  0.0     
 -0.297016  0.0977792   0.973965    0.226699  0.710227
  1.49974   0.515991   -0.986465    0.16397   2.55502 
 -0.377377  0.828004    0.29979    -0.954005  4.45789 
 -0.121924  0.0150934   0.715359    0.698757  5.31    </code></pre><p>Same story for magnetic particles:</p><pre><code class="language-julia"># evolve the magnetic particle instead:
xt, yt, vxt, vyt, t = timeseries(mp, bd, 100)

# print as a matrix:
hcat(xt, yt, vxt, vyt, t)[1:5, :]</code></pre><pre><code class="language-none">5×5 Array{Float64,2}:
 0.205866  0.28315   0.908413  -0.418075  0.0 
 0.214961  0.278992  0.910492  -0.413528  0.01
 0.224076  0.27488   0.912548  -0.40897   0.02
 0.233212  0.270813  0.914581  -0.404402  0.03
 0.242368  0.266792  0.916592  -0.399824  0.04</code></pre><p>Sometimes we may need information about which obstacles a particle visited, in which sequence, and when. For this we have the following function:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.visited_obstacles!" href="#DynamicalBilliards.visited_obstacles!"><code>DynamicalBilliards.visited_obstacles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visited_obstacles!([p::AbstractParticle,] bd::Billiard, t)</code></pre><p>Evolve the given particle <code>p</code> inside the billiard <code>bd</code> exactly like <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a>. However return only:</p><ul><li><code>ts::Vector{T}</code> : Vector of time points of when each collision occured.</li><li><code>obst::Vector{Int}</code> : Vector of obstacle indices in <code>bd</code> that the particle collided with at the time points in <code>ts</code>.</li></ul><p>The first entries are <code>0.0</code> and <code>0</code>. Similarly with <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a> the function does not record collisions with periodic walls.</p><p>Currently does not support raysplitting. Returns empty arrays for pinned particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/timeevolution/highleveltimes.jl#L122-L137">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Type of `t`</header><div class="admonition-body"><p>Remember that the behavior of time evolution depends on the type of the <code>t</code> argument, which represents &quot;total amount&quot;. If it is <code>AbstractFloat</code>, it represents total amount of time, but if it is <code>Int</code> it represents total number of collisions.</p></div></div><h2 id="Poincaré-Sections-1"><a class="docs-heading-anchor" href="#Poincaré-Sections-1">Poincaré Sections</a><a class="docs-heading-anchor-permalink" href="#Poincaré-Sections-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.psos" href="#DynamicalBilliards.psos"><code>DynamicalBilliards.psos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">psos(bd::Billiard, plane::InfiniteWall, t, particles)</code></pre><p>Compute the Poincaré section of the <code>particles</code> with the given <code>plane</code>, by evolving each one for time <code>t</code> (either integer or float) inside <code>bd</code>.</p><p>The <code>plane</code> can be an <a href="../../tutorials/billiard_table/#DynamicalBilliards.InfiniteWall"><code>InfiniteWall</code></a> of <em>any</em> orientation, however only crossings of the <code>plane</code> such that <code>dot(velocity, normal) &lt; 0</code> are allowed, with <code>normal</code> the normal unit vector of the <code>plane</code>.</p><p><code>particles</code> can be:</p><ul><li>A single particle.</li><li>A <code>Vector</code> of particles.</li><li>An integer <code>n</code> optionally followed by an angular velocity <code>ω</code>.</li></ul><p>Return the positions <code>poss</code> and velocities <code>vels</code> at the instances of crossing the <code>plane</code>. If given more than one particle, the result is a vector of vectors of vectors.</p><p><em>Notice</em> - This function can handle pinned particles. If a pinned particle can intersect with the <code>plane</code>, then an intersection is returned. If however it can&#39;t then empty vectors are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/poincare.jl#L3-L24">source</a></section></article><hr/><p>For example, the surface of section in the periodic Sinai billiard with magnetic field reveals the mixed nature of the phase-space:</p><pre><code class="language-julia">using DynamicalBilliards, PyPlot
t = 100; r = 0.15
bd = billiard_sinai(r, setting = &quot;periodic&quot;)

# the direction of the normal vector is IMPORTANT!!!
# (always keep in mind that ω &gt; 0  means counter-clockwise rotation!)
plane = InfiniteWall([0.5, 0.0], [0.5, 1.0], [-1.0, 0.0])

posvector, velvector = psos(bd, plane, t, 1000, 2.0)
c(a) = length(a) == 1 ? &quot;C1&quot; : &quot;C0&quot;

figure()
for i in 1:length(posvector)
    poss = posvector[i] # vector of positions
    vels = velvector[i] # vector of velocities at the section
    L = length(poss)
    if L &gt; 0
        #plot y vs vy
        y = [a[2] for a in poss]
        vy = [a[2] for a in vels]

        plot(y, vy, ls = &quot;None&quot;, color = c(y), ms = 2.0, alpha = 0.75, marker = &quot;o&quot;)
    end
end
xlabel(&quot;\$y\$&quot;); ylabel(&quot;\$v_y\$&quot;)</code></pre><p><img src="../psos.png" alt/></p><div class="admonition is-info"><header class="admonition-header">`psos` operates on the unit cell</header><div class="admonition-body"><p>The <code>psos</code> function always calculates the crossings <em>within</em> the unit cell of a periodic billiard. This means that no information about the &quot;actual&quot; position of the particle is stored, everything is modulo the unit cell.</p><p>This can be seen very well in the above example, where there aren&#39;t any entries in the region <code>0.5 - r ≤ y ≤ 0.5 + r</code>.</p></div></div><p>Of course it is very easy to &quot;re-normalize&quot; the result such that it is coherent. The only change we have to do is simply replace the line <code>y = [a[2] for a in poss]</code> with</p><pre><code class="language-julia">y = [a[2] &lt; 0.5 ? a[2] + 1 : a[2]  for a in poss]</code></pre><h2 id="Escape-Times-1"><a class="docs-heading-anchor" href="#Escape-Times-1">Escape Times</a><a class="docs-heading-anchor-permalink" href="#Escape-Times-1" title="Permalink"></a></h2><p>It is very easy to create your own function that calculates an &quot;escape time&quot;: the time until the particle leaves the billiard by meeting a specified condition. There is also a high-level function for this though:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.escapetime" href="#DynamicalBilliards.escapetime"><code>DynamicalBilliards.escapetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">escapetime([p,] bd, t; warning = false)</code></pre><p>Calculate the escape time of a particle <code>p</code> in the billiard <code>bd</code>, which is the time until colliding with any &quot;door&quot; in <code>bd</code>. As a &quot;door&quot; is considered any <a href="../../tutorials/billiard_table/#DynamicalBilliards.FiniteWall"><code>FiniteWall</code></a> with field <code>isdoor = true</code>.</p><p>If the particle evolves for more than <code>t</code> (integer or float) without colliding with the <code>Door</code> (i.e. escaping) the returned result is <code>Inf</code>.</p><p>A warning can be thrown if the result is <code>Inf</code>. Enable this using the keyword <code>warning = true</code>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/timeevolution/highleveltimes.jl#L5-L20">source</a></section></article><p>To create a &quot;door&quot; simply use <a href="../../tutorials/billiard_table/#DynamicalBilliards.FiniteWall"><code>FiniteWall</code></a>.</p><p>For example, the default implementation of the mushroom billiard has a &quot;door&quot; at the bottom of the stem. Thus,</p><pre><code class="language-julia">using Statistics
bd = billiard_mushroom()
et = zeros(100)
for i ∈ 1:100
    particle = randominside(bd)
    et[i] = escapetime(particle, bd, 10000)
end
println(&quot;Out of 100 particles, $(count(x-&gt; x != Inf, et)) escaped&quot;)
println(&quot;Mean escape time was $(mean(et[et .!= Inf]))&quot;)</code></pre><pre><code class="language-none">Out of 100 particles, 25 escaped
Mean escape time was 3.2836953516549294</code></pre><p>Of course, <code>escapetime</code> works with <code>MagneticParticle</code> as well</p><pre><code class="language-julia">escapetime(randominside(bd, 1.0), bd, 10000)</code></pre><pre><code class="language-none">2.9678560963937612</code></pre><h2 id="Mean-Collision-Times-1"><a class="docs-heading-anchor" href="#Mean-Collision-Times-1">Mean Collision Times</a><a class="docs-heading-anchor-permalink" href="#Mean-Collision-Times-1" title="Permalink"></a></h2><p>Because the computation of a mean collision time (average time between collisions in a billiard) is often a useful quantity, the following function computes it</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.meancollisiontime" href="#DynamicalBilliards.meancollisiontime"><code>DynamicalBilliards.meancollisiontime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">meancollisiontime([p,] bd, t) → κ</code></pre><p>Compute the mean collision time <code>κ</code> of the particle <code>p</code> in the billiard <code>bd</code> by evolving for total amount <code>t</code> (either float for time or integer for collision number).</p><p>Collision times are counted only between obstacles that are <em>not</em> <a href="../../tutorials/billiard_table/#DynamicalBilliards.PeriodicWall"><code>PeriodicWall</code></a>.</p><p>If a particle is not given, a random one is picked through <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>. See <a href="#DynamicalBilliards.parallelize"><code>parallelize</code></a> for a parallelized version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/timeevolution/highleveltimes.jl#L70-L80">source</a></section></article><p>For example,</p><pre><code class="language-julia">bd = billiard_sinai()
meancollisiontime(randominside(bd), bd, 10000.0)</code></pre><pre><code class="language-none">0.4514883673226089</code></pre><h2 id="Parallelization-1"><a class="docs-heading-anchor" href="#Parallelization-1">Parallelization</a><a class="docs-heading-anchor-permalink" href="#Parallelization-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.parallelize" href="#DynamicalBilliards.parallelize"><code>DynamicalBilliards.parallelize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parallelize(f, bd::Billiard, t, particles; partype = :threads)</code></pre><p>Parallelize function <code>f</code> across the available particles. The parallelization type can be <code>:threads</code> or <code>:pmap</code>, which use threads or a worker pool initialized with <code>addprocs</code> <em>before</em> <code>using DynamicalBilliards</code>.</p><p><code>particles</code> can be:</p><ul><li>A <code>Vector</code> of particles.</li><li>An integer <code>n</code> optionally followed by an angular velocity <code>ω</code>. This uses <a href="#DynamicalBilliards.randominside"><code>randominside</code></a>.</li></ul><p>The functions usable here are:</p><ul><li><a href="#DynamicalBilliards.meancollisiontime"><code>meancollisiontime</code></a></li><li><a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a></li><li><a href="../../lyapunovs/#DynamicalBilliards.lyapunovspectrum"><code>lyapunovspectrum</code></a> (returns only the maximal exponents)</li><li><a href="../phasespaces/#DynamicalBilliards.boundarymap"><code>boundarymap</code></a> (returns vector of vectors of 2-vectors <em>and</em> <code>arcintervals</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/parallel.jl#L9-L25">source</a></section></article><hr/><p>Here are some examples</p><pre><code class="language-julia">bd = billiard_stadium()
particles = [randominside(bd) for i in 1:1000]
parallelize(meancollisiontime, bd, 1000, particles)</code></pre><pre><code class="language-none">1000-element Array{Float64,1}:
 1.1085296239007723
 1.0496637135974072
 1.1000208752313256
 1.0700699971004486
 1.0859107381078767
 1.1107906470500497
 1.0895269514611938
 1.099612276226488 
 1.023890379410691 
 1.1001838076561434
 ⋮                 
 1.1088606302423045
 1.086564065058984 
 1.0789770921922215
 1.073719858884873 
 1.1041727034059583
 1.0852572651006387
 1.1226653446669608
 1.1252127711731394
 1.1139447591403162</code></pre><pre><code class="language-julia">parallelize(lyapunovspectrum, bd, 1000, particles)</code></pre><pre><code class="language-none">1000-element Array{Float64,1}:
 0.8507820941145596
 0.9184103207173984
 0.844687409859144 
 0.8358953758376533
 0.8842156946216801
 0.8809043266124217
 0.8330548658574854
 0.8387763843350974
 0.8840352117862595
 0.8087270886503964
 ⋮                 
 0.7944984498511086
 0.7607244773958446
 0.914172382050005 
 0.7747544144951973
 0.850208677395982 
 0.7825964227934832
 0.8773431474276789
 0.8457772760671267
 0.9156263847378749</code></pre><h2 id="It&#39;s-all-about-bounce!-1"><a class="docs-heading-anchor" href="#It&#39;s-all-about-bounce!-1">It&#39;s all about bounce!</a><a class="docs-heading-anchor-permalink" href="#It&#39;s-all-about-bounce!-1" title="Permalink"></a></h2><p>The main propagation algorithm used by <code>DynamicalBilliards</code> is bundled in the following well-behaving function:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.bounce!" href="#DynamicalBilliards.bounce!"><code>DynamicalBilliards.bounce!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bounce!(p::AbstractParticle, bd::Billiard) → i, t, pos, vel</code></pre><p>&quot;Bounce&quot; the particle (advance for one collision) in the billiard. Takes care of finite-precision issues.</p><p>Return:</p><ul><li>index of the obstacle that the particle just collided with</li><li>the time from the previous collision until the current collision <code>t</code></li><li>position and velocity of the particle at the current collision (<em>after</em> the collision has been resolved!). The position is given in the unit cell of periodic billiards. Do <code>pos += p.current_cell</code> for the position in real space.</li></ul><pre><code class="language-julia">bounce!(p, bd, raysplit) → i, t, pos, vel</code></pre><p>Ray-splitting version of <code>bounce!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/timeevolution/propagation.jl#L9-L25">source</a></section></article><hr/><p><code>bounce!</code> is the function used internally by all high-level functions, like <a href="#DynamicalBilliards.evolve!"><code>evolve!</code></a>, <a href="../phasespaces/#DynamicalBilliards.boundarymap"><code>boundarymap</code></a>, <a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a>, etc.</p><p>This is the function a user should use if they want to calculate other things besides what is already available in the high level API.</p><h2 id="Standard-Billiards-Library-1"><a class="docs-heading-anchor" href="#Standard-Billiards-Library-1">Standard Billiards Library</a><a class="docs-heading-anchor-permalink" href="#Standard-Billiards-Library-1" title="Permalink"></a></h2><div class="admonition is-success"><header class="admonition-header">You can also use keywords!</header><div class="admonition-body"><p>All standard billiards have a function version that accepts keyword arguments instead of positional arguments, for ease of use.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_rectangle" href="#DynamicalBilliards.billiard_rectangle"><code>DynamicalBilliards.billiard_rectangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_rectangle(x=1.0, y=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a rectangle billiard of size (<code>x</code>, <code>y</code>).</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li><li>&quot;ray-splitting&quot; : All obstacles in the billiard allow for ray-splitting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/standard_billiards.jl#L11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_sinai" href="#DynamicalBilliards.billiard_sinai"><code>DynamicalBilliards.billiard_sinai</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_sinai(r=0.25, x=1.0, y=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a Sinai billiard of size (<code>x</code>, <code>y</code>) with a disk in its center, of radius <code>r</code>.</p><p>In the periodic case, the system is also known as &quot;Lorentz Gas&quot;.</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li><li>&quot;ray-splitting&quot; : All obstacles in the billiard allow for ray-splitting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/standard_billiards.jl#L70-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_bunimovich" href="#DynamicalBilliards.billiard_bunimovich"><code>DynamicalBilliards.billiard_bunimovich</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_bunimovich(l=1.0, w=1.0)</code></pre><p>Return a vector of <code>Obstacle</code>s that define a Buminovich billiard, also called a stadium. The length is considered <em>without</em> the attached semicircles, meaning that the full length of the billiard is <code>l + w</code>. The left and right edges of the stadium are <a href="../../tutorials/billiard_table/#DynamicalBilliards.Semicircle"><code>Semicircle</code></a>s.</p><p><code>billiard_stadium</code> is an alias of <code>billiard_bunimovich</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/standard_billiards.jl#L271-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_mushroom" href="#DynamicalBilliards.billiard_mushroom"><code>DynamicalBilliards.billiard_mushroom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_mushroom(sl = 1.0, sw = 0.2, cr = 1.0, sloc = 0.0; door = true)</code></pre><p>Create a mushroom billiard with stem length <code>sl</code>, stem width <code>sw</code> and cap radius <code>cr</code>. The center of the cap (which is Semicircle) is always at <code>[0, sl]</code>. The center of the stem is located at <code>sloc</code>.</p><p>Optionally, the bottom-most <code>Wall</code> is a <code>Door</code> (see <a href="#DynamicalBilliards.escapetime"><code>escapetime</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/standard_billiards.jl#L234-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_polygon" href="#DynamicalBilliards.billiard_polygon"><code>DynamicalBilliards.billiard_polygon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_polygon(n::Int, R, center = [0,0]; setting = &quot;standard&quot;)</code></pre><p>Return a vector of obstacles that defines a regular-polygonal billiard with <code>n</code> sides, radius <code>r</code> and given <code>center</code>.</p><p>Note: <code>R</code> denotes the so-called outer radius, not the inner one.</p><p><strong>Settings</strong></p><ul><li>&quot;standard&quot; : Specular reflection occurs during collision.</li><li>&quot;periodic&quot; : The walls are <code>PeriodicWall</code> type, enforcing periodicity at the boundaries. Only available for <code>n=4</code> or <code>n=6</code>.</li><li>&quot;random&quot; : The velocity is randomized upon collision.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/standard_billiards.jl#L113-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_vertices" href="#DynamicalBilliards.billiard_vertices"><code>DynamicalBilliards.billiard_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_vertices(v, type = FiniteWall)</code></pre><p>Construct a polygon billiard that connects the given vertices <code>v</code> (vector of 2-vectors). The vertices should construct a billiard in a counter-clockwise orientation (i.e. the normal vector always points to the left of <code>v[i+1] - v[i]</code>.).</p><p><code>type</code> decides what kind of walls to use. Ths function assumes that the first entry of <code>v</code> should be connected with the last.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/standard_billiards.jl#L371-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_iris" href="#DynamicalBilliards.billiard_iris"><code>DynamicalBilliards.billiard_iris</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_iris(a=0.2, b=0.4, w=1.0; setting = &quot;standard&quot;)</code></pre><p>Return a billiard that is a square of side <code>w</code> enclosing at its center an ellipse with semi axes <code>a</code>, <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/standard_billiards.jl#L358-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_hexagonal_sinai" href="#DynamicalBilliards.billiard_hexagonal_sinai"><code>DynamicalBilliards.billiard_hexagonal_sinai</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_hexagonal_sinai(r, R, center = [0,0]; setting = &quot;standard&quot;)</code></pre><p>Create a sinai-like billiard, which is a hexagon of outer radius <code>R</code>, containing at its center (given by <code>center</code>) a disk of radius <code>r</code>. The <code>setting</code> keyword is passed to <code>billiard_polygon</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/standard_billiards.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_raysplitting_showcase" href="#DynamicalBilliards.billiard_raysplitting_showcase"><code>DynamicalBilliards.billiard_raysplitting_showcase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_raysplitting_showcase(x=2.0, y=1.0, r1=0.3, r2=0.2) -&gt; bd, rayspl</code></pre><p>Showcase example billiard for ray-splitting processes. A rectangle <code>(x,y)</code> with a SplitterWall at <code>x/2</code> and two disks at each side, with respective radii <code>r1</code>, <code>r2</code>.</p><p><strong>Notice</strong>: This function returns a billiard <code>bd</code> as well as a <code>rayspl</code> dictionary!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/standard_billiards.jl#L197-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.billiard_logo" href="#DynamicalBilliards.billiard_logo"><code>DynamicalBilliards.billiard_logo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">billiard_logo(;h=1.0, α=0.8, r=0.18, off=0.25) -&gt; bd, ray</code></pre><p>Create the billiard used as logo of <code>DynamicalBilliards</code> and return it along with the tuple of raysplitters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/standard_billiards.jl#L294-L298">source</a></section></article><h2 id="Particle-types-1"><a class="docs-heading-anchor" href="#Particle-types-1">Particle types</a><a class="docs-heading-anchor-permalink" href="#Particle-types-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.Particle" href="#DynamicalBilliards.Particle"><code>DynamicalBilliards.Particle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Particle(ic::Vector{T}) #where ic = [x0, y0, φ0]
Particle(x0, y0, φ0)
Particle(pos::SVector, vel::SVector)</code></pre><p>Create a particle with initial conditions <code>x0, y0, φ0</code>. It propagates as a straight line.</p><p>The field <code>current_cell</code> shows at which cell of a periodic billiard is the particle currently located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/particles.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalBilliards.MagneticParticle" href="#DynamicalBilliards.MagneticParticle"><code>DynamicalBilliards.MagneticParticle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MagneticParticle(ic::AbstractVector{T}, ω::Real) # where ic = [x0, y0, φ0]
MagneticParticle(x0, y0, φ0, ω)
MagneticParticle(pos::SVector, vel::SVector, ω)
MagneticParticle(p::AbstractParticle, ω)</code></pre><p>Create a <em>magnetic</em> particle with initial conditions <code>x0, y0, φ0</code> and angular velocity <code>ω</code>. It propagates as a circle instead of a line, with radius <code>1/abs(ω)</code>.</p><p>The field <code>current_cell</code> shows at which cell of a periodic billiard is the particle currently located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalBilliards.jl/blob/3781b3e9d03cd91c7297d79a8a6ba8adbba06ba0/src/billiards/particles.jl#L56-L69">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><a class="docs-footer-nextpage" href="../../visualizing/">Visualizing &amp; Animating »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 12 March 2020 19:24">Thursday 12 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
